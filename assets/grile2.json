{
  "subjects": [
    {
      "name": "Algoritmi si programare",
      "questions": [
        {
          "id": 1,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n#include <stdio.h>\nvoid main(){\n    int a,b = 0;\n    int i;\n    for (i=0;i<10;i++){\n        b = a;\n        a = i;\n    }\nprintf(\"%d\", b);\n}",
          "options": {
            "A": "8",
            "B": "9",
            "C": "10",
            "D": "0123456789"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. 8.\n\nExplanation: In this program, two integer variables `a` and `b` are declared, with `b` initialized to 0 and `a` left uninitialized. The `for` loop iterates from `i = 0` to `i = 9`. In each iteration, the value of `a` is assigned to `b`, and then `i` is assigned to `a`. By the end of the loop, `a` holds the last value of `i`, which is 9, and `b` holds the previous value of `a`, which was 8 (the value of `i` in the second-to-last iteration). Therefore, when `printf"
        },
        {
          "id": 2,
          "text": "Care din urmatoarele expresii sunt echivalente cu a[i]?",
          "options": {
            "A": "*(a+i)",
            "B": "i[a]",
            "C": "&a[i]",
            "D": "*(a+a)",
            "E": "*(a+i*sizeof(a[i]))"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "In C and C++ programming, arrays and pointers are closely related, and the expression `a[i]` is equivalent to pointer arithmetic.\n\n- A. `*(a+i)`: This expression is equivalent to `a[i]` because `a[i]` is essentially syntactic sugar for `*(a+i)`, where `a` is the base address of the array and `i` is the offset from that address. By adding `i` to `a`, you get the address of the `i`-th element, and then dereferencing it with `*` gives you the element itself.\n\n- B. `i[a]`: This might seem unusual, but it is also valid and equivalent to `a[i]`."
        },
        {
          "id": 3,
          "text": "Instructiunea k++ este echivalenta cu:",
          "options": {
            "A": "k = k + 1",
            "B": "k += 1",
            "C": "++k",
            "D": "k = k + k",
            "E": "k += k",
            "F": "k = k + sizeof(k)"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "The question asks which of the given options are equivalent to the expression `k++` in terms of incrementing the value of `k` by one. \n\n- **Option A: `k = k + 1`** - This directly increases the value of `k` by 1, which is exactly what `k++` does.\n- **Option B: `k += 1`** - This is a shorthand for `k = k + 1`, thus also increases the value of `k` by 1.\n- **Option C: `++k`** - This is the pre-increment operator that increases the value of `k` by 1 before its current expression is evaluated, but ultimately results in the"
        },
        {
          "id": 4,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program? \n\n#include <stdio.h>\nint a,b;\nvoid f1 (int *r, int *s){\n    int temp;\n    temp = *r;\n    *r = *s;\n    *s = temp;\n}\nvoid f2 (int *x, int *y){\n    if (*x > *y) f1(x,y);\n}\nmain(){\n    a = 64;\n    b = 42;\n    f2(&a,&b);\n    printf(\"%d,%d\\n\",a,b);\n}",
          "options": {
            "A": "42,64",
            "B": "64,42",
            "C": "64,64",
            "D": "42,42",
            "E": "eroare de compilare pentru ca lipseste void la declararea functiei main"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The program defines two global integer variables, `a` and `b`, and two functions, `f1` and `f2`. The function `f1` swaps the values of the two integers pointed to by its parameters `r` and `s`. The function `f2` calls `f1` to swap its parameters only if the first parameter is greater than the second.\n\nIn the `main` function, `a` is initialized to 64 and `b` to 42. The function `f2` is then called with the addresses of `a` and `b`. Since `a` (64) is greater than `b` (42), `f2` calls `f1` to swap their"
        },
        {
          "id": 5,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program? \n\n#include <stdio.h>\nint a,b;\nvoid f1 (int r, int s){\n    int temp;\n    temp = r;\n    r = s;\n    s = temp;\n}\nvoid f2 (int x, int y){\n    if (x > y) f1(x,y);\n}\nvoid main(){\n    a = 064;\n    b = 042;\n    f2(a,b);\n    printf(\"%d,%d\\n\",a,b);\n}",
          "options": {
            "A": "52,34",
            "B": "64,42",
            "C": "42,62",
            "D": "34,52",
            "E": "0,0",
            "F": "rezultatul nu poate fi determinat avand in vedere valorile variabilelor a si b"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The program declares two global integer variables `a` and `b`. In the `main` function, these variables are initialized with octal values `064` and `042`, which are equivalent to decimal `52` and `34`, respectively. The function `f2` is called with `a` and `b` as arguments, but it only calls `f1` if `x` is greater than `y`. Since `52` is greater than `34`, `f1` is called. However, `f1` swaps the local copies of its parameters `r` and `s`, not the global variables `a` and `b`. Thus, the actual values of `a` and `b` remain unchanged"
        },
        {
          "id": 6,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program? \n\n#include <stdio.h>\nvoid main(){\n    int k[ ] = {100,200,300,400,500,600,700};\n    int *t=k+2;\n    printf(\"%d \",*t);\n    printf(\"%d \",*(t+2) + *t);\n    *t = *t + 10;\n    printf(\"%d \",*t);\n    t = t+3;\n    printf(\"%d \",*t);\n    *t = *t + *(t-2);\n    printf(\"%d \",*t);\n}",
          "options": {
            "A": "300 800 310 600 1000",
            "B": "200 300 110 600 1100",
            "C": "300 900 320 600 1000",
            "D": "300 800 310 600 900",
            "E": "100 900 310 600 1000",
            "F": "nici una din variante nu este corecta"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To understand what the program will output, let's go through each step of the code execution:\n\n1. **Initialization**:\n   - An array `k` is initialized with values `{100, 200, 300, 400, 500, 600, 700}`.\n   - A pointer `t` is set to point to the third element of the array `k` (i.e., `k[2]`), which is `300`.\n\n2. **First `printf`**:\n   - `printf(\"%d \",*t);` prints the value pointed to by `t`, which is `300`.\n\n3. **Second `printf`**:\n   - `printf(\"%d \",*(t+2) +"
        },
        {
          "id": 7,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main(){\n    int p[] = {50,60,70,80,90,100};\n    int *q[6],i;\n    for(i =0;i<6;i++)\n    q[i] = &p[i];\n    for(i=5;i>=1;i--){\n        q[i] = q[i-1];\n        *q[i] = *q[i] + *p * 2;\n    }\nfor(i=0;i<6;i++)\nprintf(\"%d \",p[i]);\n}",
          "options": {
            "A": "150 160 170 180 190 100",
            "B": "160 160 170 180 190 100",
            "C": "150 150 150 150 150 150",
            "D": "150 160 170 180 190 190",
            "E": "150 160 170 180 190 200",
            "F": "nici una din variante nu este corecta"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To understand what the program outputs, let's break down the code:\n\n1. **Initialization**: An array `p` is declared with values `{50, 60, 70, 80, 90, 100}`. An array of integer pointers `q` is also declared.\n\n2. **Pointer Assignment**: The first loop assigns each element of `q` to point to the corresponding element in `p`. After this loop, `q[i]` points to `p[i]` for all valid indices `i`.\n\n3. **Modification Loop**: The second loop iterates from `i = 5` to `i = 1`. In each iteration:\n   - `q[i]` is set to `"
        },
        {
          "id": 8,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid f(int *x){\n    x=(int *) malloc(sizeof(int));\n    *x=12;\n}\nvoid main(){\n    int v=15/10;\n    f(&v);\n    printf(\"%d\",v);\n}",
          "options": {
            "A": "1",
            "B": "12",
            "C": "15",
            "D": "1.5",
            "E": "adresa variabilei v",
            "F": "adresa variabilei x"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The program demonstrates how pointer manipulation and memory allocation work in C. In the `main` function, the integer `v` is calculated as `15/10`, which results in `1` due to integer division (since both 15 and 10 are integers, the division discards the fractional part). The function `f` is then called with the address of `v` as an argument. Inside `f`, the pointer `x` is assigned a new memory location using `malloc`, and the value `12` is stored in that newly allocated space. However, this does not affect the original variable `v` in `main`, because `x` is a local copy of the pointer and changes to `x` do not affect"
        },
        {
          "id": 9,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main(){\n    int i, p=0x10;\n    for(i=1;;i+=2){\n        if (i=5)\n        break;\n        p+=i;\n    }\nprintf(\"%d\",p);\n}",
          "options": {
            "A": "16",
            "B": "10",
            "C": "26",
            "D": "25",
            "E": "14",
            "F": "programul cicleaza la infinit"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The given C program has a logical error in the `if` statement within the `for` loop. The condition `if (i=5)` is intended to compare `i` to 5, but due to the use of a single equals sign (`=`), it actually assigns the value 5 to `i` instead of comparing. This means that `i` will always be set to 5 during the first iteration of the loop, and the `break` statement will be executed immediately, terminating the loop.\n\nBefore entering the loop, `p` is initialized to `0x10`, which is the hexadecimal representation of 16 in decimal. Since the loop breaks before any addition to `p` occurs, the value of `p"
        },
        {
          "id": 10,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nint a = 10, b = 5;\nvoid f (int a, int t[]){\n    b = a;\n    t[2] = a % 2;\n    a = (t[0]+t[1])/2;\n    t[0]^=t[1];\n    t[1]^=t[0];\n    t[0]^=t[1];\n}\nvoid main(){\n    int t[]={4,3,1};\n    f(t[2],t);\n    printf(\"%d %d %d %d %d\",a,b,t[0],t[1],t[2]);\n}",
          "options": {
            "A": "10 1 3 4 1",
            "B": "10 5 4 3 1",
            "C": "1 5 3 4 1",
            "D": "7 5 3 4 1",
            "E": "5 5 10 4 0",
            "F": "nici una din variante nu este corecta"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Let's analyze the program step by step:\n\n1. **Global Variables Initialization:**\n   - `int a = 10, b = 5;` initializes global variables `a` and `b`.\n\n2. **Function `f`:**\n   - The function `f` takes an integer `a` and an array `t[]`.\n   - Inside the function:\n     - `b = a;` assigns the value of the passed `a` (which is `t[2]` or 1) to global `b`. So, `b` becomes 1.\n     - `t[2] = a % 2;` calculates `1 % 2`, which is 1, and assigns it to `"
        },
        {
          "id": 11,
          "text": "Consideram urmatoarea secventa de program?\n\nfloat x = 10;\nint y = 7;\nfloat t[]={3,4,1};\nfloat *q = &x;\nint *r = &y;\nvoid *p;\n\nCare din urmatoarele atribuiri sunt corecte?",
          "options": {
            "A": "q = t;",
            "B": "p = t;",
            "C": "p = &y;",
            "D": "p = r;",
            "E": "x = &t[2];",
            "F": "t = q;",
            "G": "q = r;",
            "H": "r = q;",
            "I": "r = p;"
          },
          "correct_answer": [
            "A",
            "B",
            "C",
            "D"
          ],
          "explanation": "In this question, we are asked to determine which assignments are valid given the provided variable declarations and types in C programming.\n\nLet's analyze each option:\n\nA. `q = t;` - This assignment is valid because `q` is a pointer to `float` and `t` is an array of `float`. The array name `t` can be used as a pointer to its first element, so assigning it to `q` is correct.\n\nB. `p = t;` - This assignment is valid because `p` is a `void *`, which is a generic pointer type. A `void *` can point to any data type, including the `float` array `t`.\n\nC. `p = &y;"
        },
        {
          "id": 12,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main(){\n    char s[]=\"abcdef\";\n    char *p,*q,c;\n    p=s;\n    q=p+4;\n    while(p < q){\n        c=*p;\n        *p=*q;\n        *q=++c;\n        p++;q--;\n    }\nprintf(\"%s\",s);\n}",
          "options": {
            "A": "edccbf",
            "B": "fedcba",
            "C": "feddca",
            "D": "edcbaf",
            "E": "bcdefg",
            "F": "nici una din variante nu este corecta"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The given program manipulates a string through pointer operations and prints the final result. Here's a step-by-step explanation:\n\n1. **Initialization**:\n   - The string `s` is initialized as `\"abcdef\"`.\n   - Pointer `p` is set to the beginning of the string (`s`), i.e., pointing to `'a'`.\n   - Pointer `q` is set to `p + 4`, i.e., pointing to `'e'`.\n\n2. **Loop Execution**:\n   - The `while` loop continues as long as `p < q`.\n   \n   **First Iteration**:\n   - `c` is assigned the value pointed by `p`, which is `'a'`.\n   - `*p"
        },
        {
          "id": 13,
          "text": "Care din urmatoarele linii vor genera eroare la compilare?\n\n1: void main() {\n2: int a[2] = {1,2};\n3: int b[3] = {3};\n4: int* x = a;\n5: int* const y = a;\n6: b = x;\n7: b = y;\n8:}",
          "options": {
            "A": "6, 7",
            "B": "3, 5, 6, 7",
            "C": "3, 4, 6, 7",
            "D": "3, 5",
            "E": "5, 6, 7",
            "F": "5",
            "G": "nici una"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the provided code, lines 6 and 7 will generate compilation errors due to incorrect assignment operations involving arrays and pointers. Here's a breakdown of the lines:\n\n1. Line 3 initializes an array `b` with size 3, but only the first element is explicitly initialized. This is valid, as the remaining elements will default to zero.\n2. Line 5 declares `y` as a constant pointer to an integer. This means the pointer itself cannot be changed to point to a different memory location after its initialization.\n3. Line 6 attempts to assign `x` to `b`. In C++, arrays cannot be assigned to each other or to pointers directly. This is because the array name acts as a pointer to its first element"
        },
        {
          "id": 14,
          "text": "Consideram urmatorul program:\n\n1: #include <stdio.h>\n2: void main(){\n3: int t[10];\n4: printf(\"sizeof(int)=%d\\n\",sizeof(int));\n5: printf(\"%p\\n\",t);\n6: printf(\"%p\\n\",t+3);\n7:}\n\nDaca inurmaexecutieiliniilor4si5seafiseaza2respectiv0xF004, cesevaafisa inurmaexecutiei liniei 6?",
          "options": {
            "A": "0xF00A",
            "B": "0xF010",
            "C": "0xF007",
            "D": "0xF006",
            "E": "0xF003"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To determine the output of line 6, we need to understand pointer arithmetic in C. Here's the breakdown:\n\n1. The array `t` is declared as `int t[10];`, meaning it is an array of integers with 10 elements.\n2. The `sizeof(int)` is given to be 2, which means each integer takes 2 bytes of memory.\n3. The expression `t` is the address of the first element of the array `t`. It is given to be `0xF004` from the output of line 5.\n4. When you add an integer `n` to a pointer in C (like `t + 3`), it actually moves the pointer by `n` elements,"
        },
        {
          "id": 15,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main(){\n    int x=7;\n    x = 1,2,3;\n    printf(\"%d\",x);\n}\n\nSolution: Operatorul virgula se evalueaza de la stanga la dreapta. Rezultatul este dat de\nultima valoare a expresiei. Insa, deoarce operatorul = are prioritatea mai mare decat a\noperatorului virgula mai intai se atribuie lui x valoarea 1 si apoi se evalueaza expresia x,2,3,\nrezultat care nu este memorat in nicio variabila.",
          "options": {
            "A": "1",
            "B": "7",
            "C": "2",
            "D": "3",
            "E": "6",
            "F": "nimic (programul nu se compileaza)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the given C program, the expression `x = 1,2,3;` is key to understanding what will be displayed. The comma operator in C evaluates expressions from left to right and returns the value of the rightmost expression. However, in the statement `x = 1,2,3;`, the assignment operator `=` has higher precedence than the comma operator. Therefore, the expression is interpreted as `(x = 1), 2, 3;`. This means that `x` is first assigned the value `1`. The rest of the expression `2, 3` is evaluated, but its result is not used or stored anywhere. Therefore, when `printf(\"%d\",x);` is executed,"
        },
        {
          "id": 16,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main() {\n    int array[3][] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}};\n    int s = 0, i ,j;\n    for (i = 0; i < 3 ; ++i){\n        for (j = 2; j < 3 ; j++){\n            s += array[i][j];\n        }\n}\nprintf(\"%d\",s);\n}\n\nSolution: La declararea tablourilor multidimensionale numai prima dimensiune poate fi omisa.\nIn acest caz, se genereaza eroare de compilare deoarece nu este specificat numarul de coloane.",
          "options": {
            "A": "nimic (programul nu se compileaza)",
            "B": "15",
            "C": "0",
            "D": "27",
            "E": "36"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In C, when declaring multidimensional arrays, all dimensions except the first one must be specified. In the given program, the array `int array[3][] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}};` is missing the size of the second dimension (the number of columns), which is required for the program to compile successfully. Because the number of columns is not specified, the compiler cannot properly allocate memory for the array, leading to a compilation error. Therefore, the program does not compile, and nothing is displayed on the screen. Hence, the correct answer is A: nothing (programul nu se compileaza)."
        },
        {
          "id": 17,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nint f(int y);\nvoid main(){\n    int x = 3;\n    int y = 6;\n    printf(\"%d\", f(x));\n}\nint f(int x){\n    return x+1;\n}",
          "options": {
            "A": "4",
            "B": "7",
            "C": "3",
            "D": "6",
            "E": "nimic (eroare de compilare deoarce functia f a fost apelata inainte de a fi definita)",
            "F": "nimic (eroare de compilare deoarce numele argumentului functiei f este y la declarare si x la definire)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Explanation: The program correctly compiles and runs because the function `f` is declared before it is used in the `main` function. When `main` calls `printf(\"%d\", f(x));`, it passes the value of `x` (which is 3) to the function `f`. The function `f` is defined to take an integer input `x` and return `x + 1`. Therefore, `f(3)` returns `3 + 1`, which is 4. Hence, the program prints `4` to the screen. The names of the parameters in the function declaration and definition do not need to match, as they are scoped locally within their respective functions."
        },
        {
          "id": 18,
          "text": "Cate elemente ale vectorului a vor avea valoarea 9 dupa executia programului de mai jos?:\n\nvoid main(){\n    int a[] = {0, 1, 2, 3, 0, 4, 5, 6};\n    int i = 0, x = 9;\n    do{\n        a[i++] = x;\n    }while(i<6&&a[i]);\n}",
          "options": {
            "A": "nici unul",
            "B": "unu",
            "C": "doua",
            "D": "patru",
            "E": "toate"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The given program initializes an array `a` with specific integer values and then uses a `do-while` loop to modify some of these values. Here's a step-by-step breakdown of the execution:\n\n1. The array `a` is initialized as `{0, 1, 2, 3, 0, 4, 5, 6}`.\n2. The integer `x` is set to `9`, which will be used to replace certain elements in the array.\n3. The loop starts with `i = 0`.\n4. Inside the `do` block, `a[i++] = x;` assigns the value `9` to `a[i]` and then increments `i`.\n5. This"
        },
        {
          "id": 19,
          "text": "Fie urmatorul program:\n\nvoid main (){\n    int v[20], i, n, D;\n    scanf(\"%d\", &n);\n    for(i=0;i<n;i++)\n    v[i]=i%2?i:-i;\n    for(D=1,i=0;i<n;D*=v[i++]);\n    D++;\n    printf(\"%d\",D);\n}\n\nIn urma executiei sale sunt posibile urmatoarele situatii:",
          "options": {
            "A": "Expresia conditionala din primul ciclu for este eronata din punct de vedere sintactic.",
            "B": "Daca variabila n primeste la citire valoarea 6, atunci elementele vectorului v vor fi, in ordine (0,1,-2,3,-4,5).",
            "C": "Prezenta caracterului ” ; ” dupa al doilea ciclu for constituie o eroare",
            "D": "Daca variabila n primeste la citire valoarea 5, atunci programul afiseaza 1",
            "E": "Programul functioneaza corect pentru orice valoare intreaga a lui n mai mica sau egala cu MAXINT."
          },
          "correct_answer": [
            "B",
            "D"
          ],
          "explanation": "The given C program initializes an integer array and performs operations based on user input. Here's a breakdown of the options:\n\nA. The conditional expression in the first `for` loop (`i < n`) is syntactically correct, so this option is incorrect.\n\nB. If `n` is 6, the first `for` loop runs from `i = 0` to `i = 5`. The expression `i % 2 ? i : -i` results in the values being: 0, 1, -2, 3, -4, 5. This matches the sequence described, making this option correct.\n\nC. The presence of a semicolon `;` after the second `for` loop is"
        },
        {
          "id": 20,
          "text": "Fie programul :\n\nvoid main(){\n    int v[]={0, 1, 2, 3, 4, 5, 0};\n    int i=0, n=0;\n    do{\n        if (i == v[i])\n        n++;\n    }while(i<6 && v[i++]);\n}\n\nIn urma executiei programului sunt posibile urmatoarele situatii:",
          "options": {
            "A": "variabila n va avea valoarea 0",
            "B": "variabila n va avea valoarea 1",
            "C": "programul va intra intr-un ciclu infinit",
            "D": "variabila n va avea valoarea 5",
            "E": "variabila n va avea valoarea 2"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The given C program initializes an array `v` with values `{0, 1, 2, 3, 4, 5, 0}` and two integer variables `i` and `n` set to 0. It then enters a `do-while` loop that continues as long as `i` is less than 6 and `v[i++]` is non-zero.\n\nWithin the loop, the condition `if (i == v[i])` checks if the current index `i` is equal to the value at `v[i]`. If true, it increments `n`.\n\nHere's the step-by-step execution:\n\n1. **Iteration 1:** `i = 0`, `v[0] ="
        },
        {
          "id": 21,
          "text": "Se considera secventa urmatoare, in care valorile lui n si x se presupun cunoscute, v este un\nvector cu elementele(v[0],v[1],...,v[n-1])\n\np=n;\nfor(i=0;i<n;i++)\nif (v[i]==x)\np=i;\nfor(i=p+1; i<n; i++)\nv[i-1]=v[i];\nfor(i=0; i<n-1; i++)\nprintf(\"%3d\",v[i])\n\nPrecizati care dintre urmatoarele afirmatii sunt adevarate:",
          "options": {
            "A": "Pentru n=5, x=3 si v=(5,6,2,7,1), se afiseaza ultimele patru elemente nemodificate ale vectorului:6 2 7 1.",
            "B": "Pentru n=5, x=1 si v=(2,1,3,1,4), se afiseaza: 2 3 1 4;",
            "C": "Secventa contine erori de sintaxa",
            "D": "Algoritmul sterge din vector elementul cu valoarea x, prin mutarea cu o pozitie mai la dreapta a elementelor aflate inaintea lui.",
            "E": "Algoritmul sterge din vector elementul cu valoarea x, prin mutarea cu o pozitie mai la stanga a elementelor a(cid:13)ate dupa el."
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "The correct answer is E. Here's the explanation:\n\nThe given code is designed to remove the first occurrence of the element `x` from the vector `v` by shifting the elements that come after `x` one position to the left.\n\n1. **Initialization**: The variable `p` is initialized with the value `n`. This will store the position of the first occurrence of `x` if it is found in the vector.\n\n2. **Finding `x`**: The first `for` loop searches for the first occurrence of `x` in the vector `v`. If `x` is found at position `i`, `p` is updated to `i`.\n\n3. **Shifting Elements**: If `x`"
        },
        {
          "id": 22,
          "text": "In programul urmator, care dintre secventele de instructiuni (I), (II), (III) realizeaza corect \ncitirea unui sir de caractere de la tastatura si afisarea acestuia?\n\nvoid main(){\n    char s1[10],s2[10],s3[10];\n    scanf(\"%s\", &s3[3]);\n    printf(\"%s\", s3[3]); //(I)\n    scanf(\"%s\", s2);\n    printf(\"s2=%s\", s2); //(II)\n    scanf(\"%s\",&s1);\n    printf(\"%s\", s1[10]); //(III)\n}",
          "options": {
            "A": "numai (I)",
            "B": "toate",
            "C": "(I) si (II)",
            "D": "(I) si (III)",
            "E": "numai (II)"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "The correct answer is E, which means only sequence (II) correctly reads a string from the keyboard and displays it. Here's why:\n\n1. **Sequence (I)**: `scanf(\"%s\", &s3[3]);` attempts to read a string starting at the address of `s3[3]`, which is incorrect because it doesn't ensure there's enough space to store the string starting from this position within the `s3` array. Additionally, `printf(\"%s\", s3[3]);` attempts to print a character as a string, which is incorrect and likely to cause undefined behavior.\n\n2. **Sequence (II)**: `scanf(\"%s\", s2);` correctly reads a string into the `s2` array"
        },
        {
          "id": 23,
          "text": "Pentru programul urmator, analizati corectitudinea afirmatiilor de mai jos:\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\nvoid main(){\n    char s1[4], s2[4];\n    long x;\n    scanf(\"%s %s\", s1, s2) ;\n    if (strcmp(s1, s2)>0)\n    x=atol(s1);\n    else\n    if(strcmp(s1, s2)==0)\n    x = 0;\n    else x = atol(s2);\n    printf(\"%d\", x);\n}",
          "options": {
            "A": "Conditiile din cele doua linii if sunt gresite.",
            "B": "Apelurile functiei atol sunt corecte",
            "C": "Daca de la tastatura se introduc sirurile \"98\" si \"123\" atunci se va afisa 98.",
            "D": "Daca de la tastatura se introduc sirurile \"123\" si \"121\", atunci programul va afisa sirul \"123\".",
            "E": ""
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "Let's analyze each statement regarding the given C program:\n\nA. \"Conditiile din cele doua linii if sunt gresite.\"\n   - The conditions in the `if` statements are checking the result of `strcmp`, which is correctly used to compare strings in C. Therefore, this statement is incorrect.\n\nB. \"Apelurile functiei atol sunt corecte.\"\n   - The function `atol` is used to convert a string to a long integer. Given that `s1` and `s2` are expected to be numeric strings (based on program logic), the calls to `atol` are appropriate. Therefore, this statement is correct.\n\nC. \"Daca de la tastatura se introduc sirurile '98'"
        },
        {
          "id": 24,
          "text": "In conformitate cu standardul ASCII, codurile literelor mari sunt succesive incepand cu 65, ce va \nafisa programul de mai jos?\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\nvoid main(){\n    int x = 20, e;\n    char s[15] =\"ABC\", t[15], u[15];\n    e = s[1] + s[2];\n    itoa(e, t, 10);\n    strcpy(u, t);\n    strcat(s, u);\n    printf(\"%s \", s);\n}",
          "options": {
            "A": "Nimic, sirul s fiind vid",
            "B": "ABC13",
            "C": "AB13",
            "D": "ABC133",
            "E": "ABC131"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The program is designed to perform some operations on a string and then print the result. Here's a step-by-step explanation of what's happening:\n\n1. **Initialization**: \n   - `char s[15] = \"ABC\"` initializes the string `s` with the value \"ABC\".\n   - `char t[15], u[15]` are declared as character arrays to store temporary strings.\n   \n2. **Calculating `e`**: \n   - `e = s[1] + s[2]` calculates the sum of the ASCII values of the characters at positions 1 and 2 in the string `s`. \n   - `s[1]` is 'B', which has an ASCII value of"
        },
        {
          "id": 25,
          "text": "Care dintre specificatorii modului de acces al fisierelor binare sau text, pentru functia fopen, sunt corecti:",
          "options": {
            "A": "ab",
            "B": "rb",
            "C": "ap",
            "D": "wt",
            "E": "at",
            "F": "ba",
            "G": "toate variantele sunt corecte"
          },
          "correct_answer": [
            "A",
            "B",
            "D",
            "E"
          ],
          "explanation": "The correct answer for the file access mode specifiers in the `fopen` function is A, B, D, E. Here's a short explanation for each:\n\n- **A. ab**: Opens a binary file for appending. Data is added to the end of the file without removing the existing content. If the file does not exist, it will be created.\n- **B. rb**: Opens a binary file for reading. The file must exist; otherwise, the open operation will fail.\n- **D. wt**: Opens a text file for writing. If the file already exists, its content is erased. If it does not exist, a new file is created.\n- **E. at**: Opens a text file"
        },
        {
          "id": 26,
          "text": "Stiind ca fisierul f1.txt exista in directorul curent iar f2.txt nu este creat, care dintre urmatoarele secvente de instructiuni este gresita?",
          "options": {
            "A": "f1=fopen(”f1.txt”,”w”);",
            "B": "f1=fopen(”f1.txt”,”r+”);",
            "C": "f2=fopen(\"f2.txt\",\"r+\");",
            "D": "f2=fopen(”f2.txt”,”’w+”);",
            "E": "toate variantele anterioare sunt gresite"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The question is about opening files in C using the `fopen` function with different modes. \n\n- Option A (`fopen(\"f1.txt\", \"w\")`): This mode opens the file for writing. If the file exists, its content is erased. Since `f1.txt` exists, this operation is valid.\n- Option B (`fopen(\"f1.txt\", \"r+\")`): This mode opens the file for both reading and writing. The file must exist for this mode to work. Since `f1.txt` exists, this operation is valid.\n- Option C (`fopen(\"f2.txt\", \"r+\")`): This mode opens the file for both reading and writing, but the file must exist beforehand"
        },
        {
          "id": 27,
          "text": "Care este efectul subprogramului alaturat?\n\nvoid X(char *a, char *b){\n    FILE *f,*g;\n    char s[255];\n    f=fopen(a,\"a\");\n    g=fopen(b,\"r\");\n    while(!feof(g)){\n        fgets(s,255,g);\n        fputs(s,f);\n    }\nfclose(f);\nfclose(g);\n}",
          "options": {
            "A": "copiaza continutul fisierului g peste continutul fisierului f",
            "B": "citeste informatiile din cele doua fisiere ale caror nume se transmit ca parametri",
            "C": "concateneaza doua fisiere, rezultatul concatenarii fiind pus in fisierul f",
            "D": "concateneaza doua fisiere, rezultatul concatenarii fiind pus in fisierul g",
            "E": "toate variantele anterioare sunt gresite"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The function `X` takes two file names as parameters: `a` and `b`. It opens file `a` in append mode (`\"a\"`) and file `b` in read mode (`\"r\"`). It then reads each line from file `b` using `fgets` and writes it to file `a` using `fputs`. This effectively appends the entire content of file `b` to the end of file `a`. Thus, the function concatenates the contents of the two files, with the result stored in file `a`. Therefore, the correct answer is C: it concatenates two files, and the result of the concatenation is placed in file `f`."
        },
        {
          "id": 28,
          "text": "Care dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Pentru a inchide un fisier se foloseste functia unlink;",
            "B": "Pentru redenumirea unui fisier in cadrul programului se foloseste functia remove",
            "C": "Pentru a deschide un fisier se foloseste functia fopen",
            "D": "Nu pot fi adaugate informatii intr-un fisier",
            "E": "Toate celelalte variante sunt eronate"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The correct answer is C because the function `fopen` is used to open a file in C programming. Here's a brief explanation for each option:\n\nA. The function `unlink` is used to delete a file, not to close it. To close a file, you use the `fclose` function.\n\nB. The function `remove` is used to delete a file, not to rename it. To rename a file, you use the `rename` function.\n\nC. The function `fopen` is indeed used to open a file, allowing you to specify the mode in which the file should be accessed (e.g., read, write).\n\nD. It is possible to add information to a file by opening it in append or write"
        },
        {
          "id": 29,
          "text": "Ce valori se vor gasi in fisierul numere.txt dupa executia urmatorului program?\n\n#include <conio.h>\n#include <stdio.h>\nFILE *f;\nint i=0, a[10]={20,11,17,4,5,10,14,34,23,11};\nvoid main(){\n    f=fopen(\"c:\\\\numere.txt\",\"w\");\n    for(i=0; i<5; i++){\n        if(a[i]%2!=0)\n        fprintf(f,\"%d \\n\",a[i]);\n    }\nfclose(f);\n}",
          "options": {
            "A": "11 17 5 23 11",
            "B": "20 4 10 14 34",
            "C": "11\n17\n5",
            "D": "11\n17\n5\n23\n11"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The program writes certain values from the array `a` to the file `numere.txt`. It only writes values that are odd (i.e., not divisible by 2) from the first five elements of the array `a`. The array `a` is initialized with the values `{20, 11, 17, 4, 5, 10, 14, 34, 23, 11}`. The loop in the program iterates from `i = 0` to `i < 5`, thus considering only the first five elements of `a`: 20, 11, 17, 4, and 5. Out of these, only 11, 17, and 5"
        },
        {
          "id": 30,
          "text": "Ce se intampla in urma executiei urmatorului program daca fisierul nr.txt contine\nvalorile 7 14 6 3 8 10 ?FILE *f, *g;\nint x;\nvoid main(){\n    f=fopen(\"nr.txt\",\"r+\");\n    g=fopen(\"nr2.txt\",\"w+\");\n    while(!feof(f)){\n        fscanf(f,\"%d\", &x);\n        if(x%2==0)\n        fprintf(g,\"%d \\n\",x);\n    }\nfclose(f);\nfclose(g);\n}",
          "options": {
            "A": "Fisierul nr2.txt va contine valorile 14 6 8 10",
            "B": "Fisierul nr2.txt va contine valorile 14 6 8 10, fiecare pe alta linie",
            "C": "Fisierul nr.txt va contine valorile 7 14 6 8 10",
            "D": "Fisierul nr.txt va contine valorile 7 14 6 8 10, fiecare pe alta linie"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The given C program reads integers from the file \"nr.txt\" and writes only the even numbers to the file \"nr2.txt\". The `fscanf` function reads each integer from \"nr.txt\", and the `if` statement checks if the integer is even by using the condition `x%2==0`. If the number is even, it is written to \"nr2.txt\" followed by a newline character (`\\n`), which ensures that each even number is printed on a new line. The loop continues until the end of the file is reached. Therefore, the correct answer is B, as \"nr2.txt\" will contain the even numbers 14, 6, 8, and 10, each on a separate"
        }
      ]
    },
    {
      "name": "Structuri de date si tehnici de elaborare a algoritmilor",
      "questions": [
        {
          "id": 1,
          "text": "Se da urmatorul algoritm:\nCare vor fi valorile vectorului a dupa terminarea pasului i=5, a=(8;6;4;2;3;5;7)?",
          "image": "structuri_1.png",
          "options": {
            "A": "(2;3;4;5;6;8;7)",
            "B": "(2;3;4;5;8;7;6)",
            "C": "(2;3;4;8;7;6;5)",
            "D": "(8;7;6;5;4;2;3)",
            "E": "(2;3;4;5;6;7;8)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To determine the correct answer, we need to understand the algorithm being applied to the vector `a = (8;6;4;2;3;5;7)` during the process described. Although the specific algorithm isn't explicitly stated, the question seems to imply it's a sorting algorithm or a similar iterative process that rearranges the elements of the vector.\n\nGiven the options, it appears that the algorithm is performing a sorting operation, likely a selection sort or insertion sort, where the vector is being sorted into ascending order. By the time the algorithm reaches step `i=5`, the first five elements of the vector are sorted into ascending order, while the rest of the vector remains unchanged.\n\nOption A `(2;3;4;5;6"
        },
        {
          "id": 2,
          "text": "O procedura ce parcurge urmatorul arbore in inordine va afisa:",
          "image": "structuri_2.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "An \"inorder\" traversal of a binary search tree (BST) involves visiting the nodes in the following order: left subtree, root node, right subtree. This traversal results in visiting the nodes in ascending order for a BST. Given the tree structure, the inorder traversal will access each node in the sorted sequence of their values. Therefore, the correct output will be a sorted list of the tree's node values. Option A, which is \"3,5,6,7,10,12,13,15,16,18,20,23,\" reflects this sorted order, hence it is the correct answer."
        },
        {
          "id": 3,
          "text": "O procedura ce parcurge urmatorul arbore in postordine va afisa:",
          "image": "structuri_3.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In a postorder traversal of a binary tree, the nodes are visited in the order of left subtree, right subtree, and then the root node. This means that for each subtree, you first visit all nodes in the left subtree, then all nodes in the right subtree, and finally the root node itself. \n\nGiven the correct answer is C: 3,7,6,10,13,12,5,18,23,20,16,15, this sequence reflects the postorder traversal. It shows that for each subtree, the left and right subtrees are fully processed before the root node is visited. The traversal order starts from the deepest left node (3), processes its siblings and parent nodes up the tree, and finally"
        },
        {
          "id": 4,
          "text": "O procedura ce parcurge urmatorul arbore in preordine va afisa:",
          "image": "structuri_4.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The pre-order traversal of a tree visits nodes in the following order: root, left subtree, and then right subtree. For the given question, option B (15,5,3,12,10,6,7,13,16,20,18,23) correctly represents this traversal order. It begins with the root node (15), then moves to the left child (5), continues to the leftmost child (3), and proceeds by visiting the left subtree of 5. After completing the left subtree, it visits the right subtree of 5 (starting with 12). The traversal continues by visiting each node's left subtree before its right subtree, ensuring all nodes are visited in the correct pre-order sequence."
        },
        {
          "id": 5,
          "text": "Care dintre urmatoarele conditii nu este conditia necesara pentru un algoritm de cautare binara:",
          "options": {
            "A": "lista trebuie sa fie sortata",
            "B": "ar trebui sa existe acces direct catre elementul din mijlocul fiecarei subliste",
            "C": "ar trebui sa existe un mecanism de stergere sau/si de inserare a elementelor  in lista",
            "D": "niciuna de mai sus"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The correct answer is C. A binary search algorithm requires the list to be sorted (A) and the ability to access the middle element of any sublist directly (B) to function correctly. However, having a mechanism for deleting or inserting elements (C) is not a necessary condition for performing a binary search. Therefore, option C does not qualify as a required condition for binary search."
        },
        {
          "id": 6,
          "text": "Care dintre urmatoarele nu este afirmatii nu este adevarata in cazul unui algoritm de cautare binara?",
          "options": {
            "A": "trebuie folosit un array sortat",
            "B": "cerintadeaaveaunarraysortatnecesitamultamemoriesitimpatuncicandsuntnecesare multe stergeri si inserari",
            "C": "trebuie sa existe un mecanism care sa permita accesul direct la elementul din mijloc",
            "D": "algoritmul de cautare binar nu este eficient atunci cand avem mai mult de 1000 de elemente"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Explicație: Algoritmul de căutare binară necesită un array sortat (A) și acces direct la elementul din mijloc (C) pentru a funcționa corect. De asemenea, menținerea unui array sortat (B) poate consuma multă memorie și timp, mai ales în cazul în care sunt necesare frecvente inserări și ștergeri. Totuși, afirmația D este falsă, deoarece căutarea binară este foarte eficientă chiar și pentru colecții mari de date, mult peste 1000 de elemente, datorită complexității sale logaritmice, ceea ce o face mai eficientă decât căutările liniare"
        },
        {
          "id": 7,
          "text": "Ce va afisa urmatorul program?\n\nString name;\nint i;\nboolean startWord;\nname = \"Franklin D. Roosevelt\";\nstartword = true;\nfor (i = 0; i < name.length(); i++) {\n    if (startWord)\n    System.out.println(name.charAt(i));\n    if (name.charAt(i) == ’ ’)\n    startWord = true;}\nelse\nstartWord = false;\n}",
          "options": {
            "A": "FDR",
            "B": "Franklin",
            "C": "D",
            "D": "Roosevelt",
            "E": "Franklin D. Roosevelt"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The program is designed to extract and print the initials of the words in the string \"Franklin D. Roosevelt\". Here's how it works:\n\n1. The variable `name` is initialized with the string \"Franklin D. Roosevelt\".\n2. The boolean variable `startWord` is set to `true` initially, indicating that the first character of the string is considered the start of a word.\n3. A `for` loop iterates over each character in the string `name`.\n4. If `startWord` is `true`, it prints the current character (`name.charAt(i)`) because it is the start of a word.\n5. If the current character is a space (`' '`), it sets `startWord` to"
        },
        {
          "id": 8,
          "text": "O procedura ce parcurge urmatorul arbore in inordine va afisa:",
          "image": "structuri_8.png",
          "options": {
            "A": "3,5,6,23,10,12,13,15,16,18,20,7",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In an in-order traversal of a binary tree, the nodes are visited in the following order: left subtree, root, right subtree. This traversal method results in visiting the nodes in ascending order for a binary search tree (BST).\n\nTo determine the correct sequence, we start at the leftmost node and move to the root and then to the right subtree. Let's assume the tree structure is such that option A represents the correct in-order sequence. This would imply that the nodes are visited in the exact order listed in option A: 3,5,6,23,10,12,13,15,16,18,20,7. This sequence fits the definition of in-order traversal, where each left subtree's nodes are visited before the"
        },
        {
          "id": 9,
          "text": "O procedura ce parcurge urmatorul arbore in postordine va afisa:",
          "image": "structuri_9.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,23,6,10,13,12,5,18,7,20,16,15",
            "D": "i3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In a postorder traversal of a binary tree, the nodes are visited in the following order: left subtree, right subtree, and then the root node. This means that for each subtree, you first process all the nodes in the left child, then all the nodes in the right child, and finally the node itself.\n\nLet's apply this to the given tree:\n\n1. Start with the leftmost subtree and visit the left child (3).\n2. Move to the right child of the first subtree (6), which has a left child (5). Visit 5, then 6.\n3. Move to the right child of the main root (12) and repeat: visit left child (10), then right child (13), then root of"
        },
        {
          "id": 10,
          "text": "O procedura ce parcurge urmatorul arbore in preordine va afisa:",
          "image": "structuri_10.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,23,13,16,20,18,7",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Preorder traversal of a binary tree is a type of depth-first traversal where nodes are processed in the following order: root, left subtree, and then right subtree. This is often referred to as \"NLR\" (Node, Left, Right).\n\nIn the given question, the correct answer is B: 15,5,3,12,10,6,23,13,16,20,18,7.\n\nHere's the explanation for the preorder traversal:\n\n1. Start at the root of the tree. The first node to visit is the root node, which is 15.\n2. Next, move to the left subtree of 15 and visit the root of this subtree, which is 5.\n3. Continue to the left"
        },
        {
          "id": 11,
          "text": "Ce metoda de sortare este descrisa in pseudo-codul urmator:\n\nprocedure sort(A)\nn = length(A)\nrepeat\nswapped = false\nfor i = 1 to n-1 do\nif (A[i-1]>A[i] then\nswap (A[i-1],A[i])\nswapped = true\nend if\nend for\nuntil not swapped\nend procedure\n",
          "options": {
            "A": "HeapSort",
            "B": "MergeSort",
            "C": "BubbleSort",
            "D": "SwapSort"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The pseudo-code describes the Bubble Sort algorithm. Bubble Sort works by repeatedly stepping through the list, comparing adjacent elements and swapping them if they are in the wrong order. This process is repeated until no more swaps are needed, indicating that the list is sorted. The presence of the `swapped` flag and the repeated passes through the list to check and perform swaps are characteristic features of Bubble Sort."
        },
        {
          "id": 12,
          "text": "Coloana din stanga reprezinta un input de stringuri ce trebuie sortate; coloana din dreapta reprezinta strigurile sortate; celelalte coloane reprezinta un pas intermediar al unuia dintre algoritmii:\nquicksort, mergesort top-down, merge sort botton-up, heapsort. Care este ordinea algoritmilor\ntinand cont de coloanele afisate?\nnavy wine mist blue blue bark\nplum teal coal gray coal blue\ncoal silk jade rose gray cafe\njade plum blue mint jade coal\nblue sage cafe lime lime corn\npink pink herb navy mint dusk\nrose rose gray jade navy gray\ngray jade leaf teal pink herb\nteal navy dusk coal plum jade\nruby ruby mint ruby rose leaf\nmint pine lime plum ruby lime\nlime palm bark pink teal mint\nsilk coal corn silk bark mist\ncorn corn navy corn corn navy\nbark bark wine bark dusk palm\nwine gray silk wine leaf pine\ndusk dusk ruby dusk silk pink\nleaf leaf teal leaf wine plum\nherb herb sage herb cafe rose\nsage blue rose sage herb ruby\ncafe cafe pink cafe mist sage\nmist mist pine mist palm silk\npine mint palm pine pine teal\npalm lime plum palm sage wine\n0 - - - - 1",
          "options": {
            "A": "Input, quicksort, heapsort, merge bottom-up, merge top-down, output",
            "B": "Input, heapsort, merge top-down, merge bottom-up, quicksort, output",
            "C": "Input, quicksort, heapsort, merge top-down, merge bottom-up, output",
            "D": "Input, merge top-down, merge bottom-up, quicksort, heapsort, output",
            "E": "Input, merge top-down, quicksort, heapsort, merge bottom-up, output"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. \n\nLet's break down the sorting process as reflected by the columns:\n\n1. **Input Column**: This is the initial unsorted list of strings.\n2. **Quicksort Column**: Quicksort is a divide-and-conquer algorithm that works by selecting a 'pivot' element and partitioning the array around the pivot. In this column, we see that \"navy\" is the first element, which likely means it was used as a pivot initially.\n3. **Heapsort Column**: Heapsort builds a heap from the input data, and then repeatedly extracts the maximum element from the heap, followed by rebuilding the heap. The intermediate column likely shows the state after some heap operations.\n4"
        },
        {
          "id": 13,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f1(int N){\n    int x = 0;\n    for (int i = 0; i < N, i++)\n    x++;\n    return x;\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The algorithm provided consists of a simple loop that iterates from 0 to \\( N-1 \\). Inside the loop, a single operation is performed: incrementing the variable \\( x \\). The loop runs exactly \\( N \\) times, and each iteration of the loop takes a constant amount of time, independent of \\( N \\). Therefore, the time complexity of this algorithm is directly proportional to \\( N \\), making the execution time \\( O(N) \\). This corresponds to option B."
        },
        {
          "id": 14,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f2(int N){\n    int x = 0;\n    for (int i = 0; i < N, i++)\n    for (int j = 0; j < i; j++)\n    x++;\n    return x;\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The given algorithm consists of a nested loop structure where the outer loop runs `N` times, iterating over `i` from `0` to `N-1`. The inner loop runs `i` times for each iteration of the outer loop. \n\nLet's break down the number of iterations:\n\n- For `i = 0`, the inner loop runs `0` times.\n- For `i = 1`, the inner loop runs `1` time.\n- For `i = 2`, the inner loop runs `2` times.\n- ...\n- For `i = N-1`, the inner loop runs `N-1` times.\n\nThe total number of iterations of the inner loop is the sum of the first `N"
        },
        {
          "id": 15,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f3(int N){\n    if (N==0) return 1;\n    int x=0;\n    for (int i = 0; i < N; i++)\n    x+=f3(N-1);\n    return x;\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "F"
          ],
          "explanation": "The function `f3` is a recursive function that calculates a value based on the input `N`. The base case is when `N` is 0, in which case it returns 1. Otherwise, it initializes an integer `x` to 0 and uses a loop that runs `N` times. In each iteration of the loop, it recursively calls itself with the argument `N-1` and adds the result to `x`. \n\nThis creates a recursive call tree where each level of the tree corresponds to a decrease in the value of `N` by 1. At each level `N`, the function makes `N` recursive calls to level `N-1`. This pattern results in a total number of calls that"
        },
        {
          "id": 16,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f1(int N){\n    int x = 0;\n    for (int i = 0; i < N, i++)\n    x++;\n    return x;\n}\npublic static int f4(int N){\n    if (N==0) return 0;\n    return f4(N/2) + f1(N) + f4(N/2);\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To determine the time complexity of the given algorithm, we need to analyze both functions, `f1` and `f4`.\n\n1. **Function `f1(int N)` Analysis:**\n   - `f1` contains a simple `for` loop that iterates `N` times, incrementing `x` in each iteration.\n   - Therefore, the time complexity of `f1` is O(N).\n\n2. **Function `f4(int N)` Analysis:**\n   - `f4` is a recursive function that operates as follows:\n     - If `N` is 0, it returns immediately with a constant time operation O(1).\n     - Otherwise, it makes two recursive calls to itself with an argument of"
        },
        {
          "id": 17,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f1(int N){\n    int x = 0;\n    for (int i = 0; i < N, i++)\n    x++;\n    return x;\n}\npublic static int f5(int N){\n    int x = 0;\n    for (int i = N; i > 0; i = i/2)\n    x+=f1(i);\n    return x;\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To determine the time complexity of the function `f5`, we need to analyze both `f1` and `f5`.\n\n1. **Analyzing `f1(int N)`:**\n   - The function `f1` runs a loop from 0 to N, performing a simple operation (`x++`) in each iteration.\n   - Therefore, the time complexity of `f1` is O(N).\n\n2. **Analyzing `f5(int N)`:**\n   - The function `f5` runs a loop where `i` starts at N and is halved (`i = i / 2`) each time until `i` becomes 0.\n   - This is a logarithmic loop, which typically runs log"
        },
        {
          "id": 18,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f6(int N){\n    if (N==0) return 1;\n    return f6(N-1) + f6(N-1);\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "The given algorithm is a recursive function that calls itself twice for each decrement of \\( N \\). Specifically, for any input \\( N \\), the function makes two recursive calls with \\( N-1 \\). This structure resembles a binary tree where each level of the tree represents a recursive call, and each node has two children until reaching the base case (when \\( N = 0 \\)).\n\nThe depth of the recursion tree is \\( N \\), and at each level \\( i \\), there are \\( 2^i \\) nodes (or calls to the function). Thus, at the deepest level, the number of nodes (or function calls) is \\( 2^N \\). As a result, the number of operations performed by the"
        },
        {
          "id": 19,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f7(int N){\n    if (N==1) return 0;\n    return 1+f7(N/2);\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The function `f7` is a recursive function that reduces the input `N` by half each time it is called, until `N` becomes 1. Each recursive call represents a division by 2, which suggests a logarithmic behavior. The number of times we can divide `N` by 2 until we reach 1 is approximately `log₂N`. Therefore, the time complexity of this function is `O(log N)`, which corresponds to answer A."
        },
        {
          "id": 20,
          "text": "Algoritmul Quiksort este cel mai potrivit pentru",
          "options": {
            "A": "Sortarea unui liste mari de chei care sunt in ordine aleatoare",
            "B": "Sortarea unei liste de chei care sunt aproape ordonate",
            "C": "Gasirea celui mai scurt drum",
            "D": "Sortarea unei liste scurte de chei"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Algoritmul QuickSort este un algoritm de sortare eficient, mai ales când se aplică pe liste mari de elemente care sunt distribuite aleatoriu. Funcționează prin alegerea unui pivot și rearanjarea elementelor astfel încât cele mai mici să se afle înaintea pivotului, iar cele mai mari după acesta, continuând recursiv pentru sublistele rezultate. Datorită complexității sale medii de timp de \\(O(n \\log n)\\), QuickSort este deosebit de eficient pentru liste mari de chei în ordine aleatoare. În schimb, pentru liste aproape ordonate sau foarte scurte, alte algoritmi, precum Insertion Sort, pot fi mai efic"
        }
      ]
    },
    {
      "name": "Programare orientata obiect",
      "questions": [
        {
          "id": 1,
          "text": "Un program orientat obiect reprezinta:",
          "options": {
            "A": "o colectie de obiecte care coopereaza prin intermediul mesajelor  in vederea realizarii unui obiectiv comun",
            "B": "o varianta de program procedural",
            "C": "un program care poate fi considerat un obiect de catre alte programe",
            "D": "un program specific mediului de programare Windows",
            "E": "un program format din mai multe fisiere sursa si header"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "A program orientat obiect (object-oriented program) is fundamentally based on the principles of object-oriented programming (OOP). The correct answer, A, describes this concept accurately. In OOP, a program is structured as a collection of interacting objects, where each object represents an instance of a class. These objects communicate with each other through messages (method calls) to perform tasks and achieve a common goal. This approach emphasizes modularity, encapsulation, and reusability, which are core tenets of object-oriented design. The other options do not accurately capture these key aspects of OOP."
        },
        {
          "id": 2,
          "text": "O clasa in modelul de programare orientat obiect reprezinta:",
          "options": {
            "A": "o colectie de obiecte cu aceleasi caracteristici si cu un comportament comun",
            "B": "o colectie de caracteristici",
            "C": "un obiect din program",
            "D": "o interfata",
            "E": "un grup de comportamente specific unui obiect"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In object-oriented programming, a class is a blueprint or template for creating objects. It defines a collection of attributes (characteristics) and methods (behaviors) that the objects created from the class will have. Thus, option A is correct because it accurately describes a class as a collection of objects that share the same characteristics and behaviors. Options B, C, D, and E misrepresent the concept of a class by either oversimplifying or confusing it with other concepts like interfaces or individual objects."
        },
        {
          "id": 3,
          "text": "Obiectele apartinand unei aceleiasi clase se diferentiaza prin:",
          "options": {
            "A": "starea lor",
            "B": "valorile datelor membru declarate in cadrul clasei",
            "C": "valorile caracteristicilor clasei",
            "D": "caracteristicile diferite specifice fiecarui obiect",
            "E": "comportamentul diferit specific fiecarui obiect"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "In the context of object-oriented programming, objects belonging to the same class can differ from each other based on the following aspects:\n\nA. **Starea lor (Their state):** The state of an object is determined by the values of its attributes (or fields). Even if two objects are instances of the same class, they can have different states if their attributes hold different values.\n\nB. **Valorile datelor membru declarate in cadrul clasei (The values of the member data declared within the class):** Each object can have its own set of values for the member variables defined by the class. These values can vary from one object to another, leading to differences between objects of the same class.\n\nC. **Valorile caracteristicilor"
        },
        {
          "id": 4,
          "text": "Consideram urmatorul program C++ \n\n#include <iostream>\nusing namespace std;\nclass C\n{\n    private:\n    int _i;\n    public:\n    C(int i):_i(i){}\n    C():_i(3){}\n    ~C(){cout<<_i<<endl;}\n};\nvoid main()\n{\n    C c1(4);\n    C c2;\n}\n\nCare din urmatoarele afirmatii sunt adevarate:",
          "options": {
            "A": "programul nu contine erori de sintaxa",
            "B": "exista erori de sintaxa in definitiile metodelor constructor",
            "C": "destructorul nu poate contine instructiuni de afisare",
            "D": "in cadrul programului principal sunt create doua instante ale clasei C",
            "E": "programul afiseaza la consola numerele 3 si 4"
          },
          "correct_answer": [
            "A",
            "D",
            "E"
          ],
          "explanation": "Explanation:\n\nA. The program does not contain syntax errors. - This statement is true. The program is syntactically correct as it follows the correct C++ syntax for class definition, constructor initialization, and destructor implementation.\n\nB. There are no syntax errors in the constructor definitions. - This statement is false. The constructor definitions are correctly implemented using initializer lists, which is a valid and common practice in C++.\n\nC. A destructor cannot contain output statements. - This statement is false. In C++, destructors can contain any code, including output statements like `cout`. The destructor in this program is valid and will output the value of `_i`.\n\nD. Two instances of class C are created in the main program. - This statement is true"
        },
        {
          "id": 5,
          "text": "Care din urmatoarele afirmatii referitoare la mostenire sunt adevarate relativ la limbajul de pro- gramare C++:",
          "options": {
            "A": "Relatia de mostenire in care clasa de baza si clasa derivata au aceeasi interfata se numeste mostenire pura",
            "B": "Dintr-o clasa de baza se poate obtine prin intermediul mostenirii cel mult o clasa derivata",
            "C": "O clasa derivata are exact o clasa de baza",
            "D": "Obiectele apartinand unei clase derivate pot fi convertite la tipul unei clase de baza din care clasa derivata provine",
            "E": "Specificatorul protected este folosit pentru a arata ca elementele care il urmeaza pot fi accesate si din cadrul claselor derivate"
          },
          "correct_answer": [
            "A",
            "D",
            "E"
          ],
          "explanation": "In C++, inheritance allows a class (derived class) to inherit properties and behaviors from another class (base class). Let's analyze each statement:\n\nA. **Relatia de mostenire in care clasa de baza si clasa derivata au aceeasi interfata se numeste mostenire pura** - This statement is somewhat misleading. The term \"pure inheritance\" isn't standard. However, it might imply that the derived class adheres strictly to the base class's interface, which could relate to interface inheritance in other contexts.\n\nB. **Dintr-o clasa de baza se poate obtine prin intermediul mostenirii cel mult o clasa derivata** - This is false. In C++, a base class can have multiple derived"
        },
        {
          "id": 6,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program: \n\n#include <iostream.h>\nclass Test {\n    int n;\n    public:\n    Test(int x):n(x){}\n    int f(int n, int &x, int *p){\n        n=this->n;\n        x=n++;\n        *p=this->n + n;\n        return n;\n    }\n};\nvoid main(){\n    Test t(2);\n    int n=6,x=0x10,p=1;\n    cout<<t.f(n,x,&p)<<\" \";\n    cout<<n<<\" \"<<x<<\" \"<<p;\n}",
          "options": {
            "A": "3 6 2 5",
            "B": "3 6 16 1",
            "C": "6 6 10 1",
            "D": "3 7 10 1",
            "E": "Eroare de compilare deoarce constructorul nu contine nici o intructiune"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To understand what will be displayed on the screen, let's analyze the program step by step:\n\n1. **Class Initialization**: \n   - An object `t` of class `Test` is created with the constructor `Test(2)`, which initializes the member variable `n` of the object `t` to 2.\n\n2. **Function Call**:\n   - The function `f` is called with arguments `n=6`, `x=0x10` (which is 16 in decimal), and `&p` (address of `p`, where `p` is initialized to 1).\n\n3. **Inside the Function `f`**:\n   - `n=this->n;`: The local parameter `"
        },
        {
          "id": 7,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program: \n\n#include <iostream.h>\nclass B1 {\n    public:\n    B1(){cout<<\"B1 \";}\n    ~B1(){cout<<\"DB1 \";}\n};\nclass B2 {\n    public:\n    B2(){cout<<\"B2 \";}\n    ~B2(){cout<<\"DB2 \";}\n};\nclass D: public B1, public B2{\n    public:\n    D():B2(),B1(){cout<<\"D \";}\n    ~D(){cout<<\"DD \";}\n};\nvoid main(){\n    D d1;\n    D d2=d1;\n}",
          "options": {
            "A": "B1 B2 D DD DB2 DB1 DD DB2 DB1",
            "B": "B2 B1 D DD DB2 DB1 DD DB2 DB1",
            "C": "B1 B2 D B1 B2 D DD DB2 DB1 DD DB2 DB1",
            "D": "B1 B2 D DD DB1 DB2 DD DB1 DB2",
            "E": "D DD"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To understand what will be displayed on the screen, let's analyze the program step-by-step:\n\n1. **Class Constructors and Destructors:**\n   - `B1` constructor prints \"B1 \".\n   - `B1` destructor prints \"DB1 \".\n   - `B2` constructor prints \"B2 \".\n   - `B2` destructor prints \"DB2 \".\n   - `D` constructor initializes `B2` first (prints \"B2 \"), then `B1` (prints \"B1 \"), and finally prints \"D \".\n   - `D` destructor prints \"DD \".\n\n2. **Execution in `main`:**\n   - When `D d1;` is executed, the constructor of `D` is"
        },
        {
          "id": 8,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B1 {\n    public:\n    B1(){cout<<\"B1 \";}\n    ~B1(){cout<<\"DB1 \";}\n};\nclass B2 {\n    public:\n    B2(){cout<<\"B2 \";}\n    ~B2(){cout<<\"DB2 \";}\n};\nclass D: public B1, public B2{\n    static int idGen;\n    int id;\n    public:\n    D():B2(),B1(){id=idGen++;cout<<\"D(\"<<id<<\") \";}\n    D(const D &o){id=idGen++;cout<<\"CD(\"<<id<<\") \";}\n    ~D(){cout<<\"DD \";}\n};\nint D::idGen = 0;\nvoid main(){\n    cout<<endl;\n    D d1;\n    D d2=d1;\n}",
          "options": {
            "A": "B1 B2 D(0) B1 B2 CD(1) DD DB2 DB1 DD DB2 DB1",
            "B": "B1 B2 D(0) DD DB2 DB1 DD DB2 DB1",
            "C": "B1 B2 D(0) DD DB2 DB1",
            "D": "B2 B1 D(0) B1 B2 CD(1) DD DB2 DB1 DD DB2 DB1",
            "E": "B1 B2 D(0) B2 B1 CD(1) DD DB2 DB1 DD DB2 DB1",
            "F": "rezultatul executiei nu poate fi determinat deoarce depinde de continul memoriei"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To determine what will be displayed on the screen, we need to follow the sequence of constructor and destructor calls. \n\n1. When the program begins executing `main()`, it first prints a newline due to `cout<<endl;`.\n   \n2. The creation of `D d1` triggers the following sequence:\n   - `B2` constructor is called first due to the order in the initializer list of class `D`: `B2()`.\n   - `B1` constructor is called next: `B1()`.\n   - `D` constructor is executed, which outputs `D(0)`, as `idGen` starts from 0 and is then incremented.\n\n3. The creation of `D d2 = d"
        },
        {
          "id": 9,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B1 {\n    public:\n    B1(){cout<<\"B1 \";}\n    ~B1(){cout<<\"DB1 \";}\n};\nclass B2 {\n    public:\n    B2(){cout<<\"B2 \";}\n    ~B2(){cout<<\"DB2 \";}\n};\nclass D: public B1, public B2{\n    public:\n    D():B2(),B1(){cout<<\"D \";}\n    D(const D &o){cout<<\"CD \";}\n    ~D(){cout<<\"DD \";}\n};\nvoid main(){\n    D *d1 = new D;\n    D *d2 = d1;\n    delete d1;\n}",
          "options": {
            "A": "B1 B2 D DD DB2 DB1",
            "B": "B1 B2 D DD DB2 DB1 DD DB2 DB1",
            "C": "B2 B1 D DD DB2 DB1",
            "D": "B2 B1 D DD DB2 DB1 DD DB2 DB1",
            "E": "B1 B2 D B1 B2 D DD DB2 DB1 DD DB2 DB1",
            "F": "B1 B2 D B1 B2 D DD DB2 DB1"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The program demonstrates the order of constructor and destructor calls in a class hierarchy with multiple inheritance.\n\n1. **Construction Phase:**\n   - When the object `d1` is created with `new D`, the constructors are called in the following order:\n     - `B2` constructor: Since the constructor list `D():B2(),B1()` specifies `B2` first, `B2`'s constructor is called, outputting \"B2 \".\n     - `B1` constructor: Then `B1`'s constructor is called, outputting \"B1 \".\n     - `D` constructor: Finally, `D`'s constructor is executed, outputting \"D \".\n   - The entire construction phase outputs:"
        },
        {
          "id": 10,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass A {\n    public:\n    A(){cout<<\"A()\";}\n    A(int n,int m=0){cout<<\"A(int,int)\";}\n    A(const A &o){cout<<\"A(const A&)\";}\n    ~A(){cout<<\"~A\";}\n};\nvoid main(){\n    cout<<endl;\n    A a1;\n    A a2=a1;\n    A a3=1;\n    A a4(1);\n    A a5(1,1);\n}",
          "options": {
            "A": "A()A(const A&)A(int,int)A(int,int)A(int,int)~A~A~A~A~A",
            "B": "A(const A&)A(const A&)A(int)A(int,int)A(int,int)~A~A~A~A~A",
            "C": "A()A(const A&)A(int,int)A(int,int)A(int,int)~A~A~A~A",
            "D": "A()A(const A&)A(int)A(int)A(int,int)~A~A~A~A~A",
            "E": "A()A()A(int,int)A(int)A(int,int)~A~A~A~A~A",
            "F": "Eroare de compilare la declararea obiectului a2 deoarece nu e supra incarcat operatorul =."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The provided C++ code demonstrates the behavior of constructors and destructors in a class. Here's the breakdown of what happens in the `main` function:\n\n1. `A a1;` - This line calls the default constructor `A()`, printing `A()`.\n   \n2. `A a2 = a1;` - This line initializes `a2` using the copy constructor because `a1` is an object of the same class. The copy constructor `A(const A &o)` is called, printing `A(const A&)`.\n\n3. `A a3 = 1;` - This line attempts to initialize `a3` using an integer. Since `A(int, int)` can act as a conversion constructor due"
        },
        {
          "id": 11,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    public:\n    virtual void f() { cout<<\"B::f() \";}\n    void g() { cout<<\"B::g() \";}\n};\nclass D1: public B{\n    public:\n    void f() { cout<<\"D1::f() \";}\n    void g() { cout<<\"D1::g() \";}\n};\nclass D2: public B{\n    public:\n    void g() { cout<<\"D2::g() \";}\n};\nvoid main(){\n    int i;\n    B *b[] = {new B(), new D1(), new D2()};\n    for (i=2;i>=0;i--) {b[i]->f();}\n    for (i=0;i<=2;i++) {b[i]->g();}\n}",
          "options": {
            "A": "B::f() D1::f() B::f() B::g() B::g() B::g()",
            "B": "D2::f() D1::f() B::f() B::g() B::g() B::g()",
            "C": "B::f() D1::f() D::f() B::g() D1::g() D2::g()",
            "D": "B::f() D1::f() B::f() B::g() D1::g() D2::g()",
            "E": "B::f() B::f() D2::f() B::g() B::g() D2::g()"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the given program, the output is determined by the use of virtual functions and function overriding in derived classes.\n\n1. **Virtual Function `f()`:**\n   - The function `f()` in class `B` is declared as virtual. This means that when a pointer of type `B*` points to a derived class object, the version of `f()` that gets called is determined at runtime based on the actual object type.\n   - When `b[2]->f()`, `b[1]->f()`, and `b[0]->f()` are called in the loop, they resolve to `B::f()`, `D1::f()`, and `B::f()` respectively because:\n     - `b"
        },
        {
          "id": 12,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    public:\n    virtual void f() { cout<<\"B::f() \";}\n};\nclass D1: public B{\n    public:\n    void f() { cout<<\"D1::f() \";}\n};\nclass D2: public B{\n    public:\n    void f() { cout<<\"D2::f() \";}\n};\nvoid main(){\n    int i;\n    B b[] = { B(), D1(), D2()};\n    for (i=2;i>=0;i--) {b[i].f();}\n}",
          "options": {
            "A": "B::f() B::f() B::f()",
            "B": "D2::f() D1::f() B::f()",
            "C": "B::f() D1::f() D2::f()",
            "D": "B::f() D1::f() D2::f()"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. Here's the explanation:\n\nIn the given C++ program, we have a base class `B` with a virtual function `f()`, and two derived classes `D1` and `D2`, each overriding the function `f()`. In the `main` function, an array of objects of type `B` is initialized with objects of `B`, `D1`, and `D2`.\n\nHowever, because the array `b` is of type `B`, when the array is initialized, each derived class object (`D1` and `D2`) is sliced down to a base class object `B`. This is known as object slicing, where the derived parts of the object are sliced off, leaving"
        },
        {
          "id": 13,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    protected:\n    int x;\n    public:\n    B(int x=0){this->x=x;}\n    virtual void f() {x=x+1;}\n    void print(){cout<<x<<\" \";}\n};\nclass D1: public B{\n    public:\n    void f() {x=x+5;}\n};\nclass D2: public B{\n    public:\n    void f() {x=x+2;}\n};\nvoid main(){\n    int i;\n    B *b[] = { new B(2), new D1(), new D2(), new B};\n    for (i=3;i>0;i--) (*b[i]).f();\n    for (i=0;i<=3;i++) b[i]->print();\n}",
          "options": {
            "A": "2 5 2 1",
            "B": "2 0 0 0",
            "C": "3 5 2 1",
            "D": "2 1 1 1",
            "E": "2 5 2 0",
            "F": "2 5 2",
            "G": "Eroare de compilare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To determine what the program will output, let's analyze the code step by step:\n\n1. **Class Definitions:**\n   - `B` is a base class with an integer member `x`, initialized through its constructor. It has a virtual function `f()` that increments `x` by 1 and a `print()` function that outputs `x`.\n   - `D1` and `D2` are derived classes from `B`. `D1` overrides `f()` to increase `x` by 5, and `D2` overrides `f()` to increase `x` by 2.\n\n2. **Main Function:**\n   - An array of pointers to `B` objects is created, initialized with:\n     -"
        },
        {
          "id": 14,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    int x;\n    public:\n    B(int x=0){this->x=x;}\n    virtual void f() {x=x+1;}\n    void print(){cout<<x<<\" \";}\n};\nclass D1: public B{\n    public:\n    void f() {x=x+5;}\n};\nclass D2: public B{\n    public:\n    void f() {x=x+2;}\n};\nvoid main(){\n    int i;\n    B *b[] = { new B(2), new D1(), new D2(), new B};\n    for (i=3;i>0;i--) (*b[i]).f();\n    for (i=0;i<=3;i++) b[i]->print();\n}",
          "options": {
            "A": "2 5 2 1",
            "B": "2 0 0 0",
            "C": "3 5 2 1",
            "D": "2 1 1 1",
            "E": "2 5 2 0",
            "F": "2 5 2",
            "G": "Eroare de compilare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To determine what the program will output, we need to analyze the code step by step, focusing on the classes and the method calls.\n\n1. **Class Definitions and Initialization:**\n   - Class `B` has a default constructor that initializes `x` and a virtual function `f()` that increments `x` by 1.\n   - `D1` and `D2` are derived from `B` and override `f()`, modifying `x` by adding 5 and 2, respectively.\n\n2. **Array of Pointers:**\n   - `b[]` is an array of pointers to `B` objects, initialized with:\n     - `new B(2)`: A `B` object with `x"
        },
        {
          "id": 15,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    int x;\n    static int y;\n    public:\n    B(int x=0){this->x=x;}\n    void setX(int vx) {x=vx;}\n    void setY(int vy) {y=vy;}\n    void print(){cout<<x<<\" \"<<y<<\" \";}\n};\nint B::y=0;\nvoid main(){\n    B b1=3;\n    B b2(4);\n    b1.print(); b2.print();\n    b1.setX(5); b2.setY(2);\n    b1.print(); b2.print();\n}",
          "options": {
            "A": "3 0 4 0 5 2 4 2",
            "B": "3 0 4 0 5 0 4 2",
            "C": "3 4 5 2 4 2",
            "D": "3 3 4 4 5 2 4 2",
            "E": "3 0 4 0 5 2 5 2",
            "F": "3 0 4 0 5 0 2 0"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The program consists of a class `B` that has a non-static member variable `x` and a static member variable `y`. The static member `y` is shared among all instances of the class, while each instance has its own copy of `x`.\n\n1. Two objects of class `B`, `b1` and `b2`, are created with initial values 3 and 4 for `x` respectively. The static variable `y` is initialized to 0 at the start and is shared between `b1` and `b2`.\n\n2. When `b1.print()` and `b2.print()` are called initially, they print the values of `x` and `y` for each object. Since `"
        },
        {
          "id": 16,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <iostream.h>\nstruct A{\n    int x;\n    operator double() {\n        return 21.4;\n    }\n};\nvoid main(){\n    A a;\n    a.x = 11;\n    cout << (0?3:a);\n}",
          "options": {
            "A": "21",
            "B": "21.4",
            "C": "3",
            "D": "11",
            "E": "programul nu se compileaza"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the given program, the ternary conditional operator `(0 ? 3 : a)` is used. The condition `0` evaluates to false, so the expression evaluates to `a`. The struct `A` has a user-defined conversion operator `operator double()`, which allows an object of type `A` to be implicitly converted to a `double` type. However, the `cout` statement is trying to output the value of `a` directly. Since `cout` cannot directly handle a user-defined type like `A`, the conversion operator is invoked, converting `a` to a `double`, which is `21.4`. But since the `cout` statement outputs `double` values as integers by default, it truncates"
        },
        {
          "id": 17,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <iostream.h>\nstruct A {\n    A(int d) : x(d) {}\n    int x;\n};\nvoid main(){\n    double x = 3.14;\n    A f( int(x) );\n    cout << f.x << endl;\n}",
          "options": {
            "A": "nimic (eroare de compilare)",
            "B": "0",
            "C": "3",
            "D": "3.14",
            "E": "depinde de implementarea compilatorului"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A: nimic (eroare de compilare).\n\nExplanation: The program includes a few issues that lead to a compilation error. First, the header file `<iostream.h>` is not part of the C++ standard library; instead, the correct header is `<iostream>`. Additionally, the program uses the `void main()` function signature, which is non-standard in C++. The standard signature for the main function should be `int main()`.\n\nMoreover, the program attempts to use `cout` without specifying the `std::` namespace or using a `using namespace std;` directive. These issues combined result in a compilation error, preventing the program from running and displaying any output."
        },
        {
          "id": 18,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <iostream.h>\nint f(int x, int y = x) {\n    return x+y+1;\n}\nvoid main(){\n    cout << f(2);\n}",
          "options": {
            "A": "nimic (eroare de compilare)",
            "B": "1",
            "C": "3",
            "D": "5",
            "E": "depinde de implementarea compilatorului"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A: nimic (eroare de compilare).\n\nExplanation: The given program will result in a compilation error due to the use of a default argument that depends on another parameter of the same function. In the function definition `int f(int x, int y = x)`, the default argument `y = x` is not valid because `x` is not a constant expression and its value is not known at the time when the default argument is being set. In C++, default arguments must be constants or expressions that do not rely on other parameters of the same function. Because of this rule violation, the program will not compile, leading to an error."
        },
        {
          "id": 19,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <iostream.h>\nstruct A {\n    virtual int f(int x = 5){\n        return x * 2;\n    }\n};\nstruct B : public A{\n    int f(int x = 10) {\n        return x * 3;\n    }\n};\nvoid main(){\n    A* a = new B;\n    cout << a->f();\n}",
          "options": {
            "A": "15",
            "B": "10",
            "C": "20",
            "D": "3",
            "E": "nimic (eroare de compilare)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The program demonstrates the concept of virtual functions and default parameters in C++. In the given code, `A` is a base class with a virtual function `f` that has a default parameter value of `5`. Class `B` inherits from `A` and overrides the function `f` with its own default parameter value of `10`.\n\nIn the `main` function, an object of type `B` is created and assigned to a pointer of type `A*`. When the function `f` is called through this pointer (`a->f()`), it resolves to `B`'s overridden version of `f` due to dynamic polymorphism (virtual function mechanism). However, in C++, default arguments are determined by the static type"
        },
        {
          "id": 20,
          "text": "Fie secventa de program:\n\nclass A {\n    private:\n    int x,y;\n    public:\n    A(){x=0;y=0; }\n    A(int xi,int yi){\n        x=xi;y=yi;\n    }\nvoid afis(){\n    cout <<x ” ” << y;\n}\n};\nvoid main(){\n    A A1,A2(10,20);\n    A1.afis();\n    A2.afis();\n}\nCare din urmatoarele afirmatii sunt adevarate:",
          "options": {
            "A": "Metoda afis() este incorect definita",
            "B": "Constructorul este incorect definit",
            "C": "Declaratie incorecta pentru obiectul A1",
            "D": "Programul afiseaza valorile (10 20 0 0 )",
            "E": "Programul afiseaza valorile (0 0 10 20 )"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Explanation: \n\nIn the given C++ program, there is a class `A` with two private integer members, `x` and `y`, and two constructors. The default constructor initializes both `x` and `y` to 0, while the parameterized constructor initializes them to `xi` and `yi`, respectively. The `afis()` method is correctly defined to print the values of `x` and `y`.\n\nIn the `main` function, two objects of class `A` are created: `A1` using the default constructor and `A2` using the parameterized constructor with values 10 and 20. When `A1.afis()` is called, it prints `0 0` because `"
        },
        {
          "id": 21,
          "text": "Fie secventa de program:\n\nclass C{\n    public:\n    C(){n++;}\n    static int index(){return n;}\n    private:\n    static int n;\n};\nint C :: n = 0;\nclass A{\n    private:\n    C c;\n    int a;\n};\nclass B{\n    public:\n    B(int i = 0) :b(i)\n    {cout <<C :: index() <<” ”;}\n    private:\n    A a;\n    C c;\n    int b;\n};\nvoid main(){\n    A a1;\n    cout <<C :: index() <<’ ’;\n    B b1[3];\n}\nRezultatul executiei programului este:",
          "options": {
            "A": "1 2 3 4",
            "B": "1 3 4 5",
            "C": "1 7 3 4",
            "D": "1 3 5 7",
            "E": "0 1 2 3"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "To understand the correct answer, let's break down the program execution:\n\n1. The static member `n` of class `C` is initialized to 0 (`int C::n = 0;`).\n\n2. In the `main()` function, an object `a1` of class `A` is created. The class `A` contains a member `c` of type `C`. Therefore, constructing `a1` calls the constructor of `C`, incrementing `n` by 1. So, `n` becomes 1.\n\n3. The statement `cout << C::index() << ' ';` prints the current value of `n`, which is 1.\n\n4. Next, an array `b1"
        },
        {
          "id": 22,
          "text": "Se considera secventa de program:\n\nclass C {\n    private:\n    int x,y;\n    public:\n    C(int xi,int yi){ x=xi;y=yi; }\n    C(const C &a){\n        x=a.x;y=a.y;\n    }\n};\nIn care din urmatoarele situatii se realizeaza copierea unui obiect in altul:",
          "options": {
            "A": "C c1(4,5)",
            "B": "C c2(0.0, 0,0)",
            "C": "C c3=c1",
            "D": "C c4(1)",
            "E": "C c5(c1)"
          },
          "correct_answer": [
            "C",
            "E"
          ],
          "explanation": "In the given class `C`, there is a copy constructor defined, which allows for the copying of an object into another. This copy constructor is invoked in specific situations where an object needs to be initialized using another object of the same class.\n\n- Option A (`C c1(4,5)`) and B (`C c2(0.0, 0,0)`) involve the creation of a new object using direct initialization with arguments. These do not involve copying from another object, so the copy constructor is not used.\n- Option C (`C c3=c1`) uses the copy constructor because `c3` is being initialized using the existing object `c1`. This is a direct application of the copy constructor.\n- Option"
        },
        {
          "id": 23,
          "text": "Se considera secventa de program:\n\nclass Punct {\n    private:\n    double x,y;\n    public:\n    Punct(double xi,double yi){\n        x=xi;y=yi;\n    }\n};\nIn care din urmatoarele situatii se realizeaza copierea unui obiect:",
          "options": {
            "A": "Punct P1(10,20)",
            "B": "Punct P2(P1(3))",
            "C": "Punct P3",
            "D": "Punct P4=P1",
            "E": "Punct P5(P1)"
          },
          "correct_answer": [
            "D",
            "E"
          ],
          "explanation": "In the given sequence of code, the class `Punct` has a constructor that initializes its private members `x` and `y` using the parameters `xi` and `yi`. \n\nLet's analyze each option:\n\nA. `Punct P1(10,20)` - This creates a new object `P1` using the constructor with `x` and `y` values as `10` and `20`, respectively. No copying occurs here; it's a direct initialization.\n\nB. `Punct P2(P1(3))` - This line is incorrect in syntax. `P1(3)` suggests a function call, which is invalid as `P1` is not callable. Therefore, this option does not involve copying"
        },
        {
          "id": 24,
          "text": "Se da programul :\n\nclass P {\n    double x,y;\n    public:\n    P(double x1 = 0,double y1 = 0){\n        x=x1;y=y1;\n    }\nvoid afis(){\n    cout <<x <<” ” << y;\n}\nP operator++ (){\n    ++x;++y;\n    return *this;\n}\n};\nvoid main(){\n    P p1(1,2),p2;\n    p2=++p1;\n    p2.afis();\n}\nCare din afirmatiile urmatoare sunt corecte:",
          "options": {
            "A": "Obiectul p2 nu poate fi instantiat",
            "B": "Asignarea p2=++p1 este incorecta",
            "C": "In program se realizeaza supraancarcarea operatorului prefix de incrementare",
            "D": "Programul va afisa valorile: 23",
            "E": "Programul afiseaza valorile lui p1"
          },
          "correct_answer": [
            "C",
            "D"
          ],
          "explanation": "In the given C++ program, we have a class `P` which includes a constructor, a method `afis` for displaying values, and an overloaded prefix increment operator (`operator++`). Here's a breakdown of the correct answers:\n\n- **C. In program se realizeaza supraancarcarea operatorului prefix de incrementare:**\n  - This statement is correct. The program overloads the prefix increment operator `++` for objects of class `P`. The method `operator++` increases both `x` and `y` by 1 and returns the incremented object.\n\n- **D. Programul va afisa valorile: 23:**\n  - This statement is also correct. Initially, `p1` is instantiated"
        },
        {
          "id": 25,
          "text": "Se da programul :\n\nclass A {\n    int x,y;\n    public:\n    A(int xi = 0, int yi=0){\n        x=xi;y=yi;\n    }\nvoid afis(){\n    cout <<” x” << y;\n}\nA operator+ (A o2);\nfriend A operator++ (A &a);\n};\nA A::operator+ (A o2){\n    A temp;\n    temp.x=x+o2.x;\n    temp.y=y+o2.y;\n    return temp;\n}\nA operator++ (A &a){\n    ++a.x;++a.y;\n    return a;\n}\nvoid main(){\n    A a1(20,30),a2(2,2),a3;\n    a3=++a1+a2;\n    a3.afis();\n}\nCare din afirmatiile urmatoare sunt corecte:",
          "options": {
            "A": "Utilizarea cuvantului predefinit ” friend ” nu este permisa in acest context",
            "B": "Functia operatorului ++ nu este definita corect",
            "C": "Programul va afisa valorile: 23 33",
            "D": "Atribuirea a3=++a1+a2 este incorecta",
            "E": "programul va afisa valorile: 22 32"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To understand the correct answer, let's analyze the program and the question options:\n\n1. **Friend Keyword:** \n   - The `friend` keyword is used correctly. It allows the external function `operator++` to access the private members of class `A`.\n\n2. **Operator++ Function:** \n   - The `operator++` function is defined as a friend function, which increments the values of `x` and `y` in the object `a` and returns the modified object. It is correctly defined for the intended use.\n\n3. **Output of the Program:**\n   - In the `main` function, `a1` is initialized with values (20, 30).\n   - The expression `++a1` increments"
        },
        {
          "id": 26,
          "text": "Supra incarcarea unor operatori se poate realiza prin functii operator sau functii friend. Diferenta consta in:",
          "options": {
            "A": "Precedenta operatorilor",
            "B": "Asociativitatea operatorilor",
            "C": "Obiectul returnat",
            "D": "Lista de parametri",
            "E": "Numarul parametrilor din lista functiei"
          },
          "correct_answer": [
            "D",
            "E"
          ],
          "explanation": "In C++ programming, operator overloading allows you to define how operators work with user-defined types. This can be done either through member functions (operator functions) or friend functions. The key differences between these two approaches lie in how parameters are handled:\n\nD. Lista de parametri: A member function overloading an operator takes the left-hand operand (usually the object of the class) implicitly as `*this`, and the right-hand operand as an explicit parameter. In contrast, a friend function treats both operands as explicit parameters, requiring a different parameter list.\n\nE. Numarul parametrilor din lista functiei: This directly relates to the parameter list; a member function for binary operators takes one explicit parameter, whereas a friend function requires two parameters"
        },
        {
          "id": 27,
          "text": "Se considera secventa:\n\nclass A {\n    int a[3];\n    public:\n    A(int xi, int yi, int zi ){\n        a[0]=xi;a[1]=yi;a[2]=zi;\n    }\nint &operator[](int i){\n    return a[i];\n}\n};\nvoid main() {\n    A o(1, 2, 3);\n    cout<<o[0];\n    o[1]=10;\n    cout<<o[1];\n}\nCe se poate afirma despre operator[]()?",
          "options": {
            "A": "Supraincarca operatorul()",
            "B": "Supraincarca un operator unar",
            "C": "Este o metoda oarecare a clasei care nu produce supra incarcarea unor operatori",
            "D": "Este un constructor",
            "E": "Supraincarca operatorul[]"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "The correct answer is E. \n\nExplanation: In C++, the `operator[]` function within a class allows you to define how the subscript operator `[]` behaves for objects of that class. This is known as operator overloading, where you provide a custom implementation for an operator. In the given code, the `operator[]` is overloaded to provide access to the elements of the private array `a` within the class `A`. This allows you to use the subscript operator on an instance of `A` as if it were an array, enabling expressions like `o[0]` and `o[1]`. By returning a reference (`int &`), it also allows you to modify the elements directly, as shown with"
        },
        {
          "id": 28,
          "text": "Se considera secventa:\n\nclass B{\n    int a;\n    protected:\n    int b;\n    public:\n    int c;\n    void set a(int x){a = x;}\n    void set b(int y){b = y;}\n    void set c(int z){c = z;}\n};\nclass D : public B{ int d;\n    public:\n    void set b(int y) {b = y;}\n    void set c(int z) {c = z;}\n};\nvoid main(){\n    D o;\n    o.a = 1; //(1)\n    o.B::set a(2); //(2)\n    o.b = 3; //(3)\n    o.B::set b(4); //(4)\n    o.c = 5; //(5)\n}\nCare din instructiunile (1)-(5) acceseaza corect membrii claselor:",
          "options": {
            "A": "Toate",
            "B": "(1), (2) si (5)",
            "C": "(1), (3) si(4)",
            "D": "(1), (2), (3), (4)",
            "E": "(2), (4) si (5)"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "To understand which instructions access the class members correctly, let's examine the code and access modifiers used:\n\n1. **Instruction (1)**: `o.a = 1;`\n   - The member `a` is private in class `B`, meaning it cannot be accessed directly outside the class. Therefore, this instruction is incorrect.\n\n2. **Instruction (2)**: `o.B::set a(2);`\n   - This uses the `set a` method to modify the private member `a`. It is correctly using the class's method to access the private member, so it is correct.\n\n3. **Instruction (3)**: `o.b = 3;`\n   - The member `b` is protected in class `B"
        },
        {
          "id": 29,
          "text": "In programul urmator, care din instructiunile (1)-(5) acceseaza corect membrii claselor:\n\nclass B{\n    int a;\n    protected:\n    int b;\n    public:\n    int c;\n    void set a(int x){a = x;}\n    void set b(int y){b = y;}\n    void set c(int z){c = z;}\n};\nclass D : protected B{\n    int d;\n    public:\n    void set b(int y) {b = y;}\n    void set c(int z) {c = z;}\n};\nvoid main(){\n    D o;\n    o.a = 1; //(1)\n    o.B::set a(2); //(2)\n    o.b = 3; //(3)\n    o.B::set b(4); //(4)\n    o.c = 5; //(5)\n}",
          "options": {
            "A": "Toate",
            "B": "Nici una",
            "C": "Numai (5)",
            "D": "(2), (4) si (5)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In the given code, we have two classes: `B` and `D`. Class `D` inherits from class `B` using protected inheritance. Let's analyze each instruction:\n\n1. `o.a = 1;` - This is incorrect because `a` is a private member of class `B` and cannot be accessed directly from an object of class `D`.\n\n2. `o.B::set a(2);` - This is incorrect because the `set a` method is not defined correctly in class `B` (it should be `void set_a(int x)`), and even if it were, `a` is private and cannot be accessed through inheritance.\n\n3. `o.b = 3;` - This"
        },
        {
          "id": 30,
          "text": "In programul urmator, care din instructiunile (1)-(6) acceseaza corect membrii claselor:\n\nclass B{\n    int a;\n    protected:\n    int b;\n    public:\n    int c;\n    void set a(int x){a = x;}\n    void set b(int y){b = y;}\n    void set c(int z){c = z;}\n};\nclass D : private B{\n    int d;\n    public:\n    void set b(int y) {b = y;}\n    void set c(int z) {c = z;}\n};\nvoid main(){\n    D o;\n    o.a = 1; //(1)\n    o.B::set a(2); //(2)\n    o.b = 3; //(3)\n    o.B::set b(4); //(4)\n    o.c = 5; //(5)\n    o.set c(6); //(6)\n}",
          "options": {
            "A": "(1) si (4)",
            "B": "(2), (3), (4)",
            "C": "Toate",
            "D": "(6)"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "In the given program, class `D` inherits privately from class `B`, meaning all members of `B` become private in `D`. Here's a breakdown of the access in each instruction:\n\n1. **(1) `o.a = 1;`** - This is incorrect because `a` is a private member of `B`, and cannot be accessed directly from an object of `D`.\n2. **(2) `o.B::set a(2);`** - This is incorrect because `set a` is not a valid function due to a syntax error (it should be `set_a` if it were defined). Also, `a` is private.\n3. **(3) `o.b ="
        }
      ]
    },
    {
      "name": "Tehnologii Java",
      "questions": [
        {
          "id": 1,
          "text": "Fie urmatoarea declaratie Java:\n\npublic private int h;\n\nCare afirmatii sunt adevarate:",
          "options": {
            "A": "Variabila h va fi accesata in mod public, deoarece se ia in considerare primul modificator de acces;",
            "B": "Variabila h va fi accesata in mod private,deoarece se ia in considerare ultimul modificator de acces;",
            "C": "Va fi eroare la compilare deoarece o variabila nu poate fi  in acelasi timp accesata public si private;",
            "D": "Nici una din variantele de mai sus;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In Java, o variabilă nu poate avea simultan doi modificatori de acces contradictorii, cum sunt \"public\" și \"private\". Modificatorii de acces definesc vizibilitatea și accesibilitatea unui membru al clasei, și fiecare membru poate avea doar un singur modificator de acces. În cazul prezentat în întrebare, încercarea de a declara o variabilă cu ambii modificatori, \"public\" și \"private\", va genera o eroare de compilare, deoarece este o construcție invalidă în Java. Așadar, răspunsul corect este C: va fi eroare la compilare."
        },
        {
          "id": 2,
          "text": "Fie urmatorul cod Java:\n\nint x=0;\nif (Double.isInfinite(2/x))\nSystem.out.println(\"Infinit\");\nelse\nSystem.out.println(\"2/0\");\n\nCe puteti spune despre acest cod, daca este integrat in cadrul unui program Java?",
          "options": {
            "A": "Va produce eroare la compilare din cauza impartirii la 0;",
            "B": "Va produce eroare la executie din cauza impartirii la 0 (se arunca o exceptie: \"ArithmeticExpetion\");",
            "C": "Codul este corect si va afisa Infinit;",
            "D": "Codul este corect si va afisa NaN;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In Java, dividing an integer by zero results in an arithmetic exception. In the given code, `2/x` involves dividing 2 by the integer `x`, which is initialized to 0. When this division by zero occurs, Java throws an `ArithmeticException` at runtime. The method `Double.isInfinite()` is not even reached because the exception interrupts the execution flow. Therefore, option B is correct because the code will produce a runtime error due to division by zero, specifically throwing an `ArithmeticException`."
        },
        {
          "id": 3,
          "text": "Fie urmatorul program Java:\n\npublic class Program{\n    static void f(int k){\n        switch(k){\n            default: System.out.print(\"i \"); break;\n            case 1: System.out.print(\"1 \"); break;\n            case 2: case 3: System.out.print(\"23 \"); break;\n            case 4: case 5: System.out.print(\"45 \");\n        }\n}\npublic static void main(String []args){\n    for(int i=0;i<6;i++)\n    f(i);\n}\n}\n\nCare afirmatii sunt adevarate?",
          "options": {
            "A": "Programul produce eroare la compilare;",
            "B": "Programul se compileaza si la executie afiseaza\ni 1 23 23 45 45 ;",
            "C": "Programul se compileaza si la executie afiseaza\ni 1 23 45 ;",
            "D": "Programul se compileaza si la executie afiseaza\ni 1 23 23 45 45 i;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The Java program provided uses a `switch` statement to handle different cases for the integer variable `k`. When the `main` method is executed, it runs a loop from `i = 0` to `i = 5`, calling the method `f(i)` in each iteration.\n\nHere's how the `switch` statement operates for each value of `k`:\n\n1. For `k = 0`: There is no `case` for 0, so the `default` case is executed, printing \"i \".\n2. For `k = 1`: The `case 1` is matched, printing \"1 \".\n3. For `k = 2`: The `case 2` is matched (fall-through behavior"
        },
        {
          "id": 4,
          "text": "Fie urmatorul cod Java:\n\nbyte b=-7 >>> 1;\nSystem.out.println(b);\n\nCe se poate spune despre acest cod, daca este integrat intr-un program Java?",
          "options": {
            "A": "Va produce eroare la compilare;",
            "B": "Va produce eroare la executie;",
            "C": "Programul se compileaza si la executie afiseaza -3;",
            "D": "Programul se compileaza si la executie afiseaza -4;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. Here's the explanation:\n\nIn Java, the `>>>` operator is the unsigned right shift operator, which means it shifts bits to the right and fills the leftmost bits with zeros, regardless of the sign of the original number. However, this operator only works with `int` and `long` types. In the given code, `b` is declared as a `byte`. The expression `-7 >>> 1` involves an implicit type promotion of `-7` to `int` before the shift operation is applied. As a result, the operation `-7 >>> 1` results in an `int`, not a `byte`. The assignment of the resulting `int` back to a `byte`"
        },
        {
          "id": 5,
          "text": "Ce puteti afirma despre urmatorul program Java?\n\npublic class Static1{\n    public static void main(String []args){\n        Static2 a=new Static2();\n        Static2 b=new Static2();\n        System.out.print(\"a.x= \"+ a.x);\n        a.x=100; b.x=200;\n        System.out.print(\"a.x= \"+a.x);\n    }\n}\nclass Static2{\n    static int x=0;\n    Static2()\n    {\n        x++;\n    };\n}",
          "options": {
            "A": "Afiseaza: a.x=2 a.x=200;",
            "B": "Afiseaza: a.x=0 a.x=100;",
            "C": "Afiseaza: a.x=1 a.x=100;",
            "D": "Programul nu este corect deoarece asignarea lui x, conform obiectului b, este ilegala in Java;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. The explanation for this is based on the use of the `static` keyword in Java. The variable `x` in the `Static2` class is declared as a static variable, meaning it is shared among all instances of the class. \n\nHere's a step-by-step breakdown of what happens in the program:\n\n1. When `Static2 a = new Static2();` is executed, the constructor of `Static2` is called, which increments `x` from 0 to 1.\n\n2. When `Static2 b = new Static2();` is executed, the constructor is called again, incrementing `x` from 1 to 2.\n\n3. The first `System.out.print(\"a"
        },
        {
          "id": 6,
          "text": "Ce se va afisa la executia urmatorului program Java?\n\ninterface I1{\n    float x=2.3f;\n}\npublic class Test implements I1{\n    public static void main(String [] args){\n        System.out.print(x+\" \");\n        x=6.7f;\n        System.out.print(x);\n    }\n}",
          "options": {
            "A": "Va aparea eroare la compilare deoarece valoarea variabilei x nu se mai poate modifica;",
            "B": "La executie se va afisa:\n2.3f 6.7f;",
            "C": "La executie se va afisa:\n2.3f 2.3f;",
            "D": "La executie se va afisa:\n2.3 6.7;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. In Java, fields defined in an interface are implicitly `public`, `static`, and `final`. This means that the variable `x` in the interface `I1` is a constant and cannot be modified. When the program attempts to assign a new value to `x` (`x = 6.7f;`), it results in a compilation error because `x` is `final` and cannot be reassigned. Therefore, the program will not compile, and an error will occur at the line where the code tries to change the value of `x`."
        },
        {
          "id": 7,
          "text": "Ce puteti spune despre urmatorul program Java?\n\nclass C1{\n    int x=1;\n    void f(int x){\n        this.x=x;\n    }\nint getX_C1(){\n    return x;\n}\n}\nclass C2 extends C1{\n    float x=5.0f;\n    int f(int x){\n        super.f((int)x);\n    }\nfloat getX_C2(){\n    return x;\n}\n}\npublic class Subiect9{\n    public static void main(String []args){\n        C2 obiect = new C2();\n        obiect.f(4);\n        System.out.print(obiect.getX_C2() + \" \");\n        System.out.println(obiect.getX_C1());\n    }\n}",
          "options": {
            "A": "Programul este corect si va afisa la executie 5 4;",
            "B": "Programul este corect si va afisa la executie 4.0 4;",
            "C": "Va aparea eroare la compilare deoarece in clasa C2 s-a suprascris gresit atributul x din clasa C1;",
            "D": "Va aparea eroare la compilare deoarece metoda suprascrisa f() din clasa C2  intoarce un tip diferit de void;"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The correct answer is D. The program will result in a compilation error due to the method `f(int x)` in class `C2` having a different return type than its overridden counterpart in class `C1`. In Java, when you override a method, the return type must remain the same as in the superclass unless the return type is covariant (i.e., the return type can be a subclass of the original return type). In this case, `void` and `int` are not compatible return types, so it results in a compilation error."
        },
        {
          "id": 8,
          "text": "Ce puteti spune despre urmatorul program Java?\n\npublic class Test{\n    public static void main(String []args){\n        C1 obiect =new C1();\n        obiect.f(4,3);\n    }\n}\nclass C1{\n    public void f(int xx, final int yy){\n        int a=xx+yy;\n        final int b=xx-yy;\n        class C2{\n            public void g(){\n                System.out.print(\"a= \"+a);\n                System.out.print(\", b= \"+b);\n            }\n    }\nC2 obiect2 = new C2();\nobiect2.g();\n}\n}",
          "options": {
            "A": "Programul este corect si va afisa la executie a=4, b=3;",
            "B": "Va aparea eroare la compilare, deoarece clasa C2 nu poate fi definita in metoda f() din clasa C1;",
            "C": "Va aparea eroare la compilare deoarece in metoda g() nu putem accesa vari- abila locala a din metoda f();",
            "D": "Va aparea eroare la compilare deoarece nu se creeaza in clasa Test un obiect de tip C1.C2;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The correct answer is C. In Java, local classes (such as class C2 defined within the method f of class C1) can only access final or effectively final local variables from the enclosing scope. In this program, the variable `a` is not declared as final, nor is it effectively final because it is computed using non-final parameters `xx` and `yy`. Therefore, attempting to access `a` within the method `g` of class C2 will result in a compilation error. On the other hand, the variable `b` is declared as final, so it can be accessed without any issues."
        },
        {
          "id": 9,
          "text": "Un fir de executie poate intra in starea ”blocat” (blocked) astfel?",
          "options": {
            "A": "Prin apelul metodei sleep();",
            "B": "Automat de catre sistemul de operare;",
            "C": "Prin apelul metodei block();",
            "D": "Prin apelul metodei wait();"
          },
          "correct_answer": [
            "A",
            "D"
          ],
          "explanation": "In the context of thread management, a thread can enter a \"blocked\" state under certain conditions. \n\n- Option A, \"Prin apelul metodei sleep();\", is correct because calling the `sleep()` method on a thread causes it to pause execution for a specified period, effectively putting it in a blocked state during that time.\n\n- Option D, \"Prin apelul metodei wait();\", is also correct because when a thread calls `wait()`, it releases any locks it holds and enters a blocked state, waiting to be notified or interrupted.\n\nOption B, \"Automat de catre sistemul de operare,\" is not specific enough, as threads are generally blocked due to specific actions like I/O operations or synchronization, not automatically."
        },
        {
          "id": 10,
          "text": "Care dintre urmatoarele propozitii referitoare la metodele unui applet sunt adevarate?",
          "options": {
            "A": "Trebuie sa redefinim macar o metoda altfel obtinem eroare la compilare;",
            "B": "Sunt apelate automat de navigatorul Web;",
            "C": "Pot fi apelate direct de catre utilizator;",
            "D": "Nu se pot declara noi metode;"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "In the context of applets, which are small Java programs that run within a web browser, the methods of an applet are managed in specific ways:\n\nA. Incorrect. It is not mandatory to redefine any methods for an applet to compile; however, redefining methods like `init()`, `start()`, `stop()`, and `destroy()` is common to define specific behaviors.\n\nB. Correct. The web browser automatically calls certain lifecycle methods of the applet, such as `init()`, `start()`, `stop()`, and `destroy()` at appropriate times during the applet's lifecycle.\n\nC. Correct. Methods of an applet can be invoked directly by users, usually through interactions, such as clicking a button or"
        },
        {
          "id": 11,
          "text": "Care dintre gestionarii de pozitionare (Layout Managers) de mai jos pot fi utilizati pentru applet- uri?",
          "options": {
            "A": "GridBagLayout;",
            "B": "TableLayout;",
            "C": "DefaultLayout;",
            "D": "FlowLayout;"
          },
          "correct_answer": [
            "A",
            "D"
          ],
          "explanation": "In Java's Abstract Window Toolkit (AWT), layout managers are used to arrange components within a container. The `GridBagLayout` and `FlowLayout` are standard layout managers provided by AWT that can be utilized in applets to control the positioning and sizing of components. \n\n- **GridBagLayout (A):** This is a versatile and flexible layout manager that allows for complex layouts with varying component sizes and alignments, suitable for arranging components in a grid-like manner with different constraints.\n\n- **FlowLayout (D):** This layout manager arranges components in a left-to-right flow, much like text in a paragraph, and is suitable for simple, straightforward layouts.\n\nOn the other hand, `TableLayout` and `DefaultLayout"
        },
        {
          "id": 12,
          "text": "Ce metode trebuie definite pentru a putea desena pe suprafata applet-ului?",
          "options": {
            "A": "Nu trebuie definita nici o metoda;",
            "B": "update();",
            "C": "paint();",
            "D": "repaint();"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In Java applets, the `paint()` method is crucial for rendering graphics on the applet's surface. When an applet needs to display or update its visual content, the `paint(Graphics g)` method is called by the system. This method provides a `Graphics` object as an argument, which is used to draw shapes, text, and images on the applet's surface. The `update()` and `repaint()` methods are related to the painting process, but `paint()` is the primary method where the actual drawing logic is implemented. `repaint()` requests a call to `update()`, which eventually calls `paint()`, and `update()` is used to clear the previous content before calling `paint()`. Therefore, to"
        },
        {
          "id": 13,
          "text": "Care sunt deosebirile dintre Swing si AWT?",
          "options": {
            "A": "Componentele Swing sunt scrise in totalitate in Java, pe cand in AWT, com- ponentele sunt scrise folosind cod nativ;",
            "B": "Componentele AWT au vizualizarea dependenta de sistemul de operare, iar  in Swing componentele pot avea o aceeasi vizualizare, indiferent de sistemul de operare;",
            "C": "In sistemele de operare Unix componentele AWT nu sunt vizibile, pe cand cele din Swing da;",
            "D": "Fiecare componenta AWT are o componenta corespondenta in Swing;"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "Swing și AWT sunt două biblioteci utilizate pentru crearea interfețelor grafice în Java. Diferențele principale dintre ele sunt:\n\nA. Componentele Swing sunt scrise complet în Java, ceea ce le face independente de platformă. În schimb, AWT (Abstract Window Toolkit) folosește componente scrise cu ajutorul codului nativ al sistemului de operare, ceea ce poate duce la diferențe de comportament și aspect pe diverse platforme.\n\nB. Componentele AWT depind de aspectul și comportamentul specific sistemului de operare pe care rulează, ceea ce înseamnă că pot arăta diferit pe Windows, Mac, sau Linux."
        },
        {
          "id": 14,
          "text": "Care din fragmentele de cod Java de mai jos dauga un buton unui container de baza JFrame?",
          "options": {
            "A": "JFrame f= new JFrame();\nJPanel p = (JPanel)f.getContentPane();\np.add(new JButton(\"Buton\")) ;",
            "B": "JFrame f= new JFrame();\nf.getContentPane().add(new JButton(\"Buton\"));",
            "C": "JFrame f= new JFrame();\nf. add(new JButton(\"Buton\"));",
            "D": "JFrame f=new JFrame();\nJButton b=new JButton(\"Buton\");\nf.add(b);"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "In Java, a `JFrame` is a top-level container used to create a window. To add components like buttons, you typically add them to the frame's content pane. In the correct options (A and B), the code correctly accesses the content pane of the `JFrame` instance `f` and adds a `JButton` to it.\n\n- **Option A**: Retrieves the content pane as a `JPanel` and adds a new `JButton` to this panel. This is a valid way to add components to the content pane.\n\n- **Option B**: Directly adds a new `JButton` to the content pane using `f.getContentPane().add()`. This is straightforward and correct.\n\n- **"
        },
        {
          "id": 15,
          "text": "Fie urmatoarea secventa de cod:\n\nJPanel p =new JPanel();\nJlabel e = new JLabel(\"Eticheta:\");\ne.setDisplayedMnemonic(’E’);\np.add(e, BorderLayout.EAST);\nJTextField t = new JTextField(7);\ne.setLabelFor(t);\np.add(t, BorderLayout.WEST);\n\nCe se va intampla la apasarea combinatiei de taste: Alt + E?",
          "options": {
            "A": "Eticheta e va detine focusul;",
            "B": "Campul t va detine focusul;",
            "C": "Nici o componenta nu va detine focusul;",
            "D": "Panoul p va detine focusul;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In the provided code, a `JLabel` is created with the text \"Eticheta:\" and a mnemonic 'E' is set for it using `setDisplayedMnemonic('E')`. This mnemonic allows users to interact with the interface via keyboard shortcuts. The `JLabel` is then associated with a `JTextField` using the `setLabelFor(t)` method. This association means that when the mnemonic key (Alt + E) is pressed, the focus will be transferred to the `JTextField` component (`t`). Thus, option B is correct because pressing Alt + E will result in the text field `t` gaining focus."
        },
        {
          "id": 16,
          "text": "Care dintre urmatoarele afirmatii referitoare la componenta grafica JTable sunt adevarate?",
          "options": {
            "A": "Intotdeauna o componenta JTable are asociata un model de date, chiar daca nu specificam explicit acest lucru;",
            "B": "Prin modificarile efectuate asupra datelor unui model, se va actualiza automat si vizualizarea tabelului;",
            "C": "Pentru a crea o tabela folosind modelul AbstractModelTable, este indeajuns sa suprascriem metodele getRowCount() si getColumnCount();",
            "D": "Modelul de date AbstractTableModel tine datele intotdeauna intr-un Vector avand ele- mente Vector;"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "The correct answers, A and B, relate to how JTable functions in Java:\n\nA. True. A JTable always has an associated data model. If you don't explicitly provide one, JTable will automatically create a default data model for you. This ensures that JTable has a structure to hold and manage the data it displays.\n\nB. True. JTable is designed to be a view component that reflects changes made to its underlying data model. When you modify the data in the model, JTable listens for these changes and updates its display accordingly, maintaining synchronization between the data and the view.\n\nC. False. While overriding `getRowCount()` and `getColumnCount()` is necessary, it is not sufficient to create a functional table with AbstractTableModel. You also"
        },
        {
          "id": 17,
          "text": "JDesktopPane este un exemplu de:",
          "options": {
            "A": "Container pentru JInternalFrame;",
            "B": "Subclasa pentru JLayeredPane;",
            "C": "Subclasa pentru JInternalFrame;",
            "D": "Componenta atomica simpla;"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "JDesktopPane is a part of the Java Swing library used to create Multi-Document Interface (MDI) applications. It serves two primary purposes:\n\nA. Container pentru JInternalFrame: JDesktopPane is specifically designed to be a container for JInternalFrame objects, which are similar to individual frames (like windows) but reside within a desktop pane. This allows for the management of multiple internal frames within a single main window.\n\nB. Subclasa pentru JLayeredPane: JDesktopPane extends JLayeredPane, meaning it inherits its properties and functionalities. JLayeredPane allows components to be placed in different layers, enabling overlapping components with varying levels of visibility, which is essential for managing multiple internal frames within the desktop pane.\n\nTherefore"
        },
        {
          "id": 18,
          "text": "Fie urmatorul program Java:\n\npublic class Afisare {\n    public static void main (String[] args) {\n        for (int i = 0; i < args.length; i++)\n        System.out.println(args[i]);\n    }\n}\n\nUn apel de genul java Afisare \"Hello Java\"; va produce urmatorul rezultat:",
          "options": {
            "A": "Hello Java;",
            "B": "Hello\nJava;",
            "C": "Programul este incorect, deoarece nu sunt prezente argumentele;",
            "D": "NaN;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Explanation: The Java program defines a class `Afisare` with a `main` method that takes an array of `String` arguments (`args`). The `for` loop iterates over each element in the `args` array and prints it using `System.out.println()`. When the program is executed with the command `java Afisare \"Hello Java\";`, the entire string \"Hello Java\" is passed as a single argument to the program because it's enclosed in quotes. Therefore, `args` contains one element: the string \"Hello Java\". The loop prints this single element, resulting in the output \"Hello Java\", corresponding to option A."
        },
        {
          "id": 19,
          "text": "Fie urmatorul program Java:\n\npublic class Program{\n    static void f(int k){\n        switch(k){\n            default: System.out.print(\"i \"); break;\n            case 1: System.out.print(\"1 \"); break;\n            case 2: case 3: System.out.print(\"21 \"); break;\n            case 4: case 5: System.out.print(\"26 \");\n        }\n}\npublic static void main(String []args){\n    for(int i=0;i<6;i++)\n    f(i);\n}\n}\n\nCare afirmatii sunt false?",
          "options": {
            "A": "Eroare la compilare;",
            "B": "Programul se compileaza si la executie afiseaza\ni 1 21 21 26 26 ;",
            "C": "Programul se compileaza si la executie afiseaza\ni 1 21 26 ;",
            "D": "Programul se compileaza si la executie afiseaza\ni 1 21 21 26 26 i;"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "The given Java program defines a class `Program` with a static method `f(int k)`, which uses a `switch` statement to print different outputs based on the value of `k`. The `main` method iterates from 0 to 5 and calls the `f` method with each value. Here's a breakdown of the behavior:\n\n- For `k=0`: The `switch` statement does not have a case for 0, so it defaults, printing \"i \".\n- For `k=1`: The `switch` statement matches case 1, printing \"1 \".\n- For `k=2` and `k=3`: Both 2 and 3 fall through to the same block, printing \"21 \"."
        },
        {
          "id": 20,
          "text": "Se utilizeaza protected  in Java pentru date si metode la care nu este necesar:",
          "options": {
            "A": "Sa facem o initializare;",
            "B": "Sa le accesam in subclase;",
            "C": "Ca utilizatorul sa aiba acces;",
            "D": "Accesul direct atunci cand clasa este utilizata dar care prezinta interes atunci\ncand cineva creeaza o subclasa a acesteia ca parte a unui pachet diferit, in\nvederea extinderii ei;"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "In Java, the `protected` access modifier is used to allow access to class members (fields and methods) within the same package and also by subclasses, even if they are in different packages. The correct answer (D) highlights that `protected` is specifically useful when you want to allow subclasses, potentially in other packages, to access certain members of the class. This facilitates extending the class functionality while maintaining encapsulation for the rest of the package, aligning with object-oriented principles that promote code reusability and extension."
        },
        {
          "id": 21,
          "text": "O subclasa a unei clase abstracte poate fi instantiata numai daca:",
          "options": {
            "A": "Se foloseste cuvantul cheie abstract;",
            "B": "Suprascrie fiecare metoda declarata abstracta in superclasa sa, si furnizeaza implementari pentru toate acestea;",
            "C": "Se foloseste mostenirea multipla;",
            "D": "O subclasa abstracta nu poate fi instantiata;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In contextul programării orientate pe obiecte, o clasă abstractă este o clasă care nu poate fi instanțiată direct și poate conține metode abstracte, care sunt declarate fără implementare. O subclasă a unei clase abstracte poate fi instanțiată doar dacă suprascrie toate metodele abstracte ale clasei părinte și furnizează implementări concrete pentru acestea. Astfel, opțiunea B este corectă deoarece subliniază necesitatea ca toate metodele abstracte să fie implementate în subclasă pentru a putea crea obiecte din aceasta."
        },
        {
          "id": 22,
          "text": "Prin modalitatea sa de tratare a exceptiilor, Java are urmatoarele avantaje fata de mecanismul traditional de tratare a erorilor:",
          "options": {
            "A": "Exista o metoda care se ocupa cu acest lucru;",
            "B": "Separarea codului pentru tratarea unei erori de codul  in care ea poate sa apara;",
            "C": "Propagarea unei erori pana la un analizor de exceptii corespunzator;",
            "D": "Gruparea erorilor dupa tipul lor;"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "In Java, the exception handling mechanism offers several advantages over traditional error handling methods:\n\nB. Separarea codului pentru tratarea unei erori de codul în care ea poate să apară: Java's exception handling allows for a clear separation between the code responsible for executing a task and the code responsible for handling errors. This separation improves code readability and maintainability.\n\nC. Propagarea unei erori până la un analizor de excepții corespunzător: Java allows exceptions to be propagated up the call stack until they are caught by an appropriate exception handler. This propagation ensures that errors can be handled at the most appropriate level in the program.\n\nD. Gruparea erorilor după tipul lor: Java's exception handling framework enables"
        },
        {
          "id": 23,
          "text": "Metodele care sunt apelate uzual pentru un obiect de tip exceptie sunt definite in clasa Throwable si sunt:",
          "options": {
            "A": "Declarate cu modificatorul de acces private;",
            "B": "dinamice;",
            "C": "publice;",
            "D": "exceptii;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In Java, the class `Throwable` is the superclass for all errors and exceptions. The methods defined in this class, which are commonly used for handling exceptions, are intended to be accessible to any code that handles exceptions. Therefore, these methods are declared with the `public` access modifier. This allows them to be called from any other code that has access to an instance of a `Throwable` or its subclasses, enabling effective exception handling across different parts of a program. Hence, the correct answer is C. Public methods ensure that essential functionalities like retrieving the exception message, stack trace, or cause are accessible wherever needed."
        },
        {
          "id": 24,
          "text": "Un fir de executie poate intra in starea de ready astfel:",
          "options": {
            "A": "Prin apelul metodei sleep();",
            "B": "Automat de catre sistemul de operare;",
            "C": "Prin apelul metodei join();",
            "D": "Niciodata;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The correct answer is B: Automat de catre sistemul de operare.\n\nExplanation: In the context of operating systems and multithreading, a thread can enter the \"ready\" state automatically by the operating system when it is prepared to run but is not currently executing. This transition usually occurs after the thread has been blocked (e.g., waiting for I/O or a resource) and the resource becomes available, or when the thread's sleep duration is over. The operating system manages thread states and transitions, moving threads into the \"ready\" state when they are eligible to use the CPU. The other options involve explicit actions like sleeping or joining, which typically block a thread rather than make it ready to run."
        },
        {
          "id": 25,
          "text": "Cand browser-ul intalneste tag-ul < APPLET >, rezerva o zona pentru afisare cu dimensiunile\nspecificate de paramterii WIDTH, HEIGHT si:",
          "options": {
            "A": "Se instaleaza un manager de securitate, adica un obiect de tip SecurityManager care va monitoriza activitatea metodelor appletului, aruncand exceptii de tip SecurityException;",
            "B": "Incarca codul compilat al applet-ului cu numele specificat de parametrul CODE;",
            "C": "Creaza o instanta a clasei Applet dupa care apeleaza metodele init() si start();",
            "D": "Se deschid mai multe procese pe masina client;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "When a web browser encounters the `<APPLET>` tag in an HTML document, it reserves a display area with the specified dimensions given by the WIDTH and HEIGHT parameters. The correct sequence of actions taken by the browser is described in option C: the browser creates an instance of the Applet class and then invokes the `init()` and `start()` methods. \n\nHere's why the other options are incorrect:\n- Option A is incorrect because while a security manager is involved in applet execution to ensure safe operations, this is not the primary function performed immediately upon encountering the `<APPLET>` tag.\n- Option B is partially true in that the applet's compiled code is loaded, but creating an instance of the applet and calling the `init()` and"
        },
        {
          "id": 26,
          "text": "Care dintre urmatoarele coduri nu reprezinta arhivarea fisierelor unui applet?",
          "options": {
            "A": "jar cvf arhiva.jar ClasaPrincipala.java imagine.jpg;",
            "B": "jar cvf arhiva.jar *.class *.jpg *.au;",
            "C": "jar cfv arhiva.jar *.class *.jpg *.au;",
            "D": "jar cvf arhiva.jar ClasaPrincipala.class AltaClasa.class imagine.jpg sunet.au"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "In the context of creating a JAR (Java ARchive) file for an applet, the `jar` command is used to package multiple files into a single archive file. The command typically uses options like `c` (create), `v` (verbose), and `f` (file name).\n\n- Option A: `jar cvf arhiva.jar ClasaPrincipala.java imagine.jpg;` is incorrect because it includes a `.java` file, which is source code, not compiled bytecode. Applets require compiled `.class` files to run.\n\n- Option C: `jar cfv arhiva.jar *.class *.jpg *.au;` is technically correct in syntax and functionality. However, the sequence of options does not"
        },
        {
          "id": 27,
          "text": "In care din exemplele de mai jos se foloseste corect variabila iLocation?",
          "options": {
            "A": "tabbedPanel.insertTab( \"Inserted Page\", new ImageIcon( \"image.gif\" ), pagePanel,\"My tooltip text\",iLocation );",
            "B": "JFrame f= new JFrame(); f.getContentPane().add(new JButton(\"Buton\", iLocation));",
            "C": "tabbedPanel.removeTabAt( iLocation );",
            "D": "JFrame f=new JFrame(); JButton b=new JButton(\"Buton\"); f.add(b, iLocation);"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "The question asks about the correct use of the variable `iLocation` in different contexts. \n\nIn option A, `iLocation` is correctly used as an index parameter in the `insertTab` method of a `JTabbedPane` object. This method typically takes an index parameter to specify the position where the new tab should be inserted.\n\nIn option C, `iLocation` is correctly used as an index parameter in the `removeTabAt` method of a `JTabbedPane` object. This method uses the index to identify which tab to remove.\n\nOption B is incorrect because the `add` method of a `Container` (like `JFrame`) that takes a `Component` and a `String` or `Object` as"
        },
        {
          "id": 28,
          "text": "Ce rezulta din urmatorul fragment de cod Java?\n\nint x=1;\nString []names={\"Fred\",\"Jim\",\"Sheila\"};\nnames[--x]+=\".\";\nfor(int i=0;i<names.length;i++)\nSystem.out.println(names[i]);",
          "options": {
            "A": "Output-ul include Sheila.;",
            "B": "Output-ul include Fred.;",
            "C": "Output-ul include Jim.;",
            "D": "Nimic din cele de mai sus;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In acest fragment de cod Java, avem o variabila int x initializata cu valoarea 1 si un array de stringuri numit `names` care contine trei elemente: \"Fred\", \"Jim\", si \"Sheila\". Linia `names[--x]+=\".\";` decrementeaza mai intai valoarea lui x de la 1 la 0 (datorita operatorului de pre-decrement `--`) si apoi adauga un punct (\".\") la elementul din array corespunzator indexului 0, care este \"Fred\". Astfel, \"Fred\" devine \"Fred.\". In bucla for, fiecare element al array-ului `names` este afisat pe rand."
        },
        {
          "id": 29,
          "text": "Applet-urile se diferentiaza de aplicatiile Java standard prin:",
          "options": {
            "A": "Restrictiile impuse de necesitatea asigurarii unui anumit nivel de securitate si faptul ca nu au o metoda main();",
            "B": "Faptul ca trebuie sa suprascrie toate metodele: init(), start(), stop(), pause() si destroy();",
            "C": "Faptul ca detin un instrument cu ajutorul caruia se creaza relatii de mostenire;",
            "D": "Faptul ca detin un instrument care desemneaza meniurile din cadrul unei forme;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Applet-urile Java sunt programe mici care rulează în interiorul unui browser web și sunt încorporate într-o pagină web. Spre deosebire de aplicațiile Java standard, care rulează independent și au un punct de intrare prin metoda main(), applet-urile nu au o astfel de metodă. În plus, din motive de securitate, applet-urile sunt supuse unor restricții stricte. De exemplu, ele rulează într-un sandbox, ceea ce înseamnă că nu pot accesa resursele locale ale calculatorului utilizatorului, cum ar fi fișierele de pe disc, și nu pot efectua operații care ar putea compromite securitatea sistemului gaz"
        },
        {
          "id": 30,
          "text": "Declararea constructorilor trebuie sa tina cont de:",
          "options": {
            "A": "relatia de mostenire dintre clase;",
            "B": "numele constructorului, care trebuie sa fie identic cu numele clasei;",
            "C": "comportamentul obiectelor pe care le instantiaza;",
            "D": "o metoda prin care poate fi accesat de toate tipurile din Java sau de tipuri mostenite din tipul care contine membrul in discutie; 5 Algoritmica grafurilor"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Explanation: In object-oriented programming, a constructor is a special method used to initialize objects of a class. The key characteristic of a constructor is that it must have the same name as the class it belongs to. This is why option B is the correct answer. It ensures that when an object is created, the constructor is automatically called to set up the initial state of the object. Options A, C, and D, while related to classes and objects, do not specifically address the requirement that the constructor's name must match the class name."
        }
      ]
    },
    {
      "name": "Algoritmica grafurilor",
      "questions": [
        {
          "id": 1,
          "text": "O procedura ce parcurge arborele binar in postordine va afisa:",
          "image": "grafuri_1.png",
          "options": {
            "A": "A B C D E F",
            "B": "A B D E C F",
            "C": "D B E A F C",
            "D": "D E B F C A",
            "E": "D E F B C A"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "In a postorder traversal of a binary tree, the nodes are visited in the following order: left subtree, right subtree, and then the root node. This means that for each subtree, you first process all the nodes in the left subtree, then all the nodes in the right subtree, and finally the root of the subtree.\n\nTo understand why option D is correct, let's break down the traversal process for a binary tree:\n\n1. Start with the leftmost subtree and traverse it postorder: left, right, root.\n2. Move to the right subtree of the initial root and traverse it in the same manner: left, right, root.\n3. Finally, visit the root node of the entire tree.\n\nFollowing this method, the sequence of"
        },
        {
          "id": 2,
          "text": "O procedura ce parcurge arborele binar  in preordine va afisa:",
          "image": "grafuri_2.png",
          "options": {
            "A": "J D P B H L R F N",
            "B": "J D B H F P L N R",
            "C": "N F R L H B P D J",
            "D": "B D H F N L P R J",
            "E": "B D F H L J N P R"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The question asks about the traversal order of nodes in a binary tree when using the pre-order traversal method. In pre-order traversal, nodes are visited in the following order: \n\n1. Visit the root node.\n2. Traverse the left subtree in pre-order.\n3. Traverse the right subtree in pre-order.\n\nGiven this method, the correct sequence for visiting the nodes in the binary tree is \"J D B H F P L N R\", which corresponds to option B. This sequence starts with the root node (J), followed by the pre-order traversal of the left subtree (D B H F) and then the right subtree (P L N R)."
        },
        {
          "id": 3,
          "text": "O procedura ce parcurge arborele binar  in inordine va afisa:",
          "image": "grafuri_3.png",
          "options": {
            "A": "B H F D L N P R J",
            "B": "B D H F N L P R J",
            "C": "N F R L H B P D J",
            "D": "J D P B H L R F N",
            "E": "B D F H J L N P R"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "In-order traversal of a binary tree involves visiting the nodes in the following order: left subtree, root node, right subtree. This traversal method results in the nodes being printed in ascending order for a binary search tree. Given the options, the sequence B D F H J L N P R (option E) reflects this order, as it lists the nodes from the smallest to the largest value, consistent with an in-order traversal of a binary search tree."
        },
        {
          "id": 4,
          "text": "O procedura ce parcurge arborele binar  in A-preordine va afisa:",
          "image": "grafuri_4.png",
          "options": {
            "A": "A B C E F D G H I J",
            "B": "A B C D E F G H I J",
            "C": "B E F C G H I J D A",
            "D": "B A E C F G D H I J",
            "E": "B E F G H I J C D A"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In a binary tree traversal, A-preordine (or pre-order) means visiting nodes in the order of: Root, Left, Right. This traversal starts at the root of the tree, then recursively visits the left subtree followed by the right subtree. Given the correct answer is A, the sequence \"A B C E F D G H I J\" follows this pattern. It begins with the root node \"A\", followed by the left subtree nodes \"B\", \"C\", \"E\", \"F\", and then traverses the right subtree nodes \"D\", \"G\", \"H\", \"I\", \"J\". This matches the pre-order traversal method."
        },
        {
          "id": 5,
          "text": "Care este numarul maxim de componente conexe pe care le poate avea un graf neorientat cu 20 de noduri si 12 muchii?",
          "options": {
            "A": "6",
            "B": "12",
            "C": "10",
            "D": "15",
            "E": "18"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "To determine the maximum number of connected components in an undirected graph with 20 nodes and 12 edges, we can use the concept that a connected component is a subset of the graph where any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph.\n\nFor the maximum number of connected components, the graph should have as many isolated nodes as possible because isolated nodes are their own connected components. If there are 20 nodes and 12 edges, the least number of nodes that can be connected by these edges is 12 (since each edge connects two nodes). Thus, the maximum number of isolated nodes is \\(20 - 12 = 8\\).\n\nNow, if we have 8 isolated"
        },
        {
          "id": 6,
          "text": "Cate grafuri neorientate, distincte, cu 4 varfuri se pot construi? Doua grafuri se considera distincte \ndaca matricele lor de adiacenta sunt diferite.",
          "options": {
            "A": "4⁶",
            "B": "2⁶",
            "C": "6⁴",
            "D": "4",
            "E": "2¹⁰"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To determine how many distinct undirected graphs with 4 vertices can be constructed, we need to consider the potential edges between these vertices. In an undirected graph with \\( n \\) vertices, the maximum number of possible edges is given by the binomial coefficient \\(\\binom{n}{2}\\), which represents the number of ways to choose 2 vertices from \\( n \\) to form an edge.\n\nFor 4 vertices, the number of possible edges is:\n\n\\[\n\\binom{4}{2} = 6\n\\]\n\nThis is because each pair of vertices can either be connected by an edge or not, and since there are no loops or multiple edges in simple undirected graphs, each of these 6 pairs can"
        },
        {
          "id": 7,
          "text": "Intr-un graf neorientat cu 10 muchii, fiecare nod are gradul un numar nenul. Doar trei dintre noduri \nau gradul un numar par, restul nodurilor avand gradele numere impare. Care este numarul maxim \nde noduri pe care poate sa le aiba graful?",
          "options": {
            "A": "14",
            "B": "10",
            "C": "17",
            "D": "16",
            "E": "19"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In a graph, the sum of the degrees of all the nodes is equal to twice the number of edges (known as the Handshaking Lemma). In this case, the graph has 10 edges, so the sum of the degrees of all the nodes is \\(2 \\times 10 = 20\\).\n\nAccording to the problem, three nodes have even degrees, and the remaining nodes have odd degrees. Let's assume the number of nodes with odd degrees is \\(x\\), so \\(x + 3\\) is the total number of nodes.\n\nThe sum of degrees of nodes with odd degrees is odd, and the sum of degrees of nodes with even degrees is even. The total sum is even (20), which means the sum of"
        },
        {
          "id": 8,
          "text": "Determinati numarul de frunze ale arborelui cu radacina descris prin urmatorul vector tata: (6, 5, 5, 2, 0, 3, 3, 3, 8, 7, 7)?",
          "options": {
            "A": "1",
            "B": "2",
            "C": "4",
            "D": "5",
            "E": "7"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "To determine the number of leaves in a rooted tree described by the given parent vector, we must first understand the structure of the tree. The vector provided indicates the parent of each node, where the index represents the child node and the value at that index represents the parent node.\n\nGiven the vector: (6, 5, 5, 2, 0, 3, 3, 3, 8, 7, 7), the value '0' indicates the root of the tree.\n\nA leaf in a tree is a node that does not have any children. To find the leaves, we need to identify nodes that are not listed as a parent for any other node. By analyzing the vector, we can determine which"
        },
        {
          "id": 9,
          "text": "Care dintre urmatoarele valori pot reprezenta gradele nodurilor unui graf neorientat cu 6 noduri?",
          "options": {
            "A": "(3, 2, 2, 2, 3, 3)",
            "B": "(4, 2, 2, 2, 3, 2)",
            "C": "(5, 2, 2, 2, 0, 3)",
            "D": "(5, 2, 2, 2, 1, 2)",
            "E": "(5, 2, 3, 2, 1, 2)"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "To determine which sequence of node degrees can represent a valid undirected graph with 6 nodes, we must ensure that the sum of the degrees is even, as each edge contributes to the degree count of two nodes. Additionally, each degree must be a non-negative integer and less than the number of nodes (since a node cannot have more edges than the total number of other nodes).\n\nLet's analyze the options:\n\nA. (3, 2, 2, 2, 3, 3)  \nSum = 3 + 2 + 2 + 2 + 3 + 3 = 15 (odd sum, not possible)\n\nB. (4, 2, 2, 2, 3, 2"
        },
        {
          "id": 10,
          "text": "Se considera graful neorientat cu multimea varfurilor {1, 2, 3, 4, 5, 6} si multimea muchiilor \n{[1, 2], [2, 3], [3, 4], [3, 5], [4, 5], [1, 3], [2, 6], [2, 4], [4, 6]}. Care este numarul minim de muchii ce trebuie \neliminate (care sunt aceste muchii) astfel incat graful partial obtinut sa nu mai fie conex?",
          "options": {
            "A": "1",
            "B": "3",
            "C": "2",
            "D": "5",
            "E": "nici una"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To solve this problem, we need to find the minimum number of edges that, when removed, will disconnect the graph. A graph is disconnected if there is at least one pair of vertices that do not have a path between them.\n\nGiven the undirected graph with vertices {1, 2, 3, 4, 5, 6} and edges {[1, 2], [2, 3], [3, 4], [3, 5], [4, 5], [1, 3], [2, 6], [2, 4], [4, 6]}, we can analyze its structure. The goal is to identify a set of edges whose removal results in a disconnected graph with"
        },
        {
          "id": 11,
          "text": "Se considera graful neorientat G cu 8 noduri, care are urmatoarele proprietati: \nI. suma gradelor tuturor nodurilor este 12; \nII. graful are exact 3 noduri cu gradul 1. \nCare este numarul maxim de noduri de grad 0 ale grafului G?",
          "options": {
            "A": "1",
            "B": "4",
            "C": "2",
            "D": "3",
            "E": "0"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To determine the number of nodes with degree 0 in the undirected graph \\( G \\) with 8 nodes, we can use the properties given:\n\n1. The sum of the degrees of all nodes is 12.\n2. The graph has exactly 3 nodes with degree 1.\n\nFirst, consider that the sum of degrees of all nodes in a graph is twice the number of edges. Thus, the graph has 6 edges in total.\n\nNext, since there are 3 nodes with degree 1, these contribute a total degree of \\( 1 \\times 3 = 3 \\) to the sum of degrees. Therefore, the remaining \\( 8 - 3 = 5 \\) nodes must have a combined degree of"
        },
        {
          "id": 12,
          "text": "Se considera graful neorientat cu 80 de noduri si 3160 de muchii. Care este numarul de muchii ce pot fi eliminate astfel incat graful partial obtinut sa devina arbore?",
          "options": {
            "A": "80",
            "B": "3160",
            "C": "3081",
            "D": "6320",
            "E": "2450"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To transform a graph with \\( n \\) nodes into a tree, it must have exactly \\( n-1 \\) edges, because a tree is a connected graph with no cycles and the minimum number of edges that maintains connectivity is \\( n-1 \\). In this case, the graph has 80 nodes, so it must have 79 edges to be a tree. The original graph has 3160 edges. Therefore, the number of edges that need to be removed is \\( 3160 - 79 = 3081 \\). Thus, the correct answer is C."
        },
        {
          "id": 13,
          "text": "Se considera graful orientat G reprezentat prin listele de adiacenta alaturate. Care este lungimea\nmaxima a unui drum elementar din acest graf? Sa se specifice arcele ce compun un drum cu aceste\nproprietati.\n1 2 6 5\n2 3\n3 1\n4 6\n5 6\n6 2",
          "options": {
            "A": "1",
            "B": "7",
            "C": "3",
            "D": "4",
            "E": "5"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "To determine the maximum length of an elementary path in a directed graph (graful orientat) represented by adjacency lists, we need to identify the longest path that does not repeat any vertex. The adjacency lists provided are:\n\n- 1: 2, 6, 5\n- 2: 3\n- 3: 1\n- 4: 6\n- 5: 6\n- 6: 2\n\nAn elementary path is a path that visits each vertex at most once. To find such a path, we can start from any vertex and follow the directed edges, ensuring that we do not revisit any vertex. \n\nOne potential longest elementary path is: 1 → 2 → 3 →"
        },
        {
          "id": 14,
          "text": "Pentru care dintre urmatorii arbori cu radacina, fiecare avand 9 noduri, numerotate de la 1 la 9, \nmemorati cu ajutorul vectorilor tata, nodul 3 are cei mai multi descendenti?",
          "options": {
            "A": "(2, 0, 2, 3, 2, 3, 4, 4, 3)",
            "B": "(3, 3, 4, 0, 2, 3, 4, 4, 4)",
            "C": "(4, 2, 4, 0, 3, 3, 3, 3, 3)",
            "D": "(0, 1, 1, 3, 4, 3, 4, 4, 3)",
            "E": "(0, 1, 2, 3, 4, 5, 6, 7, 8)"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To determine which tree structure has node 3 with the most descendants, we need to analyze the parental relationships defined by each vector. Each vector represents the parent-child relationships in a tree with the index being the child and the value at that index being the parent.\n\n- In option A (2, 0, 2, 3, 2, 3, 4, 4, 3), node 3 is the parent of nodes 4, 6, and 9. Node 4 is the parent of 7 and 8. Thus, node 3 has 5 descendants (4, 6, 9, 7, 8).\n\n- In option B (3, 3, 4"
        },
        {
          "id": 15,
          "text": "Care dintre urmatoarele proprietati este adevarata pentru un graf orientat cu n varfuri si n arce \n(n > 3) si care prezinta un circuit de lungime n:",
          "options": {
            "A": "exista un varf cu gradul intern n(cid:0)1.",
            "B": "pentru orice varf, gradul intern si gradul extern sunt egale.",
            "C": "graful nu are drumuri de lungime strict mai mare decat 2.",
            "D": "gradul intern al oricarui varf este egal cu 2.",
            "E": "daca notam graful cu G = (V, E), |V| = n, atunci |E| = n - 1."
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In a directed graph with \\( n \\) vertices and \\( n \\) arcs that contains a cycle of length \\( n \\), each vertex is part of the cycle, contributing exactly one incoming arc and one outgoing arc. This means that for every vertex, the in-degree (number of incoming arcs) and the out-degree (number of outgoing arcs) are both equal to 1. Therefore, the in-degree and out-degree for each vertex are equal, which makes statement B true. The other options do not hold for such a graph: \n\n- A: No vertex can have an in-degree of \\( n-1 \\) because each vertex only has one incoming arc.\n- C: The graph can have paths longer than 2, as each"
        },
        {
          "id": 16,
          "text": "Care este ordinea de parcurgere a nodurilor grafului din figura 1, daca se foloseste metoda de \nvizitare in latime (BFS) pornind din nodul 5?",
          "image": "grafuri_16.png",
          "options": {
            "A": "5, 2, 1, 3, 4, 7, 6, 8",
            "B": "5, 2, 1, 3, 5, 7, 6, 8",
            "C": "5, 7, 6, 4, 8, 2, 1, 3",
            "D": "5, 2, 7, 1, 6, 3, 4, 8",
            "E": "5, 7, 2, 6, 1, 8, 4, 3"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Explicația: Algoritmul de parcurgere în lățime (BFS - Breadth-First Search) explorează toate nodurile de la același nivel înainte de a trece la nivelul următor. Pornind din nodul 5, BFS vizitează mai întâi toți vecinii direcți ai acestuia. În funcție de figura grafului (care nu este prezentă aici, dar se presupune că răspunsul corect este D), ordinea de vizitare va fi: mai întâi nodurile direct conectate la 5, care sunt 2 și 7. Apoi, algoritmul continuă cu explorarea nodurilor adiacente la 2 și"
        },
        {
          "id": 17,
          "text": "Care este ordinea de parcurgere a nodurilor grafului din figura 2, daca se foloseste metoda de \nvizitare in adancime (DFS) pornind din nodul 3?",
          "image": "grafuri_17.png",
          "options": {
            "A": "3, 5, 7, 6, 4, 8, 2, 1",
            "B": "3, 5, 2, 7, 1, 6, 4, 8",
            "C": "3, 5, 2, 1, 4, 7, 6, 8",
            "D": "3, 5, 2, 1, 4, 6, 8, 7",
            "E": "3, 5, 2, 7, 1, 4, 6, 8"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Depth-First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. Starting from node 3, DFS will explore the graph by visiting one of its neighbors, diving deeper until it reaches a node with no unvisited neighbors, then backtracking. \n\nLet's break down the traversal using DFS from node 3:\n1. Start at node 3.\n2. Visit a neighboring node, say node 5.\n3. From node 5, visit another neighbor, node 2.\n4. From node 2, visit one of its neighbors, node 1.\n5. From node 1, backtrack since all its neighbors are visited, return to node 2.\n6. From"
        },
        {
          "id": 18,
          "text": "Deteminati ordinul si dimensiunea grafului din figura 3?",
          "image": "grafuri_18.png",
          "options": {
            "A": "5, 6",
            "B": "8, 5",
            "C": "7, 6",
            "D": "7, 7",
            "E": "6, 7"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To determine the order and size of a graph, we need to identify the number of vertices (nodes) and the number of edges (connections between nodes) in the graph.\n\n- **Order**: This is the number of vertices in the graph. In Figure 3, there are 7 vertices, so the order is 7.\n- **Size**: This is the number of edges in the graph. In Figure 3, there are 6 edges, so the size is 6.\n\nTherefore, the correct answer is C, which indicates an order of 7 and a size of 6."
        },
        {
          "id": 19,
          "text": "Daca pentru un arbore binar avem un numar de N muchii, sa se determine numarul de muchii \ncritice ale arborelui?",
          "options": {
            "A": "N - 1",
            "B": "N + 1",
            "C": "N/2",
            "D": "(N +1 )/2",
            "E": "N"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "In a tree, every edge is critical because removing any edge would disconnect the tree, splitting it into two separate components. A binary tree with \\( N \\) edges has exactly \\( N \\) critical edges, as each edge is necessary to maintain the connectivity and structure of the tree. Therefore, the correct answer is E: \\( N \\)."
        },
        {
          "id": 20,
          "text": "Daca avem un arbore binar plin cu 9 nivele,sa se determine numarul de varfuri ce se \nafla pe nivelul cu numarul 5?",
          "options": {
            "A": "15",
            "B": "31",
            "C": "2⁵",
            "D": "2⁴",
            "E": "14"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "In a full binary tree, each level \\( n \\) of the tree has \\( 2^n \\) nodes. This is because each node in a binary tree has exactly two children, doubling the number of nodes at each subsequent level. Given a binary tree with 9 levels, we need to determine the number of nodes at level 5 (considering the root level as level 0). \n\nUsing the formula \\( 2^n \\), where \\( n \\) is the level number, the number of nodes on level 5 is \\( 2^5 \\). Calculating this gives \\( 2^5 = 32 \\). However, it seems there was a misunderstanding in the explanation—let me correct that:\n\n-"
        },
        {
          "id": 21,
          "text": "Avand un arbore binar reprezentat prin urmatoarea expresie cu paranteze: \n1(2(3(0, 4(0, 0)), 5(6(0, 0), 7(0, 0))), 8(0, 9(0, 0))). Sa se determine numarul de frunze ale grafului.",
          "options": {
            "A": "4",
            "B": "3",
            "C": "5",
            "D": "9",
            "E": "6"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In a binary tree, a \"leaf\" is a node that does not have any children. The given expression, 1(2(3(0, 4(0, 0)), 5(6(0, 0), 7(0, 0))), 8(0, 9(0, 0))), represents a binary tree using a nested structure where each node is followed by its left and right child in parentheses. A \"0\" indicates the absence of a child, thus marking a node as a leaf if both children are \"0\". \n\nLet's break down the tree:\n- Node 3 has children 0 and 4(0, 0). Node 4 is a leaf because both"
        },
        {
          "id": 22,
          "text": "Avand graful ponderat din figura 4, sa se determine un arbore de acoperire de cost minim. \nVom considera nodul A ca nod de plecare. Care este ordinea de parcurgere a nodurilor?",
          "image": "grafuri_22.png",
          "options": {
            "A": "A, C, B, D, E;",
            "B": "A, B, D, E, C;",
            "C": "A, D, E, C, B;",
            "D": "A, B, D, C, E;",
            "E": "A, B, E, B, D;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To determine a minimum spanning tree (MST) using a starting node, such as node A, we typically apply algorithms like Prim's or Kruskal's. Given that the problem specifies a starting node, Prim's algorithm is more relevant here. Prim's algorithm starts at a chosen node and grows the MST by repeatedly adding the cheapest edge from the tree to a vertex not yet in the tree. \n\nStarting from node A, the process involves:\n\n1. Select the edge with the smallest weight that connects A to another node. Assume this connects to node B.\n2. From nodes A and B, choose the next smallest edge that connects to a new node, continuing this process.\n3. Following this logic with the least costly connections, the order"
        }
      ]
    },
    {
      "name": "Metode de analiza a algoritmilor",
      "questions": [
        {
          "id": 1,
          "text": "Care este expresia timpului de executie T(n) al urmatorului algoritm in cazul cel mai favorabil, \nin cazul mediu si in cazul cel mai defavorabil, unde n noteaza dimensiunea setului de intrare, \niar k, k1, ..., k8 - orice constanta pozitiva:",
          "image": "maa_1.png",
          "options": {
            "A": "k, k1n, k2n + k3",
            "B": "k1n + k2, k3n + k4, k5n + k6",
            "C": "k, k1n + k2, k2n² + k3n + k4",
            "D": "k1n + k2, k3n + k4, k5n² + k6n + k7",
            "E": "k, k1n² + k2n + k3, k4n² + k5n + k6",
            "F": "k1n + k2, k3n² + k4n + k5, k6n² + k7n + k8"
          },
          "correct_answer": [
            "F"
          ],
          "explanation": "The correct answer is F because it appropriately reflects how the time complexity of an algorithm can vary depending on the scenario (best case, average case, and worst case) and the size of the input set, \\( n \\).\n\n- **Best Case (F: \\( k_1n + k_2 \\))**: This suggests that the algorithm performs linearly with respect to the input size \\( n \\) in the most favorable scenario. The linear term \\( k_1n \\) dominates the expression, indicating that each element is processed a constant number of times.\n\n- **Average Case (F: \\( k_3n^2 + k_4n + k_5 \\))**: This indicates a quadratic time complexity, which"
        },
        {
          "id": 2,
          "text": "Determinati in care caz timpii de executie T1(n) si T2(n) au acelasi ordin de crestere, unde prin n\nnotam dimensiunea datelor de inrtare iar k noteaza o constanta oarecare pozitiva: ",
          "options": {
            "A": "lim (n → ∞) (T1(n)/T2(n)) = 0",
            "B": "lim (n → ∞) (T1(n)/T2(n)) = ∞",
            "C": "lim (n → ∞) (T1(n)/T2(n)) = k"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To determine if two functions \\( T_1(n) \\) and \\( T_2(n) \\) have the same order of growth, we use the concept of asymptotic equivalence. Specifically, two functions are said to grow at the same rate if the limit of their ratio is a positive constant as \\( n \\) approaches infinity. \n\nIn the context of the given multiple choice question, the limit \\(\\lim_{n \\to \\infty} \\frac{T_1(n)}{T_2(n)} = k\\) (where \\( k \\) is a positive constant) indicates that \\( T_1(n) \\) and \\( T_2(n) \\) grow proportionally to each other for large"
        },
        {
          "id": 3,
          "text": "Pentru lim (n → ∞) (f(n)/g(n)) = ∞, care din urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "f(n) ∈ ω(g(n))",
            "B": "f(n) ∈ Θ(g(n))",
            "C": "f(n) ∈ Ω(g(n))"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "To determine which statements are true given that \\(\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\), we need to understand the implications of this limit in terms of asymptotic notation.\n\n- **A. \\(f(n) \\in \\omega(g(n))\\):** This notation means that \\(f(n)\\) grows much faster than \\(g(n)\\) as \\(n\\) approaches infinity. The condition \\(\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\) directly implies that \\(f(n)\\) grows faster than \\(g(n)\\), which satisfies the condition for \\(f(n)"
        },
        {
          "id": 4,
          "text": "Pentru f(n) ∈ Θ(n) si g(n) ∈ Ω(n) atunci",
          "options": {
            "A": "f(n)g(n) ∈ Ω(n²)",
            "B": "f(n)g(n) ∈ Θ(n²)",
            "C": "f(n)g(n) ∈ O(n²)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To understand why the correct answer is A, let's analyze the given information:\n\n1. **f(n) ∈ Θ(n):** This means that f(n) grows linearly with n. Specifically, there exist positive constants c1, c2, and n0 such that for all n ≥ n0, c1n ≤ f(n) ≤ c2n.\n\n2. **g(n) ∈ Ω(n):** This indicates that g(n) grows at least linearly with n. There exists a positive constant c3 and an n1 such that for all n ≥ n1, g(n) ≥ c3n.\n\nNow, consider the product f(n)g(n):\n\n- Since f(n) is bounded between c"
        },
        {
          "id": 5,
          "text": "Pentru f(n)=6n^3 + 14n^2 - 8n + 4 si g(n)=2n^3 care din urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "f(n), g(n) ∈ O(2n^3)",
            "B": "f(n), g(n) ∈ O(n^3)",
            "C": "f(n) ∈ O(6n^3) si g(n) ∈ O(2n^3)"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "To determine the asymptotic behavior of the functions \\( f(n) = 6n^3 + 14n^2 - 8n + 4 \\) and \\( g(n) = 2n^3 \\), we use Big O notation, which describes an upper bound on the growth rate of a function.\n\n- **f(n) = 6n^3 + 14n^2 - 8n + 4**: The dominant term is \\( 6n^3 \\), so \\( f(n) \\) is asymptotically equivalent to \\( 6n^3 \\). Thus, \\( f(n) \\) is in \\( O(n^3) \\) because the highest degree term"
        },
        {
          "id": 6,
          "text": "Pentru f(n) ∈ Ω(n) si g(n) ∈ O(n2) atunci",
          "options": {
            "A": "(f(n) / g(n)) ∈ Ω(n)",
            "B": "(f(n) / g(n)) ∈ O(n)",
            "C": "(f(n) / g(n)) ∈ Θ(n)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To understand why the correct answer is B, let's break down the problem using the definitions of Big Omega (Ω) and Big O (O) notation.\n\n1. **f(n) ∈ Ω(n)**: This means that f(n) grows at least as fast as a constant multiple of n for sufficiently large n. In other words, there exists a positive constant c and a value n₀ such that for all n ≥ n₀, f(n) ≥ c * n.\n\n2. **g(n) ∈ O(n²)**: This means that g(n) grows at most as fast as a constant multiple of n² for sufficiently large n. In other words, there exists a positive constant C and a value n"
        },
        {
          "id": 7,
          "text": "Pentru f(n) ∈ O(h(n)) si h(n) ∈ O(g(n)) atunci",
          "options": {
            "A": "functia f(n) este echivalenta cu g(n)",
            "B": "f(n) ∈ O(g(n))",
            "C": "f(n) ∈ Θ(g(n))"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The correct answer is B: \\( f(n) \\in O(g(n)) \\).\n\nExplanation: Big O notation, \\( O \\), is used to describe an upper bound on the growth rate of a function. If \\( f(n) \\in O(h(n)) \\), it means that the growth rate of \\( f(n) \\) is at most the growth rate of \\( h(n) \\), up to a constant factor. Similarly, if \\( h(n) \\in O(g(n)) \\), it implies that the growth rate of \\( h(n) \\) is at most the growth rate of \\( g(n) \\), again up to a constant factor. By transitivity, if \\( f(n) \\) is bounded above"
        },
        {
          "id": 8,
          "text": "Pentru n - numar natural nenul si f(n) = 1 + 2 + ... + n atunci",
          "options": {
            "A": "f(n) ∈ O(n)",
            "B": "f(n) ∈ O(n²)",
            "C": "f(n) ∈ Θ(n²)"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "To solve this question, we need to analyze the function \\( f(n) = 1 + 2 + \\ldots + n \\), which represents the sum of the first \\( n \\) natural numbers. This sum can be expressed using the formula:\n\n\\[ f(n) = \\frac{n(n + 1)}{2} \\]\n\nThis simplifies approximately to:\n\n\\[ f(n) \\approx \\frac{n^2}{2} \\]\n\nNow, let's consider the big O and big Theta notations:\n\n- **Big O notation (O)** describes an upper bound of a function's growth rate. In this case, since \\( f(n) \\approx \\frac{n^2}{2} \\), it grows quadr"
        },
        {
          "id": 9,
          "text": "Care este ordinul de complexitate al algoritmului de cautare binara?",
          "image": "maa_9.png",
          "options": {
            "A": "Ω(logn)",
            "B": "O(logn)",
            "C": "O(n)"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "The binary search algorithm is designed to efficiently find an element in a sorted array by repeatedly dividing the search interval in half. This approach significantly reduces the number of comparisons needed. \n\nThe time complexity of binary search is O(log n) because with each step, the search space is halved, leading to a logarithmic number of steps relative to the size of the array. This means that in the worst-case scenario, the number of operations needed is proportional to the logarithm of the number of elements, n. \n\nThe notation Ω(log n) refers to the best-case scenario where the time complexity is also logarithmic. This is because even in the best case, where the element is found in the middle of the array on the first check,"
        },
        {
          "id": 10,
          "text": "Care este ordinul de complexitate al algoritmului de ridicare la putere al unui numar x^n?",
          "options": {
            "A": "Θ(n)",
            "B": "Θ(logn)",
            "C": "Θ(x^n)"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "The complexity of calculating \\(x^n\\) can vary depending on the algorithm used. If we use the naive approach, which involves multiplying \\(x\\) by itself \\(n\\) times, the time complexity is Θ(n). However, a more efficient approach is the \"exponentiation by squaring\" or \"binary exponentiation\" method, which reduces the number of multiplications needed. This method takes advantage of the binary representation of the exponent \\(n\\) and reduces the time complexity to Θ(log n). Therefore, both options A and B are correct, corresponding to the naive and optimized methods, respectively."
        },
        {
          "id": 11,
          "text": "Care este ordinul de complexitate al functiei f(n) cu relatia de recurenta t(n)=2t(sqrt(n)) + logn?",
          "options": {
            "A": "f(n) ∈ O(lognlog(logn))",
            "B": "f(n) ∈ O(logn)",
            "C": "f(n) ∈ O(n^1/2)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The recurrence relation given is \\( t(n) = 2t(\\sqrt{n}) + \\log n \\). To determine the order of complexity, we can use the Master Theorem or other techniques suitable for analyzing recurrence relations. However, the Master Theorem is not directly applicable here due to the unusual form of \\( \\sqrt{n} \\).\n\nInstead, we can transform the recurrence to make it easier to analyze. Let \\( m = \\log n \\). Then, \\( n = 2^m \\) and \\( \\sqrt{n} = 2^{m/2} \\). Substituting these into the recurrence gives:\n\n\\[ t(2^m) = 2t(2^{m/2})"
        },
        {
          "id": 12,
          "text": "Care este ordinul de crestere al unui algoritm avand timpul de executie de forma urmatoare:",
          "image": "maa_12.png",
          "options": {
            "A": "f(n) ∈ O(n²)",
            "B": "f(n) ∈ Θ(n²)",
            "C": "f(n) ∈ O(n)"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "In analiza algoritmilor, ordinul de creștere al unui algoritm este determinat de modul în care timpul său de execuție crește în funcție de dimensiunea intrării. În acest caz, timpul de execuție al algoritmului este dat de o formă care sugerează că depinde în principal de n², unde n este dimensiunea intrării.\n\n- Opțiunea A: f(n) ∈ O(n²) înseamnă că timpul de execuție crește cel mult proporțional cu n², ceea ce este adevărat pentru funcția dată, deoarece O(n²) oferă o limită superioară.\n\n- Opțiunea B:"
        },
        {
          "id": 13,
          "text": "Care este ordinul de crestere al unui algoritm avand timpul de executie de forma urmatoare:",
          "image": "maa_13.png",
          "options": {
            "A": "f(n) ∈ O(log2n)",
            "B": "f(n) ∈ O(logn)",
            "C": "f(n) ∈ O(lgn)"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "The question asks about the growth order, or time complexity, of an algorithm with a specific execution time expression. The notation \\(O(\\cdot)\\) is used in computer science to describe the upper bound of an algorithm's running time or space requirements in terms of input size \\(n\\).\n\nHere, the execution time is expressed in terms of logarithms, and the options show different ways of representing logarithmic complexity:\n\n- \\(O(\\log_2 n)\\) (option A) specifies base 2 logarithms.\n- \\(O(\\log n)\\) (option B) uses a general logarithm notation that typically implies base 10 or the natural logarithm; however, in Big O notation, base differences are constant factors and don't affect"
        },
        {
          "id": 14,
          "text": "Care este ordinul de crestere al algoritmului pentru problema Turnurilor din Hanoi avand timpul \nde executie de forma",
          "image": "maa_14.png",
          "options": {
            "A": "f(n) ∈ O(n)",
            "B": "f(n) ∈ O(2^n)",
            "C": "f(n) ∈ O(logn)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The Tower of Hanoi problem is a classic example of a recursive algorithm, where the goal is to move a stack of disks from one peg to another, using a third peg as an auxiliary, following certain rules. The recursive solution involves moving \\( n-1 \\) disks to the auxiliary peg, then moving the largest disk directly to the target peg, and finally moving the \\( n-1 \\) disks from the auxiliary peg to the target peg.\n\nThe time complexity of this algorithm can be described by the recurrence relation: \n\n\\[ T(n) = 2T(n-1) + 1 \\]\n\nThis recurrence solves to \\( T(n) = 2^n - 1 \\), which is exponential growth. Therefore, the order of"
        },
        {
          "id": 15,
          "text": "Care este ordinul de crestere al unui algoritm avand timpul de executie de forma urmatoare:",
          "image": "maa_15.png",
          "options": {
            "A": "f(n) ∈ O(n)",
            "B": "f(n) ∈ O(2^logn)",
            "C": "f(n) ∈ O(logn)"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "The question asks about the growth order of an algorithm whose execution time is represented in a specific form. \n\n- Option A, \\( f(n) \\in O(n) \\), indicates that the time complexity grows linearly with the input size \\( n \\). This is a common complexity for algorithms that iterate through all elements of the input once.\n\n- Option B, \\( f(n) \\in O(2^{\\log n}) \\), simplifies to \\( O(n) \\) because \\( 2^{\\log n} = n \\). Therefore, it also represents linear growth.\n\n- Option C, \\( f(n) \\in O(\\log n) \\), represents logarithmic growth, which is not equivalent to the given form, hence"
        },
        {
          "id": 16,
          "text": "Care este ordinul de complexitate al algoritmului mergesort avand relatia de \nrecurenta t(n) = 2t(n/2) + Θ(n)?",
          "options": {
            "A": "f(n) ∈ Θ(nlogn)",
            "B": "f(n) ∈ Θ(n)",
            "C": "f(n) ∈ Θ(n+nlogn)"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "The recurrence relation for the mergesort algorithm is given by \\( T(n) = 2T(n/2) + \\Theta(n) \\). This relation can be understood as follows:\n\n- The problem of size \\( n \\) is divided into two subproblems of size \\( n/2 \\), which suggests the \\( 2T(n/2) \\) term.\n- The \\( \\Theta(n) \\) term accounts for the time complexity of merging the two sorted halves back together.\n\nTo determine the overall complexity, we can use the Master Theorem, which is applicable to recurrence relations of the form \\( T(n) = aT(n/b) + f(n) \\), where:\n\n- \\( a \\) is the number"
        },
        {
          "id": 17,
          "text": "Sa se indice ordinul de crestere al functiei f(n) cu urmatoarea relatie de recurenta:",
          "image": "maa_17.png",
          "options": {
            "A": "f(n) ∈ O(n²)",
            "B": "f(n) ∈ Θ(n)",
            "C": "f(n) ∈ O(logn)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To determine the order of growth for the function \\( f(n) \\) given a recurrence relation, we typically analyze the recurrence to identify its asymptotic behavior. If the correct answer is \\( B. f(n) \\in \\Theta(n) \\), this implies that the recurrence relation describes a function that grows linearly with \\( n \\). The notation \\( \\Theta(n) \\) means that \\( f(n) \\) is bounded both above and below by linear functions of \\( n \\). This suggests that the recurrence relation simplifies to a form where the dominant term is proportional to \\( n \\), indicating a linear order of growth. Understanding the structure of the recurrence relation, such as its base case and recursive step, is essential in confirming"
        },
        {
          "id": 18,
          "text": "Sa se indice ordinul de crestere al functiei f(n) cu urmatoarea relatie de recurenta:",
          "image": "maa_18",
          "options": {
            "A": "f(n) ∈ O(n!)",
            "B": "f(n) ∈ O(n²)",
            "C": "f(n) ∈ O(n)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To determine the order of growth for the function \\( f(n) \\) given a recurrence relation, we need to analyze how the function behaves as \\( n \\) increases. If the recurrence relation suggests that \\( f(n) \\) is built by multiplying or combining terms in a way that resembles factorial growth, then the function will grow very quickly, similar to \\( n! \\). \n\nThe factorial function \\( n! \\) grows faster than polynomial functions like \\( n^2 \\) or linear functions like \\( n \\). Therefore, if the recurrence relation involves multiplying by terms that increase rapidly with \\( n \\), it aligns with the growth pattern of \\( O(n!) \\), making it the correct answer.\n\nIn this case, the recurrence likely"
        },
        {
          "id": 19,
          "text": "Sa se indice ordinul de crestere al functiei f(n) cu urmatoarea relatie de recurenta:",
          "image": "maa_19",
          "options": {
            "A": "f(n) ∈ Θ(n)",
            "B": "f(n) ∈ Θ(n+nlogn)",
            "C": "f(n) ∈ Θ(nlogn)"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "To determine the order of growth of the function \\( f(n) \\) from a recurrence relation, you typically use methods such as the Master Theorem or the iterative substitution method, depending on the form of the recurrence. The goal is to express the time complexity in Big Theta notation, which describes an asymptotically tight bound.\n\nFor this question, if the correct answers are \\( B \\) and \\( C \\), it implies that the recurrence relation leads to a function that grows proportionally to both \\( n + n\\log{n} \\) and \\( n\\log{n} \\). This typically suggests that the function's order of growth is dominated by the term \\( n\\log{n} \\), but the form \\("
        },
        {
          "id": 20,
          "text": "Care din urmatoarele interpretari fac adevarata formula F ilustrata in graficul din Figura 5?",
          "image": "maa_20",
          "options": {
            "A": "x1 = true, x2 = true, x3 = true",
            "B": "x1 = false, x2 = true, x3 = false",
            "C": "x1 = true, x2 = false, x3 = true"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To determine which interpretation makes the formula \\( F \\) true, we need to analyze the truth assignments for the variables \\( x1 \\), \\( x2 \\), and \\( x3 \\) as given in the options. The correct answer is option B: \\( x1 = \\text{false} \\), \\( x2 = \\text{true} \\), \\( x3 = \\text{false} \\). This specific combination satisfies the formula \\( F \\) as shown in the graph in Figure 5. Typically, this means that based on the logical operations depicted (such as AND, OR, NOT), only when \\( x1 \\) is false, \\( x2 \\) is true, and \\( x3 \\) is"
        }
      ]
    },
    {
      "name": "Arhitectura calculatoarelor",
      "questions": [
        {
          "id": 1,
          "text": "Exprimati in binar, octal, hexazecimal numarul zecimal 3.625",
          "options": {
            "A": "11.2000; 3.42; 4.20;",
            "B": "11.101; 3.5; 3.A;",
            "C": "2.1001; 3.52; 2D;",
            "D": "11.10000; 3.20; 3.2A;",
            "E": "11.10000; 2.42; 3.2;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To express the decimal number 3.625 in binary, octal, and hexadecimal, we convert each part separately:\n\n1. **Binary Conversion**: \n   - The integer part \\(3\\) in binary is \\(11\\).\n   - The fractional part \\(0.625\\) is converted by multiplying by 2:\n     - \\(0.625 \\times 2 = 1.25\\) (take the integer part \\(1\\))\n     - \\(0.25 \\times 2 = 0.5\\) (take the integer part \\(0\\))\n     - \\(0.5 \\times 2 = 1.0\\) (take the integer part \\(1\\))\n   - Combine these results"
        },
        {
          "id": 2,
          "text": "Convertiti in zecimal numerele urmatoare (baza este indicata in indice): DA.C₁₆, 27:4₈, 11011.101₂",
          "options": {
            "A": "216.5; 17.5; 27.52;",
            "B": "218.75; 23.5; 27.625;",
            "C": "218.75; 22.5; 26.5;",
            "D": "218.5; 23.5; 27.6;",
            "E": "218.75; 23.55; 27.625;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To convert numbers from different bases to decimal:\n\n1. **DA.C₁₆ (Hexadecimal to Decimal):**\n   - D in hexadecimal is 13 in decimal.\n   - A in hexadecimal is 10 in decimal.\n   - The number DA.C₁₆ is calculated as: \n     \\((13 \\times 16^1) + (10 \\times 16^0) + (12 \\times 16^{-1}) = 208 + 10 + 0.75 = 218.75\\).\n\n2. **27:4₈ (Octal to Decimal):**\n   - 2 in octal is 2 in decimal.\n   - 7 in octal is 7 in"
        },
        {
          "id": 3,
          "text": "Dati valoarea zecimala cu semn a numarului B7₁₆ codificat in complement fata de 1 (cod invers)",
          "options": {
            "A": "+7.2",
            "B": "71;",
            "C": "72;",
            "D": "-71;",
            "E": "-72;"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "To decode the hexadecimal number B7₁₆ using one's complement (cod invers), we first need to convert it to binary. The hexadecimal digit 'B' is '1011' in binary, and '7' is '0111'. So, B7₁₆ becomes 10110111 in binary.\n\nIn one's complement notation, the leftmost bit is the sign bit, where '1' indicates a negative number. Since the first bit of 10110111 is '1', the number is negative.\n\nTo find the magnitude, we take the one's complement of the number: invert all bits of 10110111 to get 01001000. This binary number is equal to 72 in decimal.\n\nTherefore, the"
        },
        {
          "id": 4,
          "text": "Dati pe 8 biti (in hexazecimal) reprezentarea in complement fata de 2 (cod complementar) a valorii  \nintregi negative -32.",
          "options": {
            "A": "E3",
            "B": "E0;",
            "C": "E1;",
            "D": "E2;",
            "E": "DF;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To find the 8-bit two's complement representation of the negative integer -32, follow these steps:\n\n1. **Find the binary representation of the positive integer 32**:  \n   The binary representation of 32 is `00100000`.\n\n2. **Invert the digits (find the one's complement)**:  \n   Invert each bit of `00100000` to get `11011111`.\n\n3. **Add 1 to the one's complement to find the two's complement**:  \n   Add 1 to `11011111`:\n\n   ```\n   11011111\n+        1\n   --------\n   11100000\n   ```\n\n4. **Convert the binary result to hexadecimal**:"
        },
        {
          "id": 5,
          "text": "Dati sub forma a x 2ᵇ (a si b in sistemul zecimal) valoarea care corespunde reprezentarii in VMSP \n(virgula mobila simpla precizie, adica: 1 bit = semnul mantisei, 8 biti = exponentul decalat, \n23 biti = mantisa normalizata), 27660000000₈",
          "options": {
            "A": "0.8 x 2⁴;",
            "B": "-0.5 x 2⁻³;",
            "C": "-8.8 x 2⁴;",
            "D": "-8.8125 x 2⁻⁴;",
            "E": "-100;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To determine the value represented by the octal number 27660000000₈ in single precision floating point format (VMSP), we need to follow these steps:\n\n1. **Convert the octal number to binary:**\n   The octal number 27660000000₈ converts to binary as 010 111 110 110 000 000 000 000 000 000₂. Remove leading zeros to get 1011111011000000000000000000₂.\n\n2. **Identify the components of the floating point representation:**\n   - **Sign bit (1 bit):** The first bit is 1, indicating a negative number.\n   - **Exponent (8 bits):** The next"
        },
        {
          "id": 6,
          "text": "Dati reprezentarea interna, exprimata in hexazecimal), in VMSP (virgula mobila simpla precizie, \nadica: 1 bit = semnul mantisei,8 biti = exponentul decalat,\n23 biti = mantisa normalizata) pentru \nvaloarea zecimala -6.25.",
          "options": {
            "A": "44C58000;",
            "B": "C1E40000;",
            "C": "C4B59000;",
            "D": "C4C58000;",
            "E": "CDFAA000;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To find the internal representation of the decimal value -6.25 in single-precision floating-point format (VMSP), we need to follow these steps:\n\n1. **Sign Bit**: Since the number is negative, the sign bit is 1.\n\n2. **Convert to Binary**: The absolute value of -6.25 is 6.25. In binary, 6 is represented as 110, and 0.25 is represented as 0.01. Therefore, 6.25 in binary is 110.01.\n\n3. **Normalize the Binary Number**: Normalize the binary representation to fit the form 1.xxxxx... × 2^n. For 110.01, we normalize it to"
        },
        {
          "id": 7,
          "text": "Fie o transmisie care utilizeaza codul lui Hamming cu paritate para. Gasiti mesajul transmis ( in octal) \nstiind ca reprezentarea datelor de transmis (pe 16 biti) este 7B₁₆",
          "options": {
            "A": "3724",
            "B": "3723;",
            "C": "3726;",
            "D": "3725;",
            "E": "3727;"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "To solve this problem, we need to understand how Hamming codes and parity work, and then apply this to the given hexadecimal data.\n\n1. **Hexadecimal to Binary Conversion**: \n   The given data to be transmitted is 7B₁₆. First, convert this hexadecimal number into a binary representation. \n\n   - 7₁₆ = 0111₂\n   - B₁₆ = 1011₂\n\n   So, 7B₁₆ in binary is 01111011₂.\n\n2. **Binary to Octal Conversion**:\n   The binary number 01111011₂ must be converted to octal. To do this, we group the binary digits into sets of"
        },
        {
          "id": 8,
          "text": "Fie o transmisie care utilizeaza codul lui Hamming cu paritate impara. Regasiti ( in octal) mesajul \ninitial (corectand eventualele erori daca mesajul primit (pe 21 biti) este 6130014 (in octal).",
          "options": {
            "A": "140441₈;",
            "B": "141441₈;",
            "C": "142442₈;",
            "D": "C522₁₆;",
            "E": "C321₁₆;"
          },
          "correct_answer": [
            "B",
            "E"
          ],
          "explanation": "To solve this problem, we need to understand how Hamming codes with odd parity work and how to decode the given octal message to identify and correct any errors.\n\n1. **Understanding Hamming Code and Parity**: Hamming codes are used for error detection and correction. In this case, the code uses odd parity, which means that the number of 1s in a group of bits must be odd.\n\n2. **Converting Octal to Binary**: The received message is given in octal (base 8), so first, we convert it to binary (base 2) for easier manipulation. Each octal digit corresponds to a 3-bit binary sequence. For example, the octal digit '6' is '"
        },
        {
          "id": 9,
          "text": "Fie o transmisie care utilizeaza metoda codurilor polinomiale (CRC) prin intermediul polinomului \ngenerator G(x) = x³ + x + 1. Daca se doreste transmiterea datelor (7 biti) cu reprezentarea octala \n131, care va fi mesajul trimis?",
          "options": {
            "A": "25DC₁₆",
            "B": "1313₈;",
            "C": "2CB₁₆;",
            "D": "22734₈;",
            "E": "22735₁₀;"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "To solve this problem, we need to understand how Cyclic Redundancy Check (CRC) works using a given generator polynomial. The generator polynomial provided is \\( G(x) = x^3 + x + 1 \\), which corresponds to the binary number 1011. \n\n1. **Convert the octal data to binary**: The data given is 131 in octal, which converts to binary as follows:\n   - 1 in octal is 001 in binary.\n   - 3 in octal is 011 in binary.\n   - 1 in octal again is 001 in binary.\n   - Therefore, 131 in octal is 001 011 001 in binary, which simplifies to 101"
        },
        {
          "id": 10,
          "text": "Fie o transmisie care utilizeaza metoda codurilor polinomiale (CRC) prin intermediul polinomului \ngenerator G(x) = x² + x + 1. Daca s-a receptionat mesajul T = 2332₈ (11 biti) sa se stabileasca \ndaca a fost trimis corect, iar daca raspunsul este afirmativ sa se afle mesajul M initial.",
          "options": {
            "A": "132₁₀;",
            "B": "464₈;",
            "C": "134₁₆;",
            "D": "136₁₆;",
            "E": "466₈;"
          },
          "correct_answer": [
            "D",
            "E"
          ],
          "explanation": "To determine if the message was transmitted correctly using the CRC method with the generator polynomial \\( G(x) = x^2 + x + 1 \\), we need to perform a CRC check on the received message.\n\n1. **Convert the Received Message to Binary**: The received message \\( T = 2332_8 \\) needs to be converted to binary. \\( 2332_8 \\) is represented in binary as \\( 010011011010_2 \\).\n\n2. **Perform CRC Check**: To check if the message was transmitted correctly, perform a binary division of the received binary message by the generator polynomial's binary equivalent. The generator polynomial \\( G(x) = x^2 + x + 1 \\) translates"
        },
        {
          "id": 11,
          "text": "Reduceti expresia formei normale disjunctive (cu mintermeni) a functiei logice \nf(a, b, c) = ābc + ab̄c + ab̄c̄ + abc̄ + abc",
          "options": {
            "A": "ā + bc",
            "B": "a + bc;",
            "C": "a + b̄c;",
            "D": "ā + b;",
            "E": "a + b̄."
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To reduce the given logical function \\( f(a, b, c) = \\overline{a}bc + ab̄c + ab̄c̄ + abc̄ + abc \\) to its simplest form, we can apply Boolean algebra rules. \n\n1. **Combine Terms by Consensus**:\n   - The terms \\( abc \\) and \\( abc̄ \\) can be combined to \\( ab \\) using the consensus theorem: \\( abc + abc̄ = ab \\).\n   - The terms \\( ab̄c \\) and \\( ab̄c̄ \\) can be combined to \\( ab̄ \\) using the consensus theorem: \\( ab̄c + ab̄c̄"
        },
        {
          "id": 12,
          "text": "Reduceti expresia formei normale disjunctive (cu mintermeni) a functiei logice de 4 variabile care \nia valoarea 1 daca pqrs vazut ca numar binar are o valoare mai mica deca 10.",
          "options": {
            "A": "p̄ + q̄r̄;",
            "B": "p̄qr + pq̄ + pq;",
            "C": "p + p̄q̄s;",
            "D": "pqr + r̄;",
            "E": "pq + qr + rs."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To solve this problem, we need to express the condition that the 4-variable binary number \\( pqrs \\) is less than 10 in disjunctive normal form (DNF) using minterms.\n\nIn binary, the numbers from 0 to 9 are represented as follows:\n- 0: 0000\n- 1: 0001\n- 2: 0010\n- 3: 0011\n- 4: 0100\n- 5: 0101\n- 6: 0110\n- 7: 0111\n- 8: 1000\n- 9: 1001\n\nFor the values less than 10, the leading bit"
        },
        {
          "id": 13,
          "text": "Se consider˘a urm˘atorul cont¸inut al registrelor ¸si al memoriei: (XR1) = 1; (1000) = 0; (3000) = 4;\n(B2) = 2000; (2000) = 2; (B1) = 1000; (1001) = 1; (3001) = 5; (2001) = 3; (0) = 1000.\nCare este valoarea lui F dup˘a execut¸ia programului urm˘ator: 1) LOAD 3000; 2) LOAD 2000,\nXR1; 3) SUB 2001,B1 4) MPY 1001,B2; 5) DIV 2000; 6) ADD 1000, IM; 7) SUB 0,I,XR1;\n8) STA F;",
          "options": {
            "A": "1001;",
            "B": "1002;",
            "C": "1003;",
            "D": "1004;",
            "E": "1005;"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "To determine the value of F after executing the given program, we need to follow each instruction step by step, considering the initial conditions provided:\n\n1. **LOAD 3000**: Load the value from memory address 3000 into the accumulator. (3000) = 4, so accumulator = 4.\n\n2. **LOAD 2000, XR1**: Load the value from memory address (2000 + XR1) into the accumulator. XR1 = 1, so address = 2000 + 1 = 2001. (2001) = 3, so accumulator = 3.\n\n3. **SUB 2001, B1**: Subtract the value at memory address (2001 +"
        },
        {
          "id": 14,
          "text": "Se considera o memorie centrala unde fiecare octet este adresat separat. Calculati in hexazecimal adresa \ncelui de-al 7-lea element al unui tablou cu adresa primului element 1000 si fiecare element 16 are 16 biti.",
          "options": {
            "A": "1008;",
            "B": "1009;",
            "C": "100A;",
            "D": "100B;",
            "E": "100C;"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "To solve this problem, we need to determine the address of the 7th element in an array where each element is 16 bits, and the address of the first element is given as 1000 in hexadecimal.\n\n1. **Understand the size of each element**: Each element is 16 bits, which is equivalent to 2 bytes (since 1 byte = 8 bits).\n\n2. **Calculate the address offset for the 7th element**: \n   - The 1st element is at address 1000.\n   - The 2nd element is 2 bytes after the 1st element, so it is at address 1000 + 2.\n   - The 3rd element is 2 bytes"
        },
        {
          "id": 15,
          "text": "Se considera o memorie intretesuta constituita din doua unitati de cate 4 Mo. \nStiind ca adresa de memorie se constituie pe 23 de biti astfel: 1 bit identifica superunitatea, 20 biti specifica adresa in \ncadrul unitatii, iar ultimii 2 biti octetul din cadrul cuvantului), sa se identifice ( in zecimal) linia  \nintr-o memorie cache de 1Ko precum si bitii de pondere mare ai adresei de memorie A = 10000.",
          "options": {
            "A": "600; 42;",
            "B": "600; 2;",
            "C": "452; 42;",
            "D": "600; 24;",
            "E": "452; 2;"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "To solve this problem, we need to analyze the structure of the memory and the cache system, using the given 23-bit address format:\n\n1. **Understanding the Address Structure:**\n   - The address is 23 bits long.\n   - The first bit (1 bit) identifies the superunit.\n   - The next 20 bits specify the address within the unit.\n   - The last 2 bits specify the byte within the word.\n\n2. **Calculating the Cache Line:**\n   - The cache is 1 Ko (which is 1024 bytes).\n   - Since each unit is 4 Mo, each unit has \\(4 \\times 1024 \\times 1024 = 4194304\\) bytes."
        },
        {
          "id": 16,
          "text": "Presupunem ca o adresa in memoria virtuala paginata, necesita 20 de biti organizati astfel: offset\n(cuvant): bitii de la 0 la 11; pagina: bit¸ii de la 12 la 19; Care este adresa octala a celui de-al 970-lea\ncuvant de la pagina 213 ?",
          "options": {
            "A": "3251718;",
            "B": "3251711;",
            "C": "3261711;",
            "D": "3261811;",
            "E": "3271711;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To determine the octal address of the 970th word on page 213 in a paginated virtual memory system, follow these steps:\n\n1. **Understand the Address Structure:**\n   - The virtual address is composed of two parts:\n     - **Page number**: bits 12 to 19\n     - **Offset**: bits 0 to 11\n\n2. **Convert Page and Offset to Binary:**\n   - The page number is 213 in decimal.\n   - Convert 213 to binary: \\(213_{10} = 11010101_2\\). This fits into 8 bits (bits 12-19).\n   - The offset for the 970th word is 970 in decimal.\n   -"
        },
        {
          "id": 17,
          "text": "Presupunem ca o adresa in memoria virtuala paginata, necesita 20 de biti organizati astfel: \noffset (cuvant): bitii de la 0 la 11; pagina: bitii de la 12 la 19; Care este numarul cuvantului si numarul \nde pagina pentru adresa hexazecimala ABCDE? Dati rezultatul in zecimal.",
          "options": {
            "A": "4000; 171;",
            "B": "3295; 170;",
            "C": "3294; 171;",
            "D": "4500; 200;",
            "E": "2951; 117;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To solve this problem, we need to break down the hexadecimal address ABCDE into its binary equivalent and then extract the relevant bits as defined by the problem.\n\n1. **Convert Hexadecimal to Binary:**\n   - The given address is ABCDE in hexadecimal.\n   - Converting each digit to binary: \n     - A = 1010\n     - B = 1011\n     - C = 1100\n     - D = 1101\n     - E = 1110\n   - So, ABCDE in binary is: 1010 1011 1100 1101 1110\n\n2. **Extract the Relevant Bits:**\n   - According to the problem, the address is divided into:"
        },
        {
          "id": 18,
          "text": "Presupunem ca o adresa in memoria virtuala segmentatasi paginata, necesita 24 de biti organizati \nastfel: offset (cuvant): bitii de la 0 la 7; pagina: bitii de la 8 la 17; segment: bitii de la 18 la 23; \nCare este adresa octala a celui de-al 145-lea cuvant de la pagina 111 a segmentului al 32-lea?",
          "options": {
            "A": "37067620;",
            "B": "32517180;",
            "C": "32517160;",
            "D": "37007620;",
            "E": "37062620;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To determine the octal address for the specified word, page, and segment, we need to understand how the virtual address is structured and then convert it to an octal representation. The address is organized into three parts, each with a specific bit allocation:\n\n1. **Offset (cuvânt):** Bits 0 to 7. This is an 8-bit field.\n2. **Pagina (Page):** Bits 8 to 17. This is a 10-bit field.\n3. **Segment:** Bits 18 to 23. This is a 6-bit field.\n\nGiven:\n- The 145th word corresponds to an offset value of 144 (since offset starts from 0).\n- The 111th page is"
        },
        {
          "id": 19,
          "text": "Presupunem ca o adresa in memoria virtuala segmentatasi paginata, necesita 24 de biti organizati \nastfel: offset (cuvant): bitii de la 0 la 7; pagina: bitii de la 8 la 17; segment: bitii de la 18 la 23; \nCare este numarul cuvantuluisi numarul de pagina pentru adresa hexazecimala ABCDE? Dati rezultatul in zecimal.",
          "options": {
            "A": "144; 111; 31;",
            "B": "150; 120; 131;",
            "C": "119; 053; 33;",
            "D": "150; 111; 131;",
            "E": "155; 120; 131;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To solve the problem, we need to break down the hexadecimal address ABCDE into its binary form and then separate the segments according to the bit positions specified for offset, page, and segment.\n\n1. **Convert ABCDE to Binary**: The hexadecimal number ABCDE converts to binary as follows:\n   - A = 1010\n   - B = 1011\n   - C = 1100\n   - D = 1101\n   - E = 1110\n   Therefore, ABCDE in binary is: 1010 1011 1100 1101 1110.\n\n2. **Organize into 24-bit Virtual Address**: Since the problem specifies a 24-bit address, consider only the"
        },
        {
          "id": 20,
          "text": "Care este efectul urmatoarei secvente de instructiuni care se executa pe o masina cu programare \npe zero adrese: 1) LOAD B; 2) LOAD C; 3) LOAD D 4) LOAD E; 5) DIV ; 6) ADD ;\n7) LOAD F; 8) LOAD G; 9) MPY ; 10) ADD ; 11) MPY ; STA R;",
          "options": {
            "A": "R = B × (C + D/E + F × G);",
            "B": "R = B/(C + D/E + F × G);",
            "C": "R = B × (C + D/E − F × G);",
            "D": "R = B × (C + D/E + F/G);",
            "E": "R = B × (C + D × E + F × G);"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The sequence of instructions operates in a stack-based environment typical of zero-address machines, meaning it relies on an implicit stack to manage operands for operations like multiplication, division, and addition. Here's the step-by-step breakdown of the instructions:\n\n1. `LOAD B`: Pushes B onto the stack.\n2. `LOAD C`: Pushes C onto the stack.\n3. `LOAD D`: Pushes D onto the stack.\n4. `LOAD E`: Pushes E onto the stack.\n5. `DIV`: Pops the top two values (D and E), divides D by E, and pushes the result back on the stack.\n6. `ADD`: Pops the top two values (C and result of D/E), adds them, and pushes"
        }
      ]
    },
    {
      "name": "Sisteme de operare si Proiectarea sistemelor de operare",
      "questions": [
        {
          "id": 1,
          "text": "Apelul sistem SLEEP produce:",
          "options": {
            "A": "trecerea producatorului in starea BLOCAT daca buffer-ul este gol",
            "B": "blocarea procesului pana cand un altul il trezeste prin WAKEUP",
            "C": "blocarea procesului pana cand un altul lanseaza apelul SLEEP",
            "D": "trecerea procesului precizat de parametrul apelului in starea GATA"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The correct answer is B. In operating systems, the `SLEEP` system call is used to block or suspend the execution of a process until a specific condition is met or an external event occurs. In this context, option B is the correct explanation because it describes the behavior where a process is blocked or put to sleep until another process wakes it up using the `WAKEUP` call. This mechanism is commonly used in process synchronization to prevent a process from consuming CPU resources while waiting for a specific condition or resource to become available."
        },
        {
          "id": 2,
          "text": "Planificarea preemptiva este strategia de planificare conform careia:",
          "options": {
            "A": "un proces nu poate fi suspendat temporar daca este in starea GATA",
            "B": "un proces care din punct de vedere logic poate fi executat este temporar suspendat",
            "C": "unprocesodatalansat inexecutienumaiestesuspendatatuncicandpoatefi inexecutie",
            "D": "un proces nu poate fi suspendat temporar daca este in starea BLOCAT"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Preemptive scheduling is a strategy in which the operating system can temporarily suspend a currently running process to allocate the CPU to another process. This approach allows for more efficient utilization of CPU resources by ensuring that higher-priority processes or those that are ready to execute can take precedence over others. In the context of the given choices, option B correctly describes this behavior as it highlights the ability to temporarily suspend a process that could logically be executed, in favor of another process. This ensures that the system remains responsive and can adapt to changing demands or priorities."
        },
        {
          "id": 3,
          "text": "Planificarea Round-Robin:",
          "options": {
            "A": "determina atribuirea unei cunate de timp in care procesului ii este permis sa ruleze",
            "B": "determina suspendarea unui proces intr-un moment arbitrar",
            "C": "determina atribuirea unei prioritati fixe pentru executia unui proces",
            "D": "determina lansarea in executie a unui proces daca nu exista altul mai prioritar in executie"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Planificarea Round-Robin este o tehnică de management al proceselor în sistemele de operare care implică alocarea fiecărui proces activ unui interval de timp fix, numit cota de timp sau \"time slice\". Aceasta permite fiecărui proces să ruleze pentru această perioadă determinată înainte de a trece la următorul proces în coadă, asigurându-se astfel o distribuție echitabilă a resurselor procesorului între toate procesele. De aceea, răspunsul corect este A, deoarece descrie exact acest mecanism de alocare a timpului pentru execuția proceselor."
        },
        {
          "id": 4,
          "text": "Care din urmatoarele functiuni sunt indeplinite de sistemul calculator hardware generator de baza:",
          "options": {
            "A": "functia de conservare a informatiei",
            "B": "functia de generare a informatiei",
            "C": "functia de prelucrare a informatiei",
            "D": "functia de receptionare a informatiei"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "Un sistem calculator hardware generator de bază îndeplinește mai multe funcțiuni esențiale legate de gestionarea informației. \n\n- **Funcția de conservare a informației (A):** Aceasta implică stocarea datelor în memoria sistemului pentru utilizare ulterioară. Hardware-ul, cum ar fi hard disk-urile sau SSD-urile, este responsabil pentru păstrarea informațiilor pe termen lung sau scurt.\n\n- **Funcția de prelucrare a informației (C):** Aceasta se referă la capacitatea sistemului de a procesa datele introduse, transformându-le în informații utile. Unitatea centrală de procesare (CPU) este component"
        },
        {
          "id": 5,
          "text": "Subunitatile de intrerupere sunt:",
          "options": {
            "A": "un mijloc de intrerupere al sistemului calculator",
            "B": "un mecanism de transmitere a informatillor intre dispozitivele de intrare-iesire",
            "C": "un mijloc de terminare a unei operatii de intrare-iesire",
            "D": "un mijloc de comunicatie  intre sistemul calculator hardware si sistemul de operare"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Subunitățile de întrerupere sunt componente esențiale ale arhitecturii sistemelor de calcul, care facilitează comunicarea între hardware-ul calculatorului și sistemul de operare. Atunci când un dispozitiv hardware necesită atenția procesorului, acesta generează un semnal de întrerupere care este gestionat de subunitățile de întrerupere. Acest mecanism permite sistemului de operare să răspundă rapid la evenimentele hardware, asigurând un management eficient al resurselor și al timpului de procesare. Astfel, răspunsul corect este D, deoarece subunitățile de întrerupere sunt un mijloc"
        },
        {
          "id": 6,
          "text": "La declansarea unei intreruperi prima actiune desfasurata in sistemul calculator este:",
          "options": {
            "A": "salvarea registrelor procesului intrerupt in tabela de procese",
            "B": " incarcarcarea registrului program counter cu continutul vectorului de intrerupere",
            "C": "salvarea starii programului intrerupt in stiva",
            "D": "modificarea starii procesului intrerupt"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "When an interrupt occurs in a computer system, the immediate priority is to preserve the state of the currently executing program so that it can be resumed correctly once the interrupt has been handled. This involves saving the current state, which includes the contents of the processor's registers, onto the stack. By doing so, the system ensures that no data is lost and that the interrupted program can continue from where it left off. Option C, \"salvarea starii programului intrerupt in stiva\" (saving the state of the interrupted program on the stack), accurately describes this initial step in handling an interrupt, making it the correct choice."
        },
        {
          "id": 7,
          "text": "Mecanismul de adresare al memoriei este:",
          "options": {
            "A": "mecanismul prin care se incarca programele in memorie",
            "B": "mecanismul prin care se traduce memoria virtuala in memorie reala",
            "C": "mecanismul prin care se construiesc adresele de memorie",
            "D": "mecanismul prin care se depun datele in memoria operativa"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The correct answer is B because the mechanism of memory addressing involves translating virtual memory addresses into real (physical) memory addresses. This process is crucial in modern computing as it allows programs to use a large and flexible address space, which may exceed the actual physical memory available. The operating system, along with the memory management unit (MMU), handles this translation to ensure that the virtual addresses used by applications are correctly mapped to physical locations in RAM, enabling efficient use of memory resources."
        },
        {
          "id": 8,
          "text": "Apelurile sistem DOWN si UP actioneaza asupra unei variabile de tip:",
          "options": {
            "A": "contor",
            "B": "semafor",
            "C": "contor de evenimente",
            "D": "conditie"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In computer science, the terms \"DOWN\" and \"UP\" are often associated with semaphore operations. A semaphore is a synchronization primitive used to control access to a common resource in concurrent programming. The \"DOWN\" operation, also known as \"P\" (proberen, Dutch for \"to test\"), decreases the semaphore's value and may block if the value is not positive, indicating that the resource is unavailable. Conversely, the \"UP\" operation, or \"V\" (verhogen, Dutch for \"to increment\"), increases the semaphore's value, signaling that the resource has become available. Thus, the correct answer is B, as these operations specifically pertain to semaphores."
        },
        {
          "id": 9,
          "text": "Un proces este:",
          "options": {
            "A": "activitatea unitatii de prelucrare",
            "B": "un program compilat",
            "C": "un program in executie",
            "D": "un program link-editat"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "A process is best described as \"a program in execution,\" which is why the correct answer is C. When a program is loaded into memory and begins execution, it becomes a process. It includes the program code and its current activity, represented by the program counter, registers, and variables. Unlike the other options, a process is not simply a compiled or link-edited program (options B and D), nor is it merely the activity of a processing unit (option A). Instead, it is the dynamic execution context of a program, actively utilizing system resources to perform tasks."
        },
        {
          "id": 10,
          "text": "Registrul “contor program” contine:",
          "options": {
            "A": "adresele opereanzilor operatiei ce trebuie executata",
            "B": "adresa urmatoarei instructiuni ce trebuie executata",
            "C": "chiar operanzii operatiei ce trebuie executata",
            "D": "numarul instructiunii ce trebuie executata"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The \"contor program\" or program counter is a register in a computer's CPU that holds the address of the next instruction to be executed in a program sequence. This allows the CPU to keep track of where it is in the program and to know which instruction to fetch and execute next. Therefore, the correct answer is B: it contains the address of the next instruction to be executed."
        },
        {
          "id": 11,
          "text": "Sectiunile critice sunt:",
          "options": {
            "A": "secvente de program care trebuie tratate cu mare atentie",
            "B": "secvente de tratare a intreruperilor importante",
            "C": "secvente din activitatea sistemului calculator cand resursele sunt insuficiente",
            "D": "secvente de program unde se acceseaza date partajate"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "A critical section is a segment of code in a program where shared resources, such as variables or data structures, are accessed and potentially modified. The correct answer, D, identifies these sections as places where shared data is accessed. Proper management of critical sections is crucial to prevent data corruption and ensure synchronization, especially in concurrent programming where multiple threads or processes might attempt to read or write to the same resource simultaneously. Options A, B, and C do not specifically address the aspect of accessing shared data, which defines a critical section."
        },
        {
          "id": 12,
          "text": "Planificatorul este componenta sistemului de operare care decide:",
          "options": {
            "A": "care proces trece in starea de executie si pentru cat timp",
            "B": "care proces trebuie terminat si care proces trebuie inceput",
            "C": "care dispozitiv periferic va fi folosit de catre program",
            "D": "care dintre fisierele deschise trebuie inchis la un moment dat"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. The planner, or scheduler, is a crucial component of the operating system responsible for managing process execution. It determines which process will move into the execution state and for how long it will run, effectively managing CPU time allocation. This ensures efficient use of processor resources and helps maintain system performance and responsiveness. Options B, C, and D relate to process termination, device management, and file handling, respectively, which are managed by other parts of the operating system."
        },
        {
          "id": 13,
          "text": "Criteriile generale urmarite de algoritmii de planificare sunt:",
          "options": {
            "A": "corectitudinea (echitabilitatea)",
            "B": "respectarea politicii SO",
            "C": "eficienta",
            "D": "mentenabilitatea"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "The general criteria followed by scheduling algorithms focus on ensuring optimal system performance and user satisfaction. \n\nA. Corectitudinea (echitabilitatea): This criterion ensures that all processes are treated fairly and given appropriate CPU time, preventing any one process from monopolizing resources, which is crucial for maintaining balanced system operation.\n\nB. Respectarea politicii SO: Scheduling algorithms must adhere to the operating system's policies and rules to ensure that system objectives, such as priority handling and resource allocation, are met.\n\nC. Eficienta: Efficiency is key for maximizing system performance by minimizing process turnaround time, response time, and maximizing CPU utilization, ensuring that resources are used effectively.\n\nD. Mentenabilitatea: While maintainability is important for software development,"
        },
        {
          "id": 14,
          "text": "Un sistem de operare asigura indeplinirea urmatoarelor functii: ",
          "options": {
            "A": "cresterea performantelor unitatii de prelucrare",
            "B": "un management eficient al resurselor fizice si logice",
            "C": "asistarea utilizatorului printr-un sistem dezvoltat de comunicatie",
            "D": "protectia informatiei"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "A system de operare, or operating system (OS), is responsible for managing hardware and software resources on a computer. It ensures efficient resource management (B), including memory, processing power, and storage, to optimize performance and resource allocation. Additionally, an OS provides user assistance through a developed communication system (C), such as user interfaces and command-line tools, to facilitate interaction with the computer. It also implements security measures to protect information (D) from unauthorized access and threats. While an OS can enhance performance indirectly through efficient resource management, its primary functions do not include directly increasing the performance of the processing unit (A)."
        },
        {
          "id": 15,
          "text": "Care din urmatoarele resurse fizice este “preemptibila”:",
          "options": {
            "A": "banda magnetica",
            "B": "memoria",
            "C": "scanerul",
            "D": "imprimanta"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In contextul sistemelor de operare și al gestionării resurselor, o resursă preemptibilă este o resursă care poate fi întreruptă sau reatribuită de la un proces la altul fără a cauza probleme majore sau pierderi de date. Memoria (B) este considerată o resursă preemptibilă deoarece sistemul de operare poate gestiona dinamic alocarea și eliberarea memoriei între procese, permițându-i să fie reatribuită rapid și eficient. În schimb, resursele precum banda magnetică, scanerul și imprimanta sunt, de obicei, non-preemptibile, deoarece într"
        },
        {
          "id": 16,
          "text": "Exceptiile program sunt:",
          "options": {
            "A": "evenimente care se produc la nivelul dispozitivelor fizice tratate prin intermediul unor\nsecvente de program",
            "B": "\nintreruperi ale masinii abstracte reprezentate prin programul care se executa\npe un sistem calculator real",
            "C": "mijloace de auto intrerupere a unui program pentru a solicita executarea unor \nfunctii de catre sistemul de operare",
            "D": "evenimente datorate executiei unei anume instructiuni din programul care ruleaza"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "Exceptions in programming refer to events that disrupt the normal flow of execution in a program. They can occur due to various reasons, such as errors or specific conditions that require special handling. \n\n- Option B is correct because exceptions are essentially interruptions in the abstract machine represented by the executing program on a real computer system. They act as signals that something unexpected has occurred, requiring the program to handle the situation.\n\n- Option C is correct because exceptions serve as a mechanism for self-interruption in a program. When an exception occurs, it typically triggers the operating system or runtime to execute specific functions or exception handlers to address the issue.\n\n- Option D is correct because exceptions are often the result of executing a specific instruction in the running program. For example, attempting to"
        },
        {
          "id": 17,
          "text": "Care dintre urmatoarele operatii se pot efectua asupra variabilelor contor?",
          "options": {
            "A": "ADVANCE",
            "B": "AWAIT",
            "C": "READ",
            "D": "AWAKE"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "In the context of programming, especially when dealing with variables used as counters, certain operations are typically permitted. \n\n- **ADVANCE**: This operation is often used to increment the value of a counter. It is a common action to move the counter to its next state, hence it's valid.\n- **AWAIT**: This operation implies waiting for a certain condition to be met before proceeding. While not directly modifying the counter, it can be associated with the control flow involving counters, thus it can be applied in scenarios where you wait for the counter to reach a specific value.\n- **READ**: This is the action of accessing the current value of the counter without modifying it. It's a fundamental operation that can be performed on any variable, including"
        },
        {
          "id": 18,
          "text": "Principalele functiuni ale sistemelor de operare sunt:",
          "options": {
            "A": "managementul fisierelor",
            "B": "managementul serverelor",
            "C": "managementul memoriei",
            "D": "managementul dispozitivelor periferice",
            "E": "managementul proceselor"
          },
          "correct_answer": [
            "A",
            "C",
            "D",
            "E"
          ],
          "explanation": "Sistemele de operare sunt esențiale pentru gestionarea resurselor hardware și software ale unui computer. Funcțiile principale ale acestora includ:\n\nA. **Managementul fișierelor**: Organizarea, stocarea, accesarea și protejarea datelor pe unități de stocare.\n\nC. **Managementul memoriei**: Alocarea și eliberarea memoriei RAM pentru procese, asigurând eficiența și evitarea conflictelor între aplicații.\n\nD. **Managementul dispozitivelor periferice**: Controlul și coordonarea interacțiunilor între computer și dispozitivele externe, cum ar fi imprimantele, tastaturile și"
        },
        {
          "id": 19,
          "text": "Prin constructia sistemului calculator fiecarui nivel de intrerupere i se asociaza:",
          "options": {
            "A": "un registru de adresare",
            "B": "o instructiune de calcul",
            "C": "o adresa de memorie specifica",
            "D": "un registru general"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In computer system design, each interrupt level is associated with a specific memory address (option C) because when an interrupt occurs, the system needs to know where to find the corresponding interrupt service routine (ISR). This routine handles the interrupt, and its address is stored in a predefined location in memory. This allows the processor to quickly locate and execute the ISR, ensuring efficient interrupt handling. Options A, B, and D do not provide the mechanism needed to directly link an interrupt with its handling routine in memory."
        },
        {
          "id": 20,
          "text": "Tranzitia unui proces din starea “ in execu?ie” in starea “blocat” are loc atunci cand:",
          "options": {
            "A": "planificatorul decide suspendarea procesului pentru a lansa un altul mai prioritar",
            "B": "planificatorul decide blocarea procesului din cauza unei erori",
            "C": "procesul asteapta aparitia unor date de care depinde continuarea executiei",
            "D": "procesul nu mai poate continua executia din cauza unei erori"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In the context of operating systems and process management, a process transitions from the \"running\" state to the \"blocked\" state when it cannot continue executing because it is waiting for certain conditions to be met or for specific resources to become available. Option C accurately describes this scenario: the process is waiting for the availability of data necessary for its execution to proceed. This is a typical situation where a process is blocked, as it must pause until the required data or event occurs, such as input/output operations or synchronization with other processes."
        },
        {
          "id": 21,
          "text": "Subsistemul memorie satisface urmatoarele proprietati:",
          "options": {
            "A": "permite accesul direct la fisiere",
            "B": "permite extensia modulara",
            "C": "permite alocarea dinamica",
            "D": "permite lucrul in paralel"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "In the context of computer systems, the memory subsystem is designed to manage and organize memory resources effectively. It typically satisfies the following properties:\n\nB. Permite extensia modulara: The memory subsystem can be expanded or modified in a modular fashion, allowing for easy upgrades or changes to the memory capacity without affecting the entire system.\n\nC. Permite alocarea dinamica: Dynamic allocation is a key feature of memory management, allowing the system to allocate and deallocate memory as needed, optimizing the use of available resources.\n\nD. Permite lucrul in paralel: Modern memory subsystems support parallel processing, enabling multiple processes or threads to access memory simultaneously, which improves performance and efficiency.\n\nOption A, which refers to direct access to files, is"
        },
        {
          "id": 22,
          "text": "Planificarea pe doua nivele se utilizeaza atunci cand:",
          "options": {
            "A": "procesele din sistemul calculator nu ocupa intreaga memorie operativa existenta",
            "B": " in memoria operativa nu se poate pastra la un moment dat decat un singur proces",
            "C": "procesele active la un moment dat au prioritati diferite",
            "D": "memoria necesara proceselor active la un moment dat depaseste dimensiunea memoriei existente"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Two-level scheduling is used when the memory required by the active processes at a given time exceeds the available memory size. This approach helps manage limited resources by swapping processes in and out of the main memory, allowing the system to handle more processes than it could fit in memory simultaneously. This ensures efficient utilization of memory and CPU resources, even when the demand exceeds the system's immediate capacity."
        },
        {
          "id": 23,
          "text": "In sistemele de operare de tip client-server nucleul acestuia realizeaza:",
          "options": {
            "A": "servirea proceselor server",
            "B": "servirea proceselor client",
            "C": "transportul mesajelor de la procesele client catre procesele server",
            "D": "accesul la resursele proceselor client si ale proceselor server"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In a client-server operating system, the kernel is responsible for managing communication between clients and servers. The correct answer is C: \"transportul mesajelor de la procesele client către procesele server\" (the transport of messages from client processes to server processes). This is because the kernel facilitates the exchange of information by ensuring that messages are properly routed and delivered between client and server processes, enabling them to communicate and function effectively. The other options (serving client or server processes, or accessing resources) do not accurately describe the primary role of the kernel in this context."
        },
        {
          "id": 24,
          "text": "Fiecare nivel al ierarhiei sistemului de calcul este un sistem calculator caracterizat de:",
          "options": {
            "A": "structuri de informatie",
            "B": "relatia intre nivele",
            "C": "tipuri de date",
            "D": "operatii primitive"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "In the context of computer systems, each level of the hierarchy is characterized by specific aspects that define its functionality and purpose. \n\n- **Structuri de informatie (A)**: This refers to the data structures used at each level, which define how information is organized and manipulated within that level.\n  \n- **Tipuri de date (C)**: Each level deals with certain data types that are appropriate for its operations, reflecting the abstraction and functionality of that level.\n\n- **Operatii primitive (D)**: These are the basic operations that can be performed at a given level, forming the foundational actions that more complex processes are built upon.\n\nThe incorrect option:\n\n- **Relatia intre nivele (B)**: While relationships between levels are important for understanding"
        },
        {
          "id": 25,
          "text": "Un vector de intrerupere reprezinta:",
          "options": {
            "A": "adresele punctelor de intrerupere a activitatii sistemului calculator",
            "B": "punctul de intrare in sistemul de operare relativ la evenimentul care a deter- minat aparitia intreruperii",
            "C": "directia catre care se indreapta sistemul de operare",
            "D": "o colectie de registre la care au acces toate subunitatile care pot fi intrerupte de unitatea centrala"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "A vector de întrerupere este un mecanism utilizat în arhitectura calculatoarelor pentru a gestiona întreruperile. Când un eveniment extern sau intern necesită atenția procesorului, acesta generează o întrerupere care determină procesorul să întrerupă temporar execuția curentă și să execute o rutină de tratare a întreruperii. Opțiunea B este corectă deoarece un vector de întrerupere indică punctul de intrare în sistemul de operare pentru gestionarea evenimentului care a cauzat întreruperea. Acesta este un tabel de adrese care asociază fiecare tip de întrerupere"
        },
        {
          "id": 26,
          "text": "Fie un sistem cu 5 procese, notate A,B,C,D,E si 4 resurse R,S,T,U pentru care cunoastem ca: \n- procesul A este blocat pe resursa T si detine U \n- procesul B solicita pe U si detine S \n- procesul C detine R \n- procesul D este blocat pe S si R si detine T \n- procesul E este blocat pe R \nProcesele si resursele implicate in interblocare sunt:",
          "options": {
            "A": "nu exista interblocare",
            "B": "A-S-D-U-C-T-B",
            "C": "A-U-B-S-D-R",
            "D": "B-U-A-T-D-R",
            "E": "D-S-B-U-A-T"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "To determine which processes and resources are involved in a deadlock, we need to identify a cycle in the resource allocation graph. A deadlock occurs when a set of processes are blocked because each process is holding a resource and waiting for another resource in a circular chain.\n\nLet's examine the given relationships:\n\n1. Process A is blocked on resource T and holds U.\n2. Process B is requesting U and holds S.\n3. Process C holds R.\n4. Process D is blocked on S and R and holds T.\n5. Process E is blocked on R.\n\nNow let's analyze the options to find the correct cycle:\n\n- **E. D-S-B-U-A-T**: This option suggests a cycle:\n  - D is waiting for S,"
        },
        {
          "id": 27,
          "text": "Evacuarea-re incarcarea proceselor (swapping) este procesul de:",
          "options": {
            "A": "terminare, respectiv incepe a proceselor",
            "B": "transfer al datelor in fisiere pe disc",
            "C": "lansare in executie a programelor",
            "D": "transfer al proceselor intre memorie si disc"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Swapping is a memory management technique used in operating systems where processes are transferred between main memory and disk storage. This process helps manage limited physical memory by temporarily moving inactive processes to disk, freeing up memory for active processes. The correct answer is D because swapping specifically involves the transfer of processes between memory (RAM) and disk storage, allowing the system to handle more processes than the available physical memory can accommodate simultaneously."
        },
        {
          "id": 28,
          "text": "Functia unui operator al unitatii de prelucrare reprezinta:",
          "options": {
            "A": "multimea operatiilor de verificare a operanzilor operatorului respectiv",
            "B": "multimea operatiilor primitive diferite care pot fi executate de operatorul respectiv",
            "C": "multimea operatiilor binare ale sistemului calculator",
            "D": "multimea subprogramelor pe care le poate executa un operator"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The correct answer is B. The function of a processing unit operator refers to the set of different primitive operations that the operator can execute. This means that it encompasses all the basic tasks or instructions that the operator is capable of performing. Unlike options A, C, and D, which focus on operand verification, binary operations, and subprogram execution respectively, option B accurately captures the essence of the operator's capabilities in terms of fundamental operations."
        },
        {
          "id": 29,
          "text": "Un subsistem functional al sistemului calculator este compus din:",
          "options": {
            "A": "unitate functionala propriu-zisa",
            "B": "unitate de control",
            "C": "unitate de legatura",
            "D": "unitate de comanda"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "In contextul arhitecturii calculatoarelor, un subsistem funcțional al unui sistem de calcul este compus din mai multe componente care îndeplinesc funcții specifice. Opțiunile corecte sunt:\n\nA. Unitate funcțională propriu-zisă - aceasta se referă la componentele hardware sau software care realizează efectiv sarcini specifice, cum ar fi procesarea datelor.\n\nB. Unitate de control - aceasta coordonează funcționarea diferitelor componente ale sistemului, asigurându-se că toate părțile funcționează în armonie pentru a îndeplini sarcinile cerute.\n\nCelelalte opțiuni, C"
        },
        {
          "id": 30,
          "text": "Operatorii unitatii de prelucrare sunt:",
          "options": {
            "A": "operatorul binar",
            "B": "operatorul virgula fixa",
            "C": "operatorul virgula mobila",
            "D": "operatorul zecimal"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "The question is asking about types of operators used in a processing unit. Here's a brief explanation for each option:\n\nA. **Operatorul binar (Binary operator)** - This is a fundamental type of operator in computing that works with binary data, performing operations like addition, subtraction, and logical operations on binary numbers.\n\nB. **Operatorul virgula fixa (Fixed-point operator)** - This is typically used in specific applications where fixed-point arithmetic is needed, but it is not a standard operator in general-purpose processing units.\n\nC. **Operatorul virgula mobila (Floating-point operator)** - These operators handle floating-point arithmetic, which is essential for a wide range of computing tasks, particularly those requiring precision with real numbers.\n\nD. **Operatorul"
        },
        {
          "id": 31,
          "text": "Tranzitia unui proces din starea “ in executie” in starea “gata” are loc atunci cand:",
          "options": {
            "A": "planificatorul decide suspendarea procesului pentru ca i-a expirat cuanta de timp alocata",
            "B": "planificatorul, in urma analizei proceselor active stabileste ca un proces nu poate continua executia",
            "C": "procesul nu mai are date de prelucrat si trebuie sa-si termine executia",
            "D": "procesul nu mai are date de transferat si poate sa-si continue executia"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the context of operating systems and process management, a process transitions from the \"running\" state to the \"ready\" state primarily when the scheduler intervenes to manage CPU time allocation among processes. Option A describes this scenario accurately: the scheduler suspends the execution of a process because its allocated time slice (or quantum) has expired. This is a typical behavior in preemptive multitasking systems, where the CPU is shared among processes to ensure responsive and fair execution. The process moves to the \"ready\" state, waiting for its next turn to execute. Options B, C, and D describe scenarios that don't align with standard process state transitions based on time quantum expiration."
        },
        {
          "id": 32,
          "text": "Intr-un sistem de operare de tip client-server procesele server lucreaza in modul de lucru:",
          "options": {
            "A": "supervizor",
            "B": "kernel",
            "C": "utilizator",
            "D": "privilegiat"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In a client-server operating system, server processes typically operate in user mode, which is distinct from kernel mode. This is because user mode restricts access to critical system resources and kernel functions, thus ensuring that even if a server process encounters an error or is compromised, it cannot directly affect the core operating system operations. Operating in user mode provides an additional layer of security and stability by preventing server processes from executing potentially harmful operations that could disrupt the entire system. This is why the correct answer is C. utilizator (user)."
        },
        {
          "id": 33,
          "text": "Cuvantul de stare al programului (PSW):",
          "options": {
            "A": "asigura interfata intre sistemul calculator si program",
            "B": "asigura interfata intre sistemul de operare si program",
            "C": "asigura interfata intre unitatea de prelucrare si program",
            "D": "asigura interfata intre sistemul calculator si sistemul de operare"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The Program Status Word (PSW) is a key component in computer architecture that contains status information about the currently executing program. It is used by the operating system to manage and control the execution of programs. The PSW includes information such as the instruction address, condition codes, and control bits that affect the execution of instructions. Therefore, the correct answer is B, as the PSW provides an interface between the operating system and the program, enabling the system to effectively manage program execution and handle tasks such as interrupts and context switching."
        },
        {
          "id": 34,
          "text": "Pentru a se evita “conditiile de competitie” este nevoie sa utilizam:",
          "options": {
            "A": "variabile partajate",
            "B": "fisiere partajate",
            "C": "excludere mutuala",
            "D": "sectiuni critice"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Excluderea mutuală (opțiunea C) este un mecanism utilizat în programare pentru a preveni condițiile de competiție, care apar atunci când mai multe procese sau fire de execuție încearcă să acceseze simultan resurse partajate, ceea ce poate duce la comportamente imprevizibile sau eronate. Prin implementarea excluderii mutuale, se asigură că doar un singur proces sau fir de execuție poate accesa resursa critică la un moment dat, prevenind astfel conflictele și asigurând integritatea datelor."
        },
        {
          "id": 35,
          "text": "Planificarea cu cozi multiple se aplica la:",
          "options": {
            "A": "sistemele calculator la care comutarea intre procese este foarte rapida",
            "B": "sistemele calculator la care comutarea intre procese este foarte lenta",
            "C": "sistemele calculator cu doua procesoare",
            "D": "sistemele calculator pentru conducerea proceselor industriale"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Planificarea cu cozi multiple se referă la un mecanism de planificare a proceselor în care mai multe cozi sunt utilizate pentru a gestiona diferite tipuri de procese, fiecare cu priorități și cerințe diferite. În contextul sistemelor de calcul, comutarea între procese poate fi o operațiune costisitoare în termeni de timp și resurse. Astfel, în sistemele în care comutarea între procese este foarte lentă, utilizarea cozilor multiple devine avantajoasă, deoarece permite o organizare mai eficientă și mai flexibilă a proceselor, reducând timpul de așteptare și îmbunătățind utilizarea"
        }
      ]
    },
    {
      "name": "Retele de calculatoare",
      "questions": [
        {
          "id": 1,
          "text": "O retea de calculatoare reprezinta:",
          "options": {
            "A": "o colectie de calculatoare autonome interconectate prin cablu UTP",
            "B": "o colectie de calculatoare personale conectate la Internet",
            "C": "o colectie de calculatoare autonome interconectate folosind o singura tehnologie",
            "D": "o colectie de calculatoare autonome interconectate folosind o arhitectura client-server",
            "E": "o colectie de calculatoare personale interconectate folosind o tehnologie orientata pe conexiuni"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "A computer network is defined as a collection of autonomous computers that are interconnected to share resources and information. The key aspect of option C is the use of a \"single technology\" for interconnection, which aligns with the basic definition of a network where computers are linked using a specific networking technology (such as Ethernet, Wi-Fi, etc.) to facilitate communication and resource sharing. This distinguishes it from other options that either specify particular types of connections (e.g., UTP cable) or architectures (e.g., client-server), which are not necessary conditions for forming a computer network."
        },
        {
          "id": 2,
          "text": "O retea de calculatoare a carei raspandire este la nivelul unui campus este:",
          "options": {
            "A": "o retea locala",
            "B": "o retea metropolitana",
            "C": "o retea de tip stea",
            "D": "o retea cu difuzare",
            "E": "o retea larg raspandita geografic"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "A rețea de calculatoare a cărei răspândire este la nivelul unui campus este clasificată drept \"o rețea locală\" (LAN - Local Area Network). Aceasta acoperă o suprafață geografică limitată, cum ar fi un campus universitar, o clădire de birouri sau un grup de clădiri apropiate. Rețelele locale sunt utilizate pentru a conecta computerele și alte dispozitive într-o zonă restrânsă, permițând partajarea resurselor și facilitând comunicarea rapidă între dispozitivele conectate. Opțiunile B, D și E se referă la rețele cu o ar"
        },
        {
          "id": 3,
          "text": "O retea de tip inel,",
          "options": {
            "A": "conecteaza printr-un singur cablu toate calculatoarele din retea",
            "B": "conecteaza fiecare calculator de alte doua",
            "C": "foloseste un calculator central care va fi conectat cu toate celelalte prin conexiuni directe",
            "D": "conecteaza toate calculatoarele intre ele fara ca vreunul sa aiba rol coodonator",
            "E": "are un singur canal de comunicatie care este partajat de toate masinile din retea"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "A ring network is a type of network topology where each computer is connected to exactly two other computers, forming a circular pathway for data. This setup allows data to travel in one or both directions around the ring, with each device having exactly two neighbors for communication purposes. This configuration ensures that there is no need for a central computer to coordinate the network, and it differs from other topologies like star or bus networks. Therefore, the correct answer is B, as it accurately describes how each computer in a ring network is connected to two others, creating a closed loop."
        },
        {
          "id": 4,
          "text": "Retelele care dispun de numeroase conexiuni intre perechi de masini individuale sunt:",
          "options": {
            "A": "retele cu difuzare",
            "B": "retele de tip stea",
            "C": "retele de tip plasa",
            "D": "retele de tip punct-la-punct",
            "E": "retele de tip magistrala"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The correct answer is C, not D. Here is the explanation:\n\nRetele de tip plasa (C) are characterized by having numerous connections between pairs of individual machines. In a mesh network, each device is typically connected to several other devices, allowing for multiple pathways for data to travel. This setup increases reliability and redundancy, as data can take alternative routes if one connection fails. On the other hand, \"retele de tip punct-la-punct\" (D) refers to a direct link between two individual devices, not numerous connections between many devices."
        },
        {
          "id": 5,
          "text": "Stiva de protocoale reprezinta:",
          "options": {
            "A": "o structura de date de tip ultimul intrat – primul servit folosita de protocoalele retelei",
            "B": "o lista de protocoale folosite de un anumit sistem cate un protocol pentru fiecare nivel",
            "C": "stiva folosita pentru transmiterea parametrilor functiilor realizate de protocoalele unei retele"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "A \"stivă de protocoale\" se referă la o colecție organizată de protocoale de rețea, unde fiecare protocol operează la un anumit nivel al modelului de referință OSI (Open Systems Interconnection) sau al modelului TCP/IP. Aceasta nu este o structură de date de tip \"ultimul intrat – primul servit\" și nici nu se referă la transmiterea parametrilor funcțiilor. În schimb, reprezintă un set de protocoale folosite de un sistem, fiecare având un rol specific la diferite niveluri de comunicație. Astfel, răspunsul corect este B, deoarece descrie corect o listă"
        },
        {
          "id": 6,
          "text": "Pentru a utiliza un serviciu orientat pe conexiuni beneficiarul trebuie sa:",
          "options": {
            "A": "stabileasca o conexiune, sa foloseasca aceasta conexiune si apoi sa o elibereze",
            "B": "se conecteze la retea folosind un nume de utilizator si o parola corespunzatoare",
            "C": "sa nu foloseasca medii de comunicatie fara fir (wireless)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In contextul serviciilor de rețea, un serviciu orientat pe conexiuni necesită stabilirea unei conexiuni dedicate între două puncte înainte de a putea începe transferul de date. Aceasta presupune trei pași principali: mai întâi, trebuie să se stabilească o conexiune între sursă și destinație; ulterior, această conexiune este utilizată pentru transmiterea datelor; și, în final, după ce transferul de date este complet, conexiunea trebuie eliberată sau închisă. Acești pași asigură un flux de comunicare controlat și securizat între părțile implicate. Variantele B și C nu sunt relevante pentru servici"
        },
        {
          "id": 7,
          "text": "Un serviciu este",
          "options": {
            "A": "un set de primitive (operatii) pe care un nivel le furnizeaza entitatii pereche de pe calculatorul cu care comunica",
            "B": "un set de primitive (operatii) pe care un nivel le furnizeaza nivelului de deasupra sa",
            "C": "un set de primitive (operatii) pe care un nivel le furnizeaza nivelului fizic",
            "D": "un set de primitive (operatii) pe care un nivel le pune la dispozitia utilizatorului",
            "E": "un set de primitive (operatii) pe care un nivel le furnizeaza interfetelor de retea"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In the context of network architecture and layered models (such as the OSI model), a \"serviciu\" (service) refers to the functionalities or operations provided by one layer to the layer directly above it. This is a fundamental concept in layered architectures, where each layer serves the one above it by offering a defined set of operations that help abstract the details of the processes and protocols occurring at lower levels. Thus, option B is the correct choice because it accurately describes the hierarchical relationship between layers where a layer provides services to the layer above it."
        },
        {
          "id": 8,
          "text": "Un protocol este",
          "options": {
            "A": "un set de reguli folosit pentru apelul primitivelor de serviciu",
            "B": "un set de reguli care guverneaza formatul si semnificatia cadrelor, pachetelor \nsau mesajelor schimbate intre ele de entitatile pereche de pe un anumit nivel",
            "C": "un set de reguli care guverneaza formatul pachetelor transmise nivelelor superioare",
            "D": "un set de reguli care guverneaza formatul pachetelor transmise nivelului fizic"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Explanation: In networking, a protocol is a set of rules that governs the communication between entities on a network. Option B is correct because it accurately describes a protocol as a set of rules that dictate the format and meaning of frames, packets, or messages exchanged between peer entities at a specific layer. This encompasses not only the structure but also the interpretation of the data being communicated, ensuring that both parties understand and process the information correctly. Options A, C, and D are incorrect because they either limit the scope of a protocol to a specific function or context that does not fully capture the broad role of protocols in network communication."
        },
        {
          "id": 9,
          "text": "Care dintre urmatoarele niveluri nu face parte din modelul ISO-OSI?",
          "options": {
            "A": "nivelul fizic",
            "B": "nivelul legatura de date",
            "C": "nivelul internet",
            "D": "nivelul transport",
            "E": "nivelul sesiune"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The ISO-OSI (Open Systems Interconnection) model is a conceptual framework used to understand and implement network protocols in seven distinct layers. These layers are: \n\n1. Nivelul fizic (Physical Layer)\n2. Nivelul legătura de date (Data Link Layer)\n3. Nivelul rețea (Network Layer)\n4. Nivelul transport (Transport Layer)\n5. Nivelul sesiune (Session Layer)\n6. Nivelul prezentare (Presentation Layer)\n7. Nivelul aplicație (Application Layer)\n\nThe correct answer is C, \"nivelul internet,\" because it does not correspond to any of the seven layers in the ISO-OSI model. Instead, \"nivelul internet\" is more closely associated with the TCP/IP"
        },
        {
          "id": 10,
          "text": "Care dintre urmatoarele niveluri nu face parte din modelul TCP/IP?",
          "options": {
            "A": "nivelul internet",
            "B": "nivelul transport",
            "C": "nivelul prezentare",
            "D": "nivelul aplicatie",
            "E": "nivelul gazda-la-retea"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Explicație scurtă: Modelul TCP/IP este compus din patru niveluri principale: nivelul aplicație, nivelul transport, nivelul internet și nivelul gazdă-la-rețea. Nivelul de prezentare nu face parte din modelul TCP/IP; acesta este un nivel din modelul OSI, care include șapte niveluri. Modelul OSI are niveluri suplimentare, cum ar fi prezentare și sesiune, care nu sunt prezente în modelul TCP/IP."
        },
        {
          "id": 11,
          "text": "Care dintre urmatoarele sarcini NU apartine nivelului legatura de date?",
          "options": {
            "A": "tratarea erorilor",
            "B": "tratarea secventialitatii",
            "C": "controlul traficului",
            "D": "controlul accesului la mediu"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Nivelul legăturii de date din modelul OSI este responsabil pentru stabilirea unei conexiuni de date fără erori între două noduri adiacente. Funcțiile sale principale includ tratarea erorilor, controlul traficului și controlul accesului la mediu. Tratarea secvențialității, însă, este o funcție asociată cu nivelul de transport, care se ocupă de asigurarea livrării corecte a pachetelor în ordinea corectă. Prin urmare, opțiunea B, tratarea secvențialității, nu aparține nivelului legăturii de date."
        },
        {
          "id": 12,
          "text": "Care dintre urmatoarele sarcini NU apartine nivelului retea?",
          "options": {
            "A": "dirijarea pachetelor",
            "B": "controlul congestiei",
            "C": "calitatea serviciilor",
            "D": "refacerea ordinii de transmisie a pachetelor",
            "E": "interconectarea retelelor eterogene"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "În cadrul modelului OSI (Open Systems Interconnection), nivelul rețea este responsabil pentru funcții precum dirijarea pachetelor (A), controlul congestiei (B), calitatea serviciilor (C), și interconectarea rețelelor eterogene (E). Aceste funcții sunt esențiale pentru asigurarea unei comunicări eficiente și fiabile între dispozitivele din rețea. Cu toate acestea, refacerea ordinii de transmisie a pachetelor (D) nu aparține nivelului rețea, ci nivelului transport. Nivelul transport, cum ar fi protocolul TCP (Transmission Control Protocol), se ocupă de asigurarea că pache"
        },
        {
          "id": 13,
          "text": "Care dintre urmatoarele sarcini NU apartine nivelului sesiune?",
          "options": {
            "A": "difuzarea mesajelor",
            "B": "controlul dialogului",
            "C": "sincronizarea",
            "D": "gestiunea jetonului"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "La nivelul sesiunii, sarcinile principale includ controlul dialogului, sincronizarea și gestiunea jetonului, care se referă la gestionarea modului în care se desfășoară comunicarea între două puncte finale într-o rețea. Aceste sarcini asigură că comunicarea este ordonată și eficientă. Difuzarea mesajelor (opțiunea A) este o sarcină care aparține, de obicei, nivelului de rețea sau de transport, unde mesajele sunt transmise prin rețea către mai multe destinații. Astfel, difuzarea mesajelor nu este o sarcină tipică pentru nivelul sesiun"
        },
        {
          "id": 14,
          "text": "Care dintre urmatoarele afirmatii este FALSA?",
          "options": {
            "A": "Modelul OSI suporta ambele tipuri de comunicatii – orientata pe conexiuni respectiv fara\nconexiuni – la nivelul retea",
            "B": "Modelul OSI suporta numai comunicatia orientata pe conexiuni la nivelul transport",
            "C": "Modelul TCP/IP suporta ambele tipuri de comunicatii – orientata pe conexiuni \nrespectiv fara conexiuni – la nivelul transport",
            "D": "Modelul TCP/IP suporta numai comunicatia fara conexiuni la nivelul retea",
            "E": "Modelul OSI suporta numai comunicatia fara conexiuni la nivelul transport"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "The correct answer is E. \n\nExplanation: In the OSI (Open Systems Interconnection) model, the transport layer is designed to support both connection-oriented and connectionless communication. This means that the OSI model is capable of handling data transmission that requires establishing a connection before data transfer (connection-oriented) and data transmission that doesn't require such a connection (connectionless). Therefore, the statement that the OSI model supports only connectionless communication at the transport layer is false. \n\nHere's a brief overview of the other options:\n\nA. The OSI model indeed supports both connection-oriented and connectionless communication at the network layer, which makes this statement true.\n\nB. As mentioned earlier, the transport layer in the OSI model supports both types of communication"
        },
        {
          "id": 15,
          "text": "Care dintre protocoalele urmatoare nu este de nivel aplicatie?",
          "options": {
            "A": "HTTP",
            "B": "UDP",
            "C": "FTP",
            "D": "SMTP",
            "E": "DNS"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "UDP (User Datagram Protocol) is not an application layer protocol; it operates at the transport layer of the OSI (Open Systems Interconnection) model. While HTTP, FTP, SMTP, and DNS are protocols that operate at the application layer and are used to facilitate various types of data communication over the internet, UDP is responsible for enabling the transmission of datagrams between devices across networks, providing a foundation for application layer protocols to function."
        },
        {
          "id": 16,
          "text": "Care dintre urmatoarele afirmatii este ADEVARATA?",
          "options": {
            "A": "TCP este un protocol sigur orientat pe conexiuni",
            "B": "TCP este un protocol sigur fara conexiuni",
            "C": "UDP este un protocol sigur fara conexiuni",
            "D": "UDP este un protocol nesigur orientat pe conexiuni",
            "E": "TCP este un protocol nesigur orientat pe conexiuni"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "TCP (Transmission Control Protocol) este un protocol de comunicație orientat pe conexiuni, ceea ce înseamnă că stabilește o conexiune fiabilă între două dispozitive înainte de a transfera datele. Acesta asigură livrarea corectă și în ordine a pachetelor de date, oferind mecanisme de verificare a erorilor și retransmisie a pachetelor pierdute. De aceea, TCP este considerat un protocol \"sigur\" în sensul fiabilității transferului de date, fiind orientat pe conexiuni. Celelalte opțiuni nu descriu corect caracteristicile fundamentale ale TCP sau UDP (User Datagram Protocol"
        },
        {
          "id": 17,
          "text": "Serviciile de baza, oferite in mod curent de catre nivelul legatura de date sunt:",
          "options": {
            "A": "serviciu neconfirmat fara conexiune",
            "B": "serviciu neconfirmat orientat-conexiune",
            "C": "serviciu confirmat fara conexiune",
            "D": "serviciu confirmat orientat-conexiune"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "In the context of data link layer services, the key functions include providing a reliable data transfer over a physical link and managing how data packets are framed and transmitted between nodes.\n\n- **Serviciu neconfirmat fara conexiune (A)**: This service provides data transfer without the need for establishing a connection and without confirmation of receipt, similar to a basic \"send and forget\" approach.\n\n- **Serviciu confirmat fara conexiune (C)**: This service allows for data transfer without a prior connection setup but includes a mechanism to confirm the receipt of data, ensuring that the information has reached its destination.\n\n- **Serviciu confirmat orientat-conexiune (D)**: This service involves establishing a connection before data"
        },
        {
          "id": 18,
          "text": "Controlul fluxului in nivelul legatura de date se face prin",
          "options": {
            "A": "controlul erorilor",
            "B": "reactie inversa",
            "C": "controlul retransmisiilor",
            "D": "detectarea coliziunilor"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În contextul nivelului legătură de date al modelului OSI, controlul fluxului se referă la gestionarea ratei de transmitere a datelor între două dispozitive, astfel încât să se evite supraîncărcarea receptorului. Opțiunea corectă, \"B. reacție inversă\", se referă la mecanismul prin care receptorul trimite feedback către expeditor pentru a ajusta viteza de transmitere a datelor. Această reacție inversă asigură că expeditorul nu trimite mai multe date decât poate receptorul să proceseze în mod eficient, prevenind astfel pierderea de date și asigurând o comunicare eficient"
        },
        {
          "id": 19,
          "text": "Protocoalele folosite pentru a determina cine urmeaza sa transmita intr-un canal multiacces apartin",
          "options": {
            "A": "subnivelul MAC",
            "B": "subnivelului LLC",
            "C": "nivelului fizic",
            "D": "nivelului legatura de date"
          },
          "correct_answer": [
            "A",
            "D"
          ],
          "explanation": "In rețelele de calculatoare, comunicarea într-un mediu de acces multiplu necesită un mecanism de control pentru a decide ce dispozitiv poate transmite date la un moment dat, pentru a preveni coliziunile. Aceste mecanisme sunt gestionate de protocoalele de control al accesului la mediu (MAC), care fac parte din subnivelul MAC al nivelului de legătură de date. Subnivelul MAC se ocupă de aspectele legate de accesul la canal și de controlul accesului la mediu. În cadrul modelului OSI, nivelul de legătură de date (nivelul 2) este responsabil pentru transferul de date între nodurile conectate"
        },
        {
          "id": 20,
          "text": "Care dintre campurile de mai jos apartin unui cadru (frame) Ethernet?",
          "options": {
            "A": "adresa destinatie",
            "B": "date",
            "C": "suma de control",
            "D": "port sursa"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Un cadru Ethernet este format din mai multe componente esențiale care asigură transmiterea corectă a datelor între dispozitivele dintr-o rețea. Răspunsurile corecte includ:\n\nA. **Adresa destinație** - Aceasta face parte din antetul unui cadru Ethernet și indică adresa hardware (MAC) a dispozitivului destinatar pentru a asigura livrarea corectă a datelor.\n\nB. **Date** - Acesta este câmpul care conține efectiv informațiile transmise, fiind partea centrală a cadrului Ethernet.\n\nC. **Suma de control** - Cunoscută și sub numele de FCS ("
        },
        {
          "id": 21,
          "text": "Adresele subnivelului MAC Ethernet se reprezinta pe",
          "options": {
            "A": "4 octeti",
            "B": "5 octeti",
            "C": "6 octeti",
            "D": "8 octeti"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The correct answer is C: 6 octeti. An Ethernet MAC (Media Access Control) address is a unique identifier assigned to network interfaces for communications at the data link layer of a network segment. It is typically represented as a 48-bit number, which is equal to 6 bytes or octets. Each octet consists of 8 bits, making it a total of 48 bits for the entire MAC address. This format is standardized and used in various networking technologies, including Ethernet."
        },
        {
          "id": 22,
          "text": "Lungimea minima a unui cadru Ethernet valid este de:",
          "options": {
            "A": "40 octeti",
            "B": "80 octeti",
            "C": "64 octeti",
            "D": "128 octeti"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The minimum length of a valid Ethernet frame is determined by the need to ensure proper collision detection in a CSMA/CD network. Ethernet frames must be at least 64 bytes (octets) long, which includes both the header and the payload. This minimum size allows the frame to be transmitted long enough for the sending station to detect any potential collisions on the network. If the frame were shorter, the collision detection mechanism would not function correctly, potentially leading to network communication issues. Therefore, the correct answer is C, 64 octets."
        },
        {
          "id": 23,
          "text": "Care dintr eregulile urmatoare sunt utilizate pentru dirijarea traficului in cadrul puntilor \ntransparente (transparent bridges)?",
          "options": {
            "A": "Daca LAN-ul sursa este acela si cu LAN-ul destinatie, atunci abandoneaza cadrul",
            "B": "Daca LAN-ul sursa si cel destinatie sunt diferite, atunci transmite cadrul",
            "C": "Daca LAN-ul destinatie nu este cunoscut, atunci foloseste inundarea",
            "D": "Daca LAN-ul destinatie nu este cunoscut, atunci abandoneaza cadrul"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Transparent bridges are network devices used to filter and forward traffic between different segments of a local area network (LAN). They operate by maintaining a forwarding table to make intelligent decisions about where to send traffic based on the source and destination of data frames. Let's break down the correct options:\n\nA. \"Daca LAN-ul sursa este acela si cu LAN-ul destinatie, atunci abandoneaza cadrul\" (If the source LAN is the same as the destination LAN, then discard the frame): This rule is used because if the source and destination are on the same LAN, there is no need to forward the frame through the bridge, as it would create unnecessary traffic.\n\nB. \"Daca LAN-ul sursa si cel destinatie sunt diferite,"
        },
        {
          "id": 24,
          "text": "Serviciile nivelului retea au fost proiectate avand in vedere urmatoarele scopuri:",
          "options": {
            "A": "serviciile trebuie sa fie independente de tehnologia ruterului",
            "B": "nivelul transport trebuie sa fie independent de numarul, tipul si topologia \nruterelor existente",
            "C": "adresele de retea disponibile la nivelul transport trebuie sa foloseasca o schema \nde numerotare uniforma, chiar in cadrul retelelor LAN si WAN",
            "D": "serviciile trebuie sa asigure evitarea coliziunilor"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "The question addresses the design objectives of network layer services, which are crucial for ensuring efficient and effective data communication across diverse networks. \n\nA. \"Serviciile trebuie sa fie independente de tehnologia ruterului\" (Services should be independent of router technology) is correct because network layer services need to function regardless of the underlying hardware or technology of the routers to ensure interoperability and flexibility across different systems.\n\nB. \"Nivelul transport trebuie sa fie independent de numarul, tipul si topologia ruterelor existente\" (The transport layer should be independent of the number, type, and topology of existing routers) is correct because the transport layer should be able to deliver data without needing to know the specifics of the network infrastructure, allowing for seamless communication"
        },
        {
          "id": 25,
          "text": "Care dintre urmatoarele campuri fac parte din datagrama IP?",
          "options": {
            "A": "versiunea",
            "B": "tip serviciu",
            "C": "port destinatie",
            "D": "timp de viata"
          },
          "correct_answer": [
            "A",
            "B",
            "D"
          ],
          "explanation": "O datagramă IP este un pachet de date utilizat în rețelele de calculatoare care utilizează Protocolul Internet (IP) pentru transmiterea informațiilor. Structura datagramei IP include mai multe câmpuri esențiale pentru asigurarea corectitudinii și eficienței transmiterii datelor. Câmpurile \"versiunea\" și \"tip serviciu\" sunt parte din antetul IP, având rolul de a specifica versiunea protocolului și calitatea serviciului dorit. \"Timp de viață\" este un alt câmp important care previne ciclarea infinită a pachetelor în rețea prin limitarea durate"
        },
        {
          "id": 26,
          "text": "Multimea adreselor IP de clasa A se regaseste in intervalul de adrese:",
          "options": {
            "A": "10.0.0.0 – 127.255.255.255",
            "B": "128.0.0.0 – 191.255.255.255",
            "C": "1.0.0.0 - 127.255.255.255",
            "D": "1.0.0.0 – 127.0.0.1"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The correct answer is C: 1.0.0.0 - 127.255.255.255.\n\nExplanation: In the original IPv4 addressing system, IP addresses are divided into five classes (A, B, C, D, and E) based on their leading bits. Class A addresses are designated for large networks and can be identified by their first octet, which ranges from 1 to 127. Therefore, the range of Class A IP addresses starts from 1.0.0.0 and goes up to 127.255.255.255. The address 127.0.0.0 to 127.255.255.255 is reserved for loopback functions and not used for network addresses,"
        },
        {
          "id": 27,
          "text": "Multimea adreselor IP de clasa B se regaseste in intervalul de adrese:",
          "options": {
            "A": " 128.0.0.0 – 192.0.0.0",
            "B": "128.0.0.0 - 191.255.255.255",
            "C": "127.255.255.255 – 191.255.255.255",
            "D": "127.0.0.1 – 192.0.0.0"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "IP addresses are divided into different classes, and each class has a specific range. Class B IP addresses are used for medium to large-sized networks. The Class B range is defined by the first octet of the address, which starts from 128 to 191. The full range for Class B IP addresses is from 128.0.0.0 to 191.255.255.255. This is because the first two bits of a Class B address are '10', which corresponds to the decimal range of 128-191 in the first octet. Therefore, the correct answer is B, as it accurately represents the complete range for Class B IP addresses."
        },
        {
          "id": 28,
          "text": "Multimea adreselor IP de clasa C se regaseste in intervalul de adrese:",
          "options": {
            "A": "191.255.255.255 – 223.255.255.255",
            "B": "192.0.0.0 – 224.0.0.0",
            "C": "191.255.255.255 – 224.0.0.0",
            "D": "192.0.0.0 - 223.255.255.255"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The correct answer is D: 192.0.0.0 - 223.255.255.255.\n\nExplanation: In the original IPv4 address classification system, IP addresses were divided into five classes (A, B, C, D, and E) for different types of networks. Class C addresses are designed for small networks and have a specific range of IP addresses. \n\nClass C addresses start at 192.0.0.0 and end at 223.255.255.255. This range is defined by the first three bits of the first octet being set to \"110,\" which restricts the values from 192 to 223. Therefore, option D correctly describes the range of Class C IP addresses. The"
        },
        {
          "id": 29,
          "text": "Multimea adreselor IP de clasa D se regaseste in intervalul de adrese:",
          "options": {
            "A": "224.0.0.0 – 239.255.255.255",
            "B": "223.255.255.255 – 239.255.255.255",
            "C": "223.255.255.255 – 240.0.0.0",
            "D": "224.0.0.0 – 240.0.0.0"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Class D IP addresses are designated for multicast, which is a method used to send data to multiple computers simultaneously. The range for Class D addresses is specifically from 224.0.0.0 to 239.255.255.255. This range is defined by the first four bits of the address being '1110', which translates to the decimal value starting from 224 up to 239. Therefore, the correct interval for Class D IP addresses is 224.0.0.0 to 239.255.255.255, making option A the correct choice."
        },
        {
          "id": 30,
          "text": "Multimea adreselor IP de clasa E se regaseste in intervalul de adrese:",
          "options": {
            "A": "240.0.0.0 – 255.255.255.255",
            "B": "239.255.255.255 – 255.255.255.255",
            "C": "240.0.0.0 – 255.0.0.0",
            "D": "239.255.255.255 – 255.0.0.0"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Multimea adreselor IP de clasa E este rezervată pentru uz experimental și nu este utilizată în mod obișnuit pentru traficul public de internet. Intervalul de adrese IP de clasa E începe de la 240.0.0.0 și se extinde până la 255.255.255.255. Acest interval este destinat în principal pentru cercetare și dezvoltare și nu ar trebui să fie asignat dispozitivelor din rețelele standard. Variantele B, C și D nu acoperă corect întregul interval al clasei E sau includ adrese care nu fac parte din clasa E. Astfel, răspunsul corect este A:"
        },
        {
          "id": 31,
          "text": "Bitii cei mai semnificativi ai unei adrese valide de clasa A au valorile:",
          "options": {
            "A": "0",
            "B": "1",
            "C": "01",
            "D": "10"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the context of IPv4 addressing, IP addresses are divided into classes (A, B, C, D, and E) based on their leading bits. For a Class A IP address, the most significant bit (the first bit) is always set to 0. This allows for a large number of possible networks with a relatively small number of hosts per network. Therefore, the correct answer is A, as the most significant bits of a valid Class A address are 0."
        },
        {
          "id": 32,
          "text": "Bitii cei mai semnificativi ai unei adrese valide de clasa B au valorile:",
          "options": {
            "A": "10",
            "B": "1",
            "C": "01",
            "D": "11"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the context of IP addressing, particularly IPv4, addresses are divided into classes. Each class is defined by the leading bits in the address. \n\nFor a Class B IP address, the most significant bits (the first few bits of the address) are always \"10\". This distinguishes Class B from other classes: \n- Class A addresses start with \"0\", \n- Class C addresses start with \"110\", and so on. \n\nTherefore, the correct answer is A, as \"10\" is the bit pattern that identifies a Class B IP address."
        },
        {
          "id": 33,
          "text": "Bitii cei mai semnificativi ai unei adrese valide de clasa C au valorile:",
          "options": {
            "A": "110",
            "B": "111",
            "C": "100",
            "D": "10"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the context of IP addressing, IP addresses are divided into classes, and each class is identified by the most significant bits of the address. For a Class C IP address, the most significant bits are always \"110\". This is how the network is identified as a Class C network. The Class C address format allows for a large number of networks, each with a smaller number of hosts. Therefore, the correct answer is A, as the most significant bits for a Class C address are \"110\"."
        },
        {
          "id": 34,
          "text": "Bitii cei mai semnificativi ai unei adrese valide de clasa D au valorile:",
          "options": {
            "A": "1110",
            "B": "110",
            "C": "01",
            "D": "10"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Class D IP addresses are used for multicast, which allows a single packet to be delivered to multiple destinations. The defining feature of Class D addresses in the context of IPv4 is that the most significant bits (MSBs) are set to \"1110\". This bit pattern distinguishes Class D addresses from other classes (A, B, C) and sets the range for multicast addresses from 224.0.0.0 to 239.255.255.255. Therefore, the correct answer is A."
        },
        {
          "id": 35,
          "text": "Carei clase de adrese apartine adresa IP 88.100.10.23?",
          "options": {
            "A": "A",
            "B": "B",
            "C": "C",
            "D": "D"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The question asks about the class type of the IP address 88.100.10.23. IP addresses are divided into different classes based on their starting bits, which determine the range and purpose of the address.\n\n- **Class A** addresses range from 0.0.0.0 to 127.255.255.255. They are characterized by having the first bit set to 0, which means the first octet ranges from 0 to 127.\n- **Class B** addresses range from 128.0.0.0 to 191.255.255.255, with the first two bits set to 10.\n- **Class C** addresses range from 192.0.0.0 to"
        },
        {
          "id": 36,
          "text": "Carei clase de adrese apartine adresa IP 163.21.84.12?",
          "options": {
            "A": "A",
            "B": "B",
            "C": "C",
            "D": "D"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The given IP address, 163.21.84.12, belongs to Class B. Here's how we determine this:\n\nIPv4 addresses are divided into different classes (A, B, C, D, and E) based on their leading bits:\n\n- **Class A** addresses range from 0.0.0.0 to 127.255.255.255. They have the first octet ranging from 0 to 127.\n- **Class B** addresses range from 128.0.0.0 to 191.255.255.255. They have the first octet ranging from 128 to 191.\n- **Class C** addresses range from 192.0.0.0 to 223"
        },
        {
          "id": 37,
          "text": "Carei clase de adrese apartine adresa IP 231.2.4.1?",
          "options": {
            "A": "A",
            "B": "B",
            "C": "C",
            "D": "D"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Adresele IP sunt împărțite în mai multe clase (A, B, C, D și E) pe baza primului octet al adresei. Fiecare clasă are un interval specific de adrese. Clasa D este utilizată pentru multicast și include adresele IP care au primul octet în intervalul 224-239. În cazul adresei IP 231.2.4.1, primul octet este 231, ceea ce înseamnă că aceasta aparține clasei D, care este destinată transmisiunilor multicast."
        },
        {
          "id": 38,
          "text": "Protocolul ARP se utilizeaza pentru a afla,",
          "options": {
            "A": "adresa Ethernet pe baza adresei IP",
            "B": "adresa IP pe baza adresei Ethernet",
            "C": "adresa IP pe baza claselor de adrese",
            "D": "adresa IP destinatie pe baza algoritmilor de dirijare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The Address Resolution Protocol (ARP) is used in computer networks to map an IP address to a physical machine address, also known as a MAC (Media Access Control) or Ethernet address. When a device wants to communicate with another device on the same local network, it needs to know the MAC address associated with the IP address of the destination device. ARP facilitates this by sending out a request on the network, asking for the MAC address corresponding to a specific IP address. Therefore, the correct answer is A: it is used to find the Ethernet address based on the IP address."
        },
        {
          "id": 39,
          "text": "Care dintre obiectivele de mai jos sunt vizate de protocolul IPv6?",
          "options": {
            "A": "reducerea dimensiunii tabelelor de dirijare",
            "B": "extinderea adreselor Ethernet la 128 de biti",
            "C": "posibilitatea ca un calculator gazda sa migreze fara a-si schimba adresa IP",
            "D": "asigurarea unei securitati sporite prin mecanisme de autentificare si confidentialitate"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "IPv6 a fost creat pentru a aborda limitările IPv4 și a aduce îmbunătățiri semnificative. \n\nA. Reducerea dimensiunii tabelelor de dirijare: IPv6 utilizează o structură mai eficientă de adresare și agregare, ceea ce permite o reducere a complexității și dimensiunii tabelelor de routare.\n\nC. Posibilitatea ca un calculator gazdă să migreze fără a-și schimba adresa IP: IPv6 suportă mobilitatea IP, permițând dispozitivelor să-și păstreze adresa IP în timp ce se deplasează între diferite rețele.\n\nD."
        },
        {
          "id": 40,
          "text": "Care dintre campurile urmatoare fac parte din antetul obligatoriu IPv6?",
          "options": {
            "A": "urmatorull antent",
            "B": "eticheta fluxului",
            "C": "limita de salturi",
            "D": "tipul nodului: client sau server"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "In IPv6, the mandatory header fields include the \"Next Header\" (următorul antet), \"Flow Label\" (eticheta fluxului), and \"Hop Limit\" (limita de salturi). These fields are essential for the basic functionality of the IPv6 protocol. The \"Next Header\" field indicates the type of the next header following the IPv6 header, the \"Flow Label\" is used for identifying and handling packets belonging to the same flow, and the \"Hop Limit\" specifies the maximum number of hops a packet can take before being discarded. Option D, \"Tipul nodului: client sau server,\" is not a field in the IPv6 header."
        }
      ]
    },
    {
      "name": "Securitatea retelelor de calculatoare",
      "questions": [
        {
          "id": 1,
          "text": "Un sistem criptografic este",
          "options": {
            "A": "Un tuplu format dintr-o functie de criptare, una de decriptare, domeniile de \ndefinitie si chei",
            "B": "Un tuplu format din functie de criptare decriptare, domenii de definitie si chei",
            "C": "Un tuplu format din functie de criptare si chei",
            "D": "Un aparat special de transformare a caracterelor",
            "E": "O metoda de codificare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "A cryptographic system, also known as a cryptosystem, is defined as a structure or scheme consisting of several components that work together to provide secure communication. The correct answer, A, specifies that a cryptographic system is a tuple that includes an encryption function, a decryption function, a set of possible keys, and defined domains for these functions. This comprehensive definition highlights the key components essential for the encryption and decryption processes: the encryption function transforms plaintext into ciphertext using a key, and the decryption function reverses this process, using a key to transform the ciphertext back into plaintext. The inclusion of the domains and keys ensures that the system operates correctly and securely within specified parameters. This understanding is crucial for implementing effective cryptographic systems."
        },
        {
          "id": 2,
          "text": "Un sistem de criptare prin shift-are are o cheie compusa din",
          "options": {
            "A": "doua numere intregi",
            "B": "un numar natural",
            "C": "un numar intreg si unul real",
            "D": "un numar irational",
            "E": "doua numere"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "A shift cipher, also known as a Caesar cipher, is a type of encryption technique where each letter in the plaintext is shifted a certain number of places down or up the alphabet. The key for a shift cipher is a single number that indicates the number of positions each letter in the plaintext is shifted. Since this number must be a whole, non-negative value to effectively represent the shifts, it is characterized as a natural number. Therefore, the correct answer is B, as the encryption key for a shift cipher is composed of one natural number."
        },
        {
          "id": 3,
          "text": "Autentificarea unui mesaj reprezinta",
          "options": {
            "A": "verificarea integritatii mesajului primit de un destinatar",
            "B": "modul prin care expeditorul nu poate nega faptul ca a transmis mesajul",
            "C": "destinatarul unui mesaj trebuie sa dispuna de modalitati de a verifica \nidentitatea expeditorului si originea mesajului"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Autentificarea unui mesaj implică verificarea identității expeditorului și asigurarea că mesajul provine dintr-o sursă autentică. Aceasta înseamnă că destinatarul trebuie să aibă mijloace pentru a confirma cine a trimis mesajul și că acesta nu a fost modificat de la expediere. Opțiunea C descrie acest proces prin sublinierea nevoii destinatarului de a putea verifica identitatea expeditorului și originea mesajului, ceea ce este esențial pentru autentificare. Opțiunile A și B descriu alte aspecte ale securității mesajelor, cum ar fi integritatea și non-repudi"
        },
        {
          "id": 4,
          "text": "Non-Repudierea mesajului intr-o retea reprezinta",
          "options": {
            "A": "Modul de a se accepta un mesaj",
            "B": "dupa transmiterea unui mesaj, trebuie ca expeditorul sa nu il poata nega",
            "C": "dupa transmiterea unui mesaj trebuie ca destinatarul sa nu poata sa il refuze"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Non-repudiation in a network context ensures that once a message has been sent, the sender cannot deny having sent it. This is crucial for accountability and trust in communication systems. The correct answer is B because it captures the essence of non-repudiation: preventing the sender from denying their action after the message has been transmitted. Option C relates more to the acceptance of the message by the recipient, which is not the focus of non-repudiation. Option A is incorrect as it pertains to accepting a message, not the inability to deny having sent it."
        },
        {
          "id": 5,
          "text": "Criptologia reprezinta",
          "options": {
            "A": "o metoda de codificare a mesajelor",
            "B": "o metoda de analiza a corectitudinii mesajelor criptate",
            "C": "un mod de criptare",
            "D": "un mod de decriptare",
            "E": "cumulul dintre criptare si analiza criptografica"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Criptologia este un domeniu care cuprinde atât criptografia, cât și criptoanaliza. Criptografia se ocupă de crearea și implementarea metodelor de criptare pentru a asigura confidențialitatea și securitatea mesajelor, în timp ce criptoanaliza se concentrează pe studierea și spargerea acestor metode pentru a analiza corectitudinea și securitatea mesajelor criptate. Prin urmare, criptologia reprezintă cumulul dintre criptare (criptografie) și analiza criptografică (criptoanaliză), ceea ce face ca răspunsul corect să fie E."
        },
        {
          "id": 6,
          "text": "Criptografia este",
          "options": {
            "A": "o metoda de analiza a datelor",
            "B": "un sistem de regasire a mesajelor in clar din mesaje criptate",
            "C": "stiinta matematica care asigura confidentialitatea datelor"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Cryptography is fundamentally the mathematical science that ensures data confidentiality. It involves techniques and methods to encrypt information, making it accessible only to those with the proper authorization or decryption key. This is distinct from data analysis (option A) and retrieving plain text from encrypted messages (option B), which are not primary functions of cryptography. Instead, cryptography focuses on securing data from unauthorized access or alterations, thereby protecting sensitive information."
        },
        {
          "id": 7,
          "text": "Sistemul de criptare cu cheie simetrica foloseste",
          "options": {
            "A": "o cheie pentru criptare si una pentru decriptare, diferite",
            "B": "o cheie pentru criptare si una pentru decriptare, a doua fiind obtinuta prin transformarea primei chei",
            "C": "o cheie la criptare si una la decriptare, identice",
            "D": "o singura cheie, pentru criptare, decriptarea fiind facuta de destinatar, fara cheie"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Sistemul de criptare cu cheie simetrică utilizează aceeași cheie atât pentru criptarea, cât și pentru decriptarea datelor. Aceasta înseamnă că cheia folosită pentru a transforma mesajul clar într-un mesaj criptat este identică cu cea folosită pentru a transforma mesajul criptat înapoi în mesajul clar. Această metodă necesită ca atât expeditorul, cât și destinatarul să dețină aceeași cheie secretă, care trebuie păstrată în siguranță pentru a menține confidențialitatea informațiilor. De aceea, răspunsul corect este C: o cheie la criptare și una la decript"
        },
        {
          "id": 8,
          "text": "Criptarea de tip stream este o criptare",
          "options": {
            "A": "simetrica, cu doua chei diferite",
            "B": "asimetrica, cu o singura cheie",
            "C": "nu este o criptare, este o codificare",
            "D": "este inversa criptarii de tip bloc",
            "E": "simetrica"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Stream cipher encryption is a type of symmetric encryption because it uses the same key for both encryption and decryption. In symmetric encryption, both the sender and receiver share the same secret key, which is used to encrypt and decrypt the data. Stream ciphers encrypt data one bit or byte at a time, making them different from block ciphers, which encrypt data in fixed-size blocks. Therefore, the correct answer is E."
        },
        {
          "id": 9,
          "text": "Criptarea de tip bloc, este",
          "options": {
            "A": "o criptare asimetrica, cu doua chei identice",
            "B": "o criptare asimetrica",
            "C": "o codificare a mesajului, pentru autentificare",
            "D": "un mod de semnare",
            "E": "o criptare simetrica"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Block cipher encryption is a type of symmetric encryption, meaning it uses the same key for both encryption and decryption. This method processes data in fixed-size blocks, transforming them into ciphertext blocks of the same size. Unlike asymmetric encryption, which uses a pair of public and private keys, symmetric encryption like block ciphers relies on a single, shared secret key for both parties involved. This makes option E the correct answer, as it accurately describes block cipher encryption."
        },
        {
          "id": 10,
          "text": "Sniffer este un termen care defineste",
          "options": {
            "A": "un sistem criptografic simetric",
            "B": "un sistem criptografic asimetric",
            "C": "un mod de analiza a puterii unui algoritm criptografic",
            "D": "un mod de analiza a datelor transferate intr-o retea de calculatoare"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "A \"sniffer\" is a tool or software used to monitor and analyze data as it is transmitted over a computer network. It captures network packets and decodes the data for analysis, allowing users to understand the information being sent and received. This can be useful for network troubleshooting, security analysis, and network management. Unlike the other options, which relate to cryptographic methods, a sniffer focuses specifically on observing and analyzing network traffic, making option D the correct answer."
        },
        {
          "id": 11,
          "text": "SSL si TLS sunt",
          "options": {
            "A": "unul si acelasi protocol",
            "B": "doua protocoale criptografice pentru retele",
            "C": "doua modele de criptare locale, al doilea se bazeaza pe primul"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "SSL (Secure Sockets Layer) și TLS (Transport Layer Security) sunt două protocoale criptografice utilizate pentru a securiza comunicațiile în rețelele de calculatoare, cum ar fi internetul. SSL a fost inițial dezvoltat de Netscape și a evoluat în timp, iar TLS a fost introdus ca succesor al SSL pentru a oferi îmbunătățiri de securitate și performanță. Deși TLS este bazat pe SSL și îndeplinește funcții similare, ele sunt versiuni distincte, nu sunt unul și același protocol, și nu sunt modele de criptare locale. De aceea, opțiunea corectă este B, care men"
        },
        {
          "id": 12,
          "text": "Intr-o retea de calculatoare un sniffer are acces la datele",
          "options": {
            "A": "toate datele care tranziteaza reteaua",
            "B": "datele de la computerele legate indirect la acelasi server",
            "C": "datele din computerele care sunt in aceeasi zona geografica",
            "D": "datele de la computerelec are comunica in orice fel cu un computer care ares niffer instalat",
            "E": "datele din subreteaua primului switch de deasupra sa, in ierahia retelei"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "In a computer network, a sniffer is a tool used to monitor and capture data packets as they travel across a network. The answer to this question is E because a sniffer typically captures packets within the same subnet or network segment to which it is connected. In most network configurations, a switch is used to connect multiple devices in a local area network (LAN). The sniffer can capture data packets only from the devices connected to the same switch unless it has additional privileges or capabilities to intercept data from other parts of the network. Therefore, the sniffer has access to data within the subnetwork managed by the first switch directly above it in the network hierarchy."
        },
        {
          "id": 13,
          "text": "O semnatura electronica are la baza",
          "options": {
            "A": "un algoritm simetric de criptare",
            "B": "un algoritm asimetric de criptare, in care semnatarul foloseste cheia publica",
            "C": "un algoritm asimetric de criptare, in care semnatarul foloseste cheia privata",
            "D": "o cheie pentru fiecare utilizator si fiecare mesaj"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "A digital signature is based on an asymmetric encryption algorithm, where the signer uses their private key to create the signature. This ensures that the signature is unique to the signer and can be verified by anyone with access to the corresponding public key. Option C is correct because it accurately describes this process, where the private key is used to sign the message, providing authenticity and integrity."
        },
        {
          "id": 14,
          "text": "O retea de calculatoare are ca mod de comunicare standard un modul numit placa de retea. \nAceasta comunica date",
          "options": {
            "A": "criptat, cu un algoritm simetric",
            "B": "criptat, cu un algoritm asimetric",
            "C": "semnate de destinatar",
            "D": "in clar"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The correct answer is D: \"in clar.\"\n\nExplanation: In a standard computer network, network interface cards (NICs) are responsible for facilitating communication between computers. By default, data transmitted over the network is sent \"in clear,\" meaning it is not encrypted. This is because basic network communication does not inherently include encryption processes. Options A and B involve encryption methods (symmetric and asymmetric algorithms), which are not standard features of basic network communication through a network card. Option C refers to data being signed by the recipient, which is not a standard practice in network communication either. Therefore, the correct choice is that data is communicated in its clear, unencrypted form unless additional security measures are explicitly implemented."
        }
      ]
    },
    {
      "name": "Baze de Date",
      "questions": [
        {
          "id": 1,
          "text": "Intre avantajele bazelor de date se numara:",
          "options": {
            "A": "nepartajarea datelor intre utilizatori",
            "B": "organizarea datelor pe doua niveluri - fizic si logic",
            "C": "gestionarea centralizata a datelor printr-un SGBD",
            "D": "integrarea in aceeasi structura a tuturor datelor pertinente ale unui sistem informatic",
            "E": "independenta datelor fata de programele de aplicatii"
          },
          "correct_answer": [
            "B",
            "C",
            "E"
          ],
          "explanation": "B. Organizarea datelor pe două niveluri - fizic și logic: Acest avantaj se referă la separarea modului în care datele sunt stocate fizic de modul în care sunt percepute logic, permițând o gestionare mai flexibilă și eficientă a datelor.\n\nC. Gestionarea centralizată a datelor printr-un SGBD: Sistemele de gestionare a bazelor de date (SGBD) permit centralizarea datelor, ceea ce facilitează administrarea, securitatea și accesul controlat la date de către utilizatori.\n\nE. Independența datelor față de programele de aplicații: Acest avantaj indică faptul că modificările în structura"
        },
        {
          "id": 2,
          "text": "O entitate se caracterizeaza prin:",
          "options": {
            "A": "este identificata unic printr-un nume",
            "B": "cuprinde, in general, mai multe valori sau realizari",
            "C": "administreaza obiecte",
            "D": "semnifica un obiect concret sau abstract, reprezentat prin proprietatile sale",
            "E": "semnifica o caracteristica a unui obiect concret"
          },
          "correct_answer": [
            "A",
            "B",
            "D"
          ],
          "explanation": "O entitate este un concept fundamental în modelarea datelor și se referă la un obiect sau un lucru care poate fi identificat în mod unic și despre care vrem să stocăm informații. \n\nA. Este identificată unic printr-un nume - Această opțiune este corectă deoarece fiecare entitate trebuie să aibă un identificator unic, cum ar fi un nume sau un ID, care o distinge de alte entități.\n\nB. Cuprinde, în general, mai multe valori sau realizări - Această opțiune este corectă deoarece o entitate este de obicei descrisă printr-un set de atribute sau proprietăți, fiecare având valori"
        },
        {
          "id": 3,
          "text": "O entitate din modelul Entitate-Asociere are urmatoarele caracteristici:",
          "options": {
            "A": "are o existenta proprie",
            "B": "este intotdeauna concreta",
            "C": "trebuie definita fara ambiguitati",
            "D": "este intotdeauna legata de o alta entitate printr-o asociatie",
            "E": "este identificata unic prin ansamblul atributelor sale"
          },
          "correct_answer": [
            "C",
            "E"
          ],
          "explanation": "In modelul Entitate-Asociere (Entity-Relationship, ER), o \"entitate\" reprezintă un obiect distinct sau un concept din lumea reală care poate fi identificat și descris în sistemul de baze de date. \n\nC. trebuie definita fara ambiguitati: Entitățile trebuie să fie clar definite pentru a evita confuziile și pentru a asigura integritatea datelor. Fiecare entitate trebuie să fie descrisă astfel încât să nu existe dubii cu privire la ceea ce reprezintă.\n\nE. este identificata unic prin ansamblul atributelor sale: Fiecare entitate trebuie să aibă unul sau mai multe atribute care să permit"
        },
        {
          "id": 4,
          "text": "Administratorul bazei de date asigura:",
          "options": {
            "A": "scrierea programelor in cod-masina",
            "B": "autorizarea accesului la date",
            "C": "realizarea obiectivelor si functiilor sistemului",
            "D": "definirea strategiei de salvare si restaurare a bazei de date",
            "E": "crearea programelor de aplicatii"
          },
          "correct_answer": [
            "B",
            "D"
          ],
          "explanation": "In the context of database management, a database administrator (DBA) is responsible for ensuring the security and integrity of data within a database. Option B, \"autorizarea accesului la date\" (authorizing access to data), refers to controlling who can access or modify the data, which is a key responsibility of a DBA to maintain data security and privacy. Option D, \"definirea strategiei de salvare si restaurare a bazei de date\" (defining the database backup and recovery strategy), involves planning and implementing procedures to back up data and restore it in case of data loss, ensuring data availability and durability. These tasks are critical for the proper management and operation of a database, aligning with the core duties of a database"
        },
        {
          "id": 5,
          "text": "Se da tabelul: ANGAJATI (CodAngaj, Nume, DataAngajare, Compartiment, Profesia, Salariu) Care dintre urmatoarele instructiuni SQL permite afisarea numarului de salariati pe fiecare com- partiment care incepe cu litera ”A”?",
          "options": {
            "A": "SELECT CodAngajat, Nume, Compartiment FROM ANGAJATI WHERE Nume like A* ;",
            "B": "SELECT COUNT(CodAngajat) AS Numar, Nume, Compartiment FROM ANGAJATI WHERE Nume like \"A*\" GROUP BY Compartiment ;",
            "C": "SELECT CodAngajat, Nume, Compartiment FROM ANGAJATI WHERE Compartiment like A*;",
            "D": "SELECT COUNT(CodAngajat) AS Numar, Compartiment FROM ANGAJATI WHERE Compartiment like \"A*\" GROUP BY Compartiment;",
            "E": "Niciuna dintre cele de mai sus"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The correct answer is D.\n\nExplanation: The question asks for an SQL statement that displays the number of employees in each department (compartiment) where the department's name starts with the letter \"A\". \n\n- Option A is incorrect because it selects individual columns without aggregating the count per department.\n- Option B is incorrect because it groups by \"Compartiment\" but incorrectly uses a filter on \"Nume\" with a wildcard syntax that is not valid in SQL (A* should be 'A%').\n- Option C is incorrect because it selects individual columns without counting the employees or grouping by department.\n- Option D is the correct choice because it counts the number of employees per department (using COUNT(CodAngajat)) and groups the results by"
        },
        {
          "id": 6,
          "text": "Urmatoarele operatii sunt echivalente:",
          "options": {
            "A": "R3= R1U R2 si R3= APPEND(R1,R2);",
            "B": "R3= R1-R2 si R3 = R1 OR R2;",
            "C": "R3 = R1XR2 si R3 = PRODUCT(R1,R2);",
            "D": "R3=R1U R2 si R3= UNION(R1,R2);",
            "E": "R3=R1-(R1-R2) si AND(R1,R2);"
          },
          "correct_answer": [
            "C",
            "D",
            "E"
          ],
          "explanation": "The question is about determining which operations on sets or relations are equivalent. Here's a brief explanation of why options C, D, and E are correct:\n\nC. R3 = R1 × R2 and R3 = PRODUCT(R1, R2):\n   - Both operations describe the Cartesian product of two sets or relations, pairing every element of R1 with every element of R2. Thus, they are equivalent.\n\nD. R3 = R1 ∪ R2 and R3 = UNION(R1, R2):\n   - Both operations describe the union of two sets or relations, which combines all unique elements from R1 and R2 into R3. Therefore, they are equivalent.\n\nE. R3 = R1 - (R"
        },
        {
          "id": 7,
          "text": "Se da tabelul:\nCHITANTE (NrChitanta, Suma, DataChitanta, NrGhiseu )\nCare dintre urmatoarele instructiuni SQL are ca efect afisarea zilelor in care s-au emis mai mult de\n2 chitante?\n",
          "options": {
            "A": "SELECT Nrchitanta, Suma, Data FROM CHITANTE WHERE COUNT(NrChitanta)>2;",
            "B": "SELECT Nrchitanta, Suma, Data FROM CHITANTE HAVING COUNT(NrChitanta)>2;",
            "C": "SELECT CHITANTE.Data FROM CHITANTE GROUP BY Data HAVING COUNT(NrChitanta)>2;",
            "D": "SELECT COUNT(Data), COUNT(NrChitanta) FROM CHITANTE WHERE Data IS Unique;",
            "E": "SELECT Data FROM CHITANTE WHERE COUNT(NrChitanta) > 2;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To determine the days on which more than two receipts (\"chitante\") were issued, we need to group the data by the date (`DataChitanta`) and then count the number of receipts (`NrChitanta`) for each date. The SQL statement that achieves this is:\n\nC. `SELECT CHITANTE.Data FROM CHITANTE GROUP BY Data HAVING COUNT(NrChitanta)>2;`\n\nExplanation:\n- `GROUP BY Data`: This clause groups the records in the `CHITANTE` table by the `DataChitanta` column, which represents the date.\n- `HAVING COUNT(NrChitanta) > 2`: The `HAVING` clause filters the groups created by `GROUP BY"
        },
        {
          "id": 8,
          "text": "Se da entitatea ANGAJATI, cu urmatoarele atribute: ANGAJATI (CodAngaj, Nume, DataAngajare, compartiment, profesia, salariu) CaredintreurmatoareleinstructiuniSQLpermitestergereasalariatilorangajatiinaintedeinceputul anului 2007, cu profesia ”profesor”.",
          "options": {
            "A": "DELETE FROM Angajati WHERE DataAngajare < ”1/1/2006” AND profesia = ”pro- fesor” ;",
            "B": "DELETE*FROMAngajatiWHEREprofesiaLIKE”profesor”HAVINGYEAR(DataAngajare) <2007;",
            "C": "DELETEAngajatiWHEREDataAngajare<\"1/1/2007\"ANDprofesiaLIKE \"*profesor*\";",
            "D": "UPDATE Angajati SET CodAngaj = Null WHERE DataAngajare < ”1/1/2006” AND profesia = ”profesor”;",
            "E": "niciuna"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The correct answer is C. Let's break down why:\n\nThe question asks for the SQL statement that will delete employees (salariați) who were hired before the beginning of 2007 and have the profession \"profesor.\" \n\n- Option A incorrectly uses a date comparison for before \"1/1/2006\" rather than \"1/1/2007.\"\n- Option B uses an incorrect syntax by combining WHERE and HAVING clauses inappropriately, and also uses a function (YEAR) that is not typically used this way in a DELETE statement.\n- Option C correctly specifies the condition for deletion: employees hired before \"1/1/2007\" with a profession similar to \"profesor.\" The use of the LIKE operator with wildcard"
        },
        {
          "id": 9,
          "text": "Fie tabelul proiecte(CodProiect;CodAng;functie;suma)cu cheia(CodProiect;CodAng), de sto- care a informatiilor privind repartizarea pe proiecte a salariatilor unei firme. Suma obtinuta de- pindede CodAng si de functia inacel proiect (CodAng;functie)!suma. Aplicand a doua forma normala care din schemele urmatoare este corecta?",
          "options": {
            "A": "R1=(CodProiect,CodAng,functie),R2=(CodProiect,functie,suma)",
            "B": "R1=(CodProiect,CodAng, suma), R2=(CodAng,functie)",
            "C": "R1=(CodProiect,CodAng, suma), R2=(CodProiect,functie)",
            "D": "R1=(CodProiect,CodAng), R2=(CodProiect,functie)",
            "E": "Niciuna"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To determine the correct schema in the context of the second normal form (2NF), we need to ensure that all non-key attributes are fully functionally dependent on the primary key. In the given table, the primary key is (CodProiect, CodAng), and it is mentioned that the \"suma\" (amount) depends on CodAng and \"functie\" (role). This suggests that \"functie\" is partially dependent on CodAng, which violates 2NF since it is not fully dependent on the whole primary key. \n\nTo achieve 2NF, we need to eliminate partial dependencies by creating separate tables:\n\n- In option A, the first table R1=(CodProiect, CodAng, functie) breaks down the dependency of"
        },
        {
          "id": 10,
          "text": "Fie relatia r de schema R si X ⊂  R, Y ⊂  R si dependenta tranzitiva K -> X -> Y. Care din urmatoarele descompuneri sunt in forma normala trei?",
          "options": {
            "A": "R1=K(R-Y), R2=(KY)",
            "B": "R1=K(R-Y), R2=(XY)",
            "C": "R1=K(R-Y), R2=(XX)",
            "D": "R1=(R-Y), R2=(XX)",
            "E": "R1=KY, R2=(XX)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "To determine which decomposition is in Third Normal Form (3NF), we need to ensure that the decomposition satisfies the conditions of 3NF, which are:\n\n1. The relation must be in Second Normal Form (2NF).\n2. Every non-prime attribute (an attribute that is not part of any candidate key) must depend only on the candidate keys, and not on any other non-prime attribute (i.e., there should be no transitive dependencies).\n\nGiven the transitive dependency K -> X -> Y, we want to decompose the relation such that these dependencies are preserved, and no transitive dependencies exist.\n\nIn option B, R1=K(R-Y) and R2=(XY), the decomposition is structured such that:\n\n-"
        },
        {
          "id": 11,
          "text": "Fie relatia r de schema R, X ⊂ R, Y ⊂ R, Z = R - XY si dependenta multivoca X ->> Y. Care din urmatoarele descompuneri sunt in forma normala patru?",
          "options": {
            "A": "R1=XZ , R2=(XY)",
            "B": "R1=XZ, R2=(X)",
            "C": "R1=K(R-Y), R2=(XZ)",
            "D": "R1=XY, R2=(XZ)",
            "E": "R1=KX, R2=(XZ)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To determine which decomposition is in the fourth normal form (4NF), we need to consider the multivalued dependency (MVD) X ->> Y. The 4NF requires that for every non-trivial multivalued dependency X ->> Y in a relation, X must be a superkey, or the relation must be decomposed.\n\nIn the given options, we have the relation R, with subsets X, Y, and Z = R - XY, and the multivalued dependency X ->> Y.\n\nIn decomposition A: \n- R1 = XZ and R2 = XY.\n- R1 (XZ) includes X but excludes Y, while R2 (XY) includes both X and Y.\n- This decomposition ensures"
        },
        {
          "id": 12,
          "text": "Fie tabelul Studenti(NrLeg, LimbaStraina, M asina)\n111 Engleza Logan\n111 Franceza Logan\n111 Spaniola Logan\n111 Engleza Cielo\n111 Franceza Cielo\n112 Engleza Logan\n112 Franceza Logan\nsi dependentele multivoce NrLeg \u0010 LimbaStraina, NrLeg \u0010 M asina. Care este reprezentarea\nFN4 determinata de aceste MV-dependente.",
          "options": {
            "A": "R1= NrLeg, LimbaStraina, R2= NrLeg, Masina",
            "B": "R1= Masina,LimbaStraina, R2= NrLeg, LimbaStraina,",
            "C": "R1= NrLeg,LimbaStraina R2= NrLeg,LimbaStraina,Masina",
            "D": "R1= NrLeg,Masina R2= NrLeg,LimbaStraina",
            "E": "R1= NrLeg,Masina R2= NrLeg,LimbaStraina,Masina"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In the given scenario, we have a table called \"Studenti\" with attributes NrLeg, LimbaStraina, and Masina. We are provided with multivalued dependencies (MVDs) NrLeg →→ LimbaStraina and NrLeg →→ Masina. \n\nTo achieve Fourth Normal Form (4NF), a relation must have no non-trivial multivalued dependencies other than a candidate key. This means we need to decompose the table in such a way that each relation in the decomposition has at most one non-trivial multivalued dependency.\n\nGiven the MVDs:\n1. NrLeg →→ LimbaStraina\n2. NrLeg →→ Masina\n\nWe decompose the original table into two"
        },
        {
          "id": 13,
          "text": "Restrictiile referentiale intre 2 tabele sunt date de:",
          "options": {
            "A": "Cheile primare si cheile externe",
            "B": "Coloanele commune",
            "C": "Coloanele din clauza CHECK",
            "D": "Coloanele din SELECT",
            "E": "Chei externe"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. Cheile primare și cheile externe (Primary keys and foreign keys) are fundamental components of referential integrity in relational databases. Referential integrity is a concept that ensures relationships between tables remain consistent. A primary key is a unique identifier for each record in a table, while a foreign key is a field (or a collection of fields) in one table that uniquely identifies a row of another table. The foreign key creates a link between the two tables, ensuring that any value in the foreign key column corresponds to a value in the primary key column of the related table. This mechanism enforces the integrity and accuracy of the data across the tables."
        },
        {
          "id": 14,
          "text": "Fie baza de date formata din tabelele: studenti(NrLeg, Nume, Pren, Fac,An,grupa) cataloage(NrLeg,CodDis,dat,nota), discipline(CodDis,Denumire,NrOreC, NrOreL, NrOreS, NrOreP,Credite,An,Sectie). Care din expresiile algebrei relationale determina studentii din anul II:",
          "options": {
            "A": "πAn(studenti)",
            "B": "σAn=2(studenti)",
            "C": "πAn(σAn=2(studenti))",
            "D": "σAn(πAn=2(studenti))",
            "E": "πNume(studenti)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In algebra relațională, simbolurile și operatorii sunt folosiți pentru a manipula și interoga baze de date relaționale. În acest context:\n\n- Operatorul σ (sigma) reprezintă selecția, care se folosește pentru a extrage rândurile (tuples) dintr-o relație care satisfac o anumită condiție.\n- În expresia σAn=2(studenti), operatorul σ este utilizat pentru a selecta doar acei studenți din tabelul \"studenti\" care sunt în anul II (An=2).\n\nAlte opțiuni nu sunt corecte pentru că:\n\n- A. πAn(studenti) ar returna doar o proiecție a"
        },
        {
          "id": 15,
          "text": "Pentru o baza de date relationala algebra relationala este:",
          "options": {
            "A": "Completa (permite sa extrag orice informatii din baza)",
            "B": "Procedurala (Arata si modul cum se obtin informatiile din baza de date)",
            "C": "Complexa (permite sa extrag informatii obiectuale)",
            "D": "Limbaj formal",
            "E": "Limbaj de interogare"
          },
          "correct_answer": [
            "A",
            "B",
            "D",
            "E"
          ],
          "explanation": "The question pertains to the characteristics of relational algebra in the context of relational databases. Here's a short explanation for each correct option:\n\nA. Completa (permite sa extrag orice informatii din baza) - Relational algebra is considered complete because it provides a set of operations that can be used to query and manipulate data in any manner necessary to extract all possible information from a relational database.\n\nB. Procedurala (Arata si modul cum se obtin informatiile din baza de date) - Relational algebra is procedural, meaning it specifies a sequence of operations to be performed to retrieve the desired data. It describes how the result can be obtained, unlike declarative languages that focus on what result is needed.\n\nD. Limbaj formal -"
        },
        {
          "id": 16,
          "text": "Restrictiile date de dependentele functionale pentru un tabel se testeaza cu ajutorul:",
          "options": {
            "A": "Axiomelor de inferenta",
            "B": "Algoritmul de satisfacere(satisfie)",
            "C": "Algoritmul de inchidere",
            "D": "Algoritmul de sortare",
            "E": "Algoritmul de normalizare"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The correct answer is B. Algoritmul de satisfacere (satisfie) because it is specifically designed to test whether a set of functional dependencies can be satisfied or maintained within a given database schema. This involves checking if the dependencies hold true for the data in the table. This process ensures that the constraints imposed by the functional dependencies are adhered to, which is essential for maintaining data integrity and consistency. The other options, such as axioms of inference, closure algorithms, sorting algorithms, and normalization algorithms, serve different purposes in database management and are not directly used for testing functional dependency constraints."
        },
        {
          "id": 17,
          "text": "Fiind data apriori o multime de restrictii data de o multime de dependente funtionale F. Elaborarea\nunei reguli de validare pentru o dependenta functionala X → Y presupune:",
          "options": {
            "A": "Verificarea deductibilitatii din F",
            "B": "Verificarea incluziunii X ⊂ Y",
            "C": "Verificarea incluziunii X ⊂ X+",
            "D": "Normalizarea schemei de relatie XY",
            "E": "Toate"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "To elaborate a validation rule for a functional dependency \\( X \\rightarrow Y \\), we need to ensure that this dependency is consistent with the given set of functional dependencies \\( F \\).\n\n- **A. Verificarea deductibilitatii din F**: This means checking if the dependency \\( X \\rightarrow Y \\) can be logically deduced from the set \\( F \\). This ensures that the dependency is valid according to the existing constraints.\n\n- **C. Verificarea incluziunii X \\subseteq X^+**: This involves checking if the set \\( X \\) is included in its closure \\( X^+ \\) with respect to \\( F \\). This is always true by definition, but in the context of validation,"
        },
        {
          "id": 18,
          "text": "Fiind data apriori o multime de restrictii data de o multime de dependente funtionale F. Elaborarea\nunei proceduri pentru a verifica dependenta functionala X → Y presupune mai intai:",
          "options": {
            "A": "Verificarea redundantei acesteia",
            "B": "Inlaturarea atributelor eliminabile din determinantul X",
            "C": "Inlaturarea atributelor eliminabile din determinantul Y",
            "D": "Inlaturarea atributelor eliminabile din X si Y",
            "E": "Niciuna"
          },
          "correct_answer": [
            "A",
            "B",
            "C",
            "D"
          ],
          "explanation": "To verify a functional dependency \\( X \\rightarrow Y \\) given a set of functional dependencies \\( F \\), the process involves ensuring the dependency is both necessary and irreducible. This includes checking for redundancy and simplifying the attributes involved. Here's a brief explanation for each step:\n\nA. **Verificarea redundantei acesteia**: This involves checking if the dependency \\( X \\rightarrow Y \\) is redundant when considering the other dependencies in \\( F \\). If it can be derived from other dependencies, it may be unnecessary to include it explicitly.\n\nB. **Inlaturarea atributelor eliminabile din determinantul X**: This step involves removing any attributes from the determinant \\( X \\) that do not affect the dependency. If \\("
        },
        {
          "id": 19,
          "text": "Fiind data apriori o multime de restrictii data de o multime de dependente funtionale F. Aceasta este folosita la:",
          "options": {
            "A": "Normalizarea bazei de date",
            "B": "La validarea starii bazei de date",
            "C": "Crearea bazei de date",
            "D": "Crearea procedurilor de interogare",
            "E": "Constructia algebrei relationale"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "In the context of databases, a set of functional dependencies (F) is crucial for understanding and organizing the data structure. Here's a brief explanation for each option:\n\nA. Normalizarea bazei de date (Normalization of the database): Functional dependencies are fundamental in database normalization, which is the process of organizing a database to reduce redundancy and improve data integrity. They help determine the normal forms of a database schema by identifying the relationships between different attributes.\n\nB. La validarea starii bazei de date (Validation of the database state): Functional dependencies are used to ensure that the current state of the database adheres to certain rules and constraints. By validating these dependencies, one can check if the data in the database is consistent with the defined rules, ensuring data"
        },
        {
          "id": 20,
          "text": "Interogarile din SQL sunt la fel de expresive cu:",
          "options": {
            "A": "Algebra relationala",
            "B": "Calculul relational al tuplurilor",
            "C": "Calculul relational al domeniilor",
            "D": "Calculul procedural",
            "E": "Calculul bazat pe tablouri"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "In SQL, queries are designed to be as expressive as those in relational algebra and relational calculus. Relational algebra provides a procedural way to query databases, focusing on operations like selection, projection, and joins. Relational calculus, on the other hand, is non-procedural and comes in two forms: tuple relational calculus (TRC) and domain relational calculus (DRC). Both TRC and DRC describe what results are desired without specifying how to compute them. SQL combines the expressiveness of these approaches, allowing users to efficiently retrieve and manipulate data. Therefore, SQL queries are as expressive as those in relational algebra (A), tuple relational calculus (B), and domain relational calculus (C). Calculul procedural (D) and calculul baz"
        }
      ]
    },
    {
      "name": "Fundamentele bazelor de date",
      "questions": [
        {
          "id": 1,
          "text": "O baza de date distribuita este:",
          "options": {
            "A": "O colectie de date si de scheme partajate si interconectate logic, distribuite fizic pe calculatoarele unei retele,",
            "B": "O colectie de date impartita in mai multe fragmente,",
            "C": "O colectie de date impartita in mai multe replici,",
            "D": "O colectie de fragmente mixte.",
            "E": "Niciuna."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "A distributed database is a system where the database is not stored in a single location but is spread across multiple computers or sites connected by a network. Option A correctly defines this by stating that it is a \"collection of data and schemas that are shared and logically interconnected, physically distributed across the computers of a network.\" This means that while the data is physically separated, it is logically integrated to function as a single database system. Thus, the correct answer is A, as it captures the essence of what a distributed database is meant to achieve: decentralized storage with centralized access and management."
        },
        {
          "id": 2,
          "text": "O tranzactie este:",
          "options": {
            "A": "O unitate de program ce realizeaza citiri si scrieri,",
            "B": "O multime finita si ordonata de operatii de citire, scriere si terminare,",
            "C": "O multime de instructiuni executabile dintr-un limbaj gazda,",
            "D": "O serie finita de opeartii de modificare a datelor dintr-o baza de date ORACLE",
            "E": "O multime finita de operatii coerente, executate de un SGBD, care\n manipuleaza datele unei baze de date."
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "The correct answer is E because a transaction in the context of a database management system (SGBD - Sistem de Gestiune a Bazelor de Date) refers to a finite set of coherent operations that are executed to manipulate data within a database. Transactions ensure that database operations are completed successfully and maintain data integrity, typically following the ACID properties (Atomicity, Consistency, Isolation, Durability). Option E best captures this definition by emphasizing the coherence and finite nature of these operations as well as their execution by a database management system. Other options either do not fully encompass the concept of a transaction or describe related but distinct processes."
        },
        {
          "id": 3,
          "text": "Numele unei coloane dintr-un tabelin ORACLE :",
          "options": {
            "A": "trebuie sa fie unic in cadrul tabelului,",
            "B": "trebuie sa fie unicin cadrul bazei de date,",
            "C": "are asociat un index ,",
            "D": "trebuie sa aparaa in instructiunea CREATE TABLE,",
            "E": "rebuie sa fie specificat a in instructiunea ALTER TABLE."
          },
          "correct_answer": [
            "A",
            "D"
          ],
          "explanation": "In Oracle, the name of a column in a table must adhere to certain rules to ensure proper database management and integrity. \n\nA. The column name must be unique within the table to avoid confusion and ensure that each column can be distinctly identified by its name. This uniqueness requirement is specific to the table, allowing for the same column name to exist in different tables within the same database.\n\nD. A column name must appear in the CREATE TABLE statement because this is where the table's structure is defined, including its columns and their respective data types. Without specifying the column names and types in the CREATE TABLE statement, the table cannot be properly created or used.\n\nOptions B, C, and E are incorrect because:\n- B. Column names do not have"
        },
        {
          "id": 4,
          "text": "O tranzactie urmeaza un protocol in doua faze daca:",
          "options": {
            "A": "Blocheaza accesul la un element de date,",
            "B": "Toate opratiile de blocare preced prima operatie de deblocare,",
            "C": "Cere mai intai deblocarea si apoi realizeaza blocarea accesului la un element de date,",
            "D": "Blocheaza tabelul la care are acces,",
            "E": "Blocheaza accesul altor utilizatori la o baza de date."
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The correct answer, B, refers to the two-phase locking protocol, which is a concurrency control method used in database systems to ensure transaction serializability. In this protocol, a transaction follows two distinct phases:\n\n1. **Growing Phase**: During this phase, the transaction can acquire locks but cannot release any locks. This ensures that all necessary locks are obtained before any data is modified.\n\n2. **Shrinking Phase**: Once the transaction releases its first lock, it enters the shrinking phase, where it can no longer acquire any new locks. \n\nOption B, stating that all lock operations precede the first unlock operation, accurately describes this two-phase behavior, ensuring that transactions are executed in a serializable manner without causing conflicts or inconsistencies in"
        },
        {
          "id": 5,
          "text": "Proprietatea de consistenta a tranzactiei consta din:",
          "options": {
            "A": "Transformarea unei stari consistente intr-o stare consistenta,",
            "B": "Eliminarea redundantelor,",
            "C": "Izolarea tranzactiilor in executie,",
            "D": "Transparenta,",
            "E": "Durabilitate."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The property of consistency in a transaction refers to the principle that a database transaction must transition the database from one valid state to another valid state. This means that if the database is in a consistent state before the transaction begins, it must remain in a consistent state after the transaction completes, assuming no other transactions are interfering. This is crucial for maintaining the integrity of the data. Therefore, the correct answer is A, as it directly addresses the transformation of a consistent state into another consistent state."
        },
        {
          "id": 6,
          "text": "Un cursor este:",
          "options": {
            "A": "Un pointer catre un set de rezultate,",
            "B": "un set de rezultate ale instructiunii select,",
            "C": "o metoda de analiza a performantei,",
            "D": "o colectie de randuri ale unei tabele,",
            "E": "Sun buffer care pastreaza rezultatul unei istructiuni SELECT."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "A cursor is a database object used to retrieve, manipulate, and navigate through a set of results returned by a query. It acts as a pointer to the result set, allowing row-by-row processing. This makes option A the correct choice, as it accurately describes the cursor's role in database management. A cursor is not the result set itself (B), nor is it a method for performance analysis (C), a collection of table rows (D), or a buffer for storing query results (E)."
        },
        {
          "id": 7,
          "text": "Abordarea distribuita a unei baze de date oglindeste:",
          "options": {
            "A": "Structura organizationala,",
            "B": "Paralelismul prelucrarilor",
            "C": "Gestiunile locale ale bazelor de date,",
            "D": "Seriabilitatea tranzactiilor,",
            "E": "Toate."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. A distributed database approach mirrors the organizational structure because it allows different parts of an organization to manage and access their data independently while still being part of a larger, cohesive system. This structure can reflect the geographic, functional, or departmental divisions within the organization, enabling localized control and efficiency while maintaining overall data integrity and coordination."
        },
        {
          "id": 8,
          "text": "O baza de date distribuita se gaseste implementata numai:",
          "options": {
            "A": "Intr-o retea de calculatoare,",
            "B": "Pe un calculator performant,",
            "C": "Pe mai multe calculatoare izolate, conectate la Internet,",
            "D": "Pe un Calculator client,",
            "E": "Pe un laptop."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "A distributed database is implemented across multiple locations, primarily to enhance performance, reliability, and availability. Option A, \"Intr-o retea de calculatoare\" (In a network of computers), is correct because a distributed database requires the coordination and communication between multiple computers within a network to manage and store data. This setup allows the database to be distributed across different nodes, ensuring that even if one node fails, the data can still be accessed from other nodes in the network. Options B, C, D, and E do not provide the necessary infrastructure for a distributed database, as they suggest either isolated or singular computing environments."
        },
        {
          "id": 9,
          "text": "Tranzactiile se numesc in 2 faze daca :",
          "options": {
            "A": "Satisfac protocolul in 2 faze,",
            "B": "Sunt formate numai din citiri si scrieri,",
            "C": "Contin comenzile commit si rollback,",
            "D": "Contin 2 faze de executie,",
            "E": "Contin 2 faze, una de definire a datelor, si alta de prelucrare a lor."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In contextul bazelor de date, tranzacțiile „în 2 faze” se referă la un protocol specific de control al tranzacțiilor, cunoscut sub numele de protocolul în două faze (Two-Phase Commit Protocol). Acest protocol este utilizat pentru a asigura că toate părțile implicate într-o tranzacție distribuită sunt de acord să o finalizeze sau să o anuleze, menținând astfel integritatea datelor. Prima fază implică pregătirea și votul tuturor participanților pentru a comite sau a anula tranzacția, iar a doua fază se ocupă de finalizarea efectivă a tranzacției pe baza"
        },
        {
          "id": 10,
          "text": "Se dau tabelele\nPERSONAL(Marca, Numepren, Compart, Datasv, Salorar,Salorarco, Compart)\nPONTAJE(Marca, Data, Orelucrate, Oreco, Orenoapte, Oreabsnem)\nCe afiseaza urmatoarea interogare?\n\nWITH VENITURI AS\n(SELECT Numepren, SUM(Orelucrate*Salorar+Oreco*Salorarco) AS Venit_Baza\nFROM PONTAJE po INNER JOIN PERSONAL pe ON po.Marca=pe.Marca GROUP BY Numepren),\nrasp AS\n(SELECT MAX(SUM(Orelucrate*Salorar+Oreco*Salorarco)) AS Venit_Max from PONTAJE po\nINNER JOIN PERSONAL pe ON po.Marca=pe.Marca GROUP BY Numepren)\nSELECT Numepren,Venit_Baza from VENITURI INNER JOIN rasp ON Venit_Baza=Venit_Max",
          "options": {
            "A": "Venitul maxim al unui angajat dintr-un compartiment utilizand expresii tabela",
            "B": "Angajatul sau angajatii cu cel mai mare venit utilizand expresii tabela",
            "C": "Venitul de baza al unui angajat utilizand operatorul INNER JOIN",
            "D": "Veniturile angajatilorin ordine descrescatoare utilizand expresii tabela",
            "E": "Numele angajatului din fiecare compartiment cu venitul cel mai mare"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The query uses common table expressions (CTEs) to calculate and identify employees with the highest earnings. The first CTE, `VENITURI`, calculates the base earnings (`Venit_Baza`) for each employee by summing their regular and overtime work multiplied by their respective salary rates. The second CTE, `rasp`, determines the maximum earnings from these calculated sums. The final `SELECT` statement retrieves the names and base earnings of employees whose earnings match the maximum earnings calculated in `rasp`. Therefore, the query effectively identifies and displays the employee(s) with the highest earnings, which corresponds to option B: \"Angajatul sau angajatii cu cel mai mare venit utilizand expresii tabela\" (The employee or employees with"
        },
        {
          "id": 11,
          "text": "Se da tabelul\nPREZENTA(Marca, Data, Orelucrate, Oreco, Orenoapte, Oreabsnem)\nCe executa urmatoarea secventa?\n\nDECLARE an salarii.an\\%TYPE := 2015;\nluna salarii.luna\\%TYPE := 1;\nprima_zi DATE ; zi DATE; BEGIN prima_zi :=\nTO_DATE(’01/’||luna||’/’||an, ’DD/MM/YYYY’); zi:= prima_zi; WHILE\nzi <= LAST_DAY(prima_zi) LOOP IF RTRIM(TO_CHAR(zi,’DAY’)) IN\n(’SATURDAY’, ’SUNDAY’) THEN NULL;\n ELSE\n BEGIN\n  INSERT INTO pontaje (marca, data)\n   SELECT marca, zi FROM personal;\n   EXCEPTION\n   WHEN DUP_VAL_ON_INDEX THEN\n   DELETE FROM pontaje WHERE data=zi;\n   INSERT INTO pontaje (marca, data)\n   SELECT marca, zi FROM personal;\n END;\n END IF;\n  zi:=zi + 1;\n END LOOP;\n COMMIT;\n END;",
          "options": {
            "A": "Introduce inregistrari numai pentru zilele nelucratoare",
            "B": "Populeaza cu inregistrari tabela pe o luna dintr-un an",
            "C": "Nu populeaza tabela datorita exceptiei DUP-VAL-ON-INDEX",
            "D": "Daca se executa de doua ori succesiv, nu produce rezultate",
            "E": "Daca se executa de doua ori succesiv, dubleazainregistrarile din tabela"
          },
          "correct_answer": [
            "B",
            "D"
          ],
          "explanation": "The given PL/SQL block is designed to populate a table called `pontaje` for each working day of a specified month and year. Here's the breakdown of the sequence:\n\n1. **Initialization**: The variables `an` and `luna` are initialized with values `2015` and `1`, respectively. This means the operation is set for January 2015.\n\n2. **Date Calculation**: `prima_zi` is set to the first day of the specified month and year, and `zi` is initialized to this date.\n\n3. **Loop through Days**: The loop iterates over each day of the month (`zi <= LAST_DAY(prima_zi)`), incrementing `zi` by one day in"
        },
        {
          "id": 12,
          "text": "Se da tabelul \nSTUDENT(CNP, Nume, Grupa, Adresa) \nCare secventa creaza un view ce permite ca modificarilein tabela \nsa se reflecte automat siin view?",
          "options": {
            "A": "CREATE VIEW stud AS \nSELECT * FROM STUDENT WHERE Grupa IN (210,220);",
            "B": "CREATE VIEW emp_vu AS \nSELECT * FROM STUDENT WHERE Grupa IN (210,220) \nWITH READ ONLY;",
            "C": "CREATE VIEW stud AS \nSELECT * FROM STUDENT WHERE Grupa IN (210,220) \nWITH CHECK OPTION;",
            "D": "CREATE FORCE VIEW stud AS \nSELECT * FROM STUDENT WHERE Grupa IN (210,220);",
            "E": "CREATE FORCE VIEW stud AS \nSELECT * FROM STUDENT WHERE Grupa=210 OR GRUPA=220;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The correct answer is C. \n\nExplanation: In SQL, a view is a virtual table that is based on the result of a SELECT query. To ensure that changes made to the underlying table are reflected in the view, the view must support updates. The \"WITH CHECK OPTION\" clause in the view definition (option C) enforces that any updates or inserts made through the view must satisfy the view's defining conditions. This means that any modification in the underlying table that would result in a row being excluded from the view's condition (in this case, where `Grupa` is either 210 or 220) will not be allowed unless it still satisfies the condition. This ensures that the view always reflects the current state of the table according to"
        },
        {
          "id": 13,
          "text": "Se da tabelul \nSTUDENT(CNP, Nume, Grupa, Adresa) \nsi urmatoarea secventa ce reprezinta o tranzactie: \n\nCREATE table STUDENT_NOU ( CNP NUMBER, Nume VARCHAR2(30)); \nINSERT INTO STUDENT_NOU SELECT CNP, Nume from STUDENT; \nSavepoint s1; \nUPDATE STUDENT_NOU SET Nume = UPPER(Nume); \nSavepoint s2; \nDELETE FROM STUDENT_NOU; \nRollback to s2; \nDELETE FROM STUDENT_NOU WHERE CNP=100; \nUPDATE STUDENT_NOU SET Nume = ’Ionescu’; \nRollback to s2; \nUPDATE STUDENT_NOU SET Nume = ’Ionescu’ WHERE CNP=100; \nRollback; \n\nCare este rezultatul acestei tranzactii?",
          "options": {
            "A": "Nu avem linii in tabela",
            "B": "Avem un student cu numele Ionescu",
            "C": "Nu putem sa facem Rollback mai mult de o data pe un punct de reluare",
            "D": "Ultimul UPDATE esueaza deoarece studentul cu CNP-ul 100 a fost sters",
            "E": "Tranzactia esueaza deoarece avem mai multe puncte de reluare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The question involves a series of SQL operations performed on a database table, including the use of savepoints and rollbacks. Here's a breakdown:\n\n1. A new table `STUDENT_NOU` is created, and data is copied from the existing `STUDENT` table into `STUDENT_NOU`.\n2. A savepoint `s1` is created after the insertion.\n3. The `Nume` column in `STUDENT_NOU` is updated to uppercase for all entries, followed by another savepoint `s2`.\n4. All entries are deleted from `STUDENT_NOU`.\n5. A rollback to `s2` is executed, restoring the table to the state right after the names were converted to uppercase but before any"
        },
        {
          "id": 14,
          "text": "Se dau tabelele \nANGAJATI(ID-Angajat, Nume, ID-Compart, Salariu) \nCOMPARTIMENT (ID-Compart, Nume-Compart) \nsi urmatoarea interogare: \nSELECT e.EMPLOYEE_ID,e.LAST_NAME,e.DEPARTMENT_ID, d.DEPARTMENT_NAME \nFROM EMP e, DEPARTMENT d \nWHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID; \n\nCe operatii implementeaza aceasta interogare?",
          "options": {
            "A": "Diferenta, proiectia si join",
            "B": "Selectia, proiectia si join",
            "C": "Selectia, intersectia si join",
            "D": "Intersectia, proiectia si join",
            "E": "Diferenta, intersectia si join"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "The query provided performs three main operations: selection, projection, and join.\n\n1. **Join**: The query uses a join condition (`WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID`) to combine rows from the `EMP` (employees) and `DEPARTMENT` tables based on the matching department IDs. This operation allows the retrieval of related data from both tables.\n\n2. **Projection**: The `SELECT` clause specifies which columns to retrieve from the combined data set: `e.EMPLOYEE_ID`, `e.LAST_NAME`, `e.DEPARTMENT_ID`, and `d.DEPARTMENT_NAME`. This operation involves selecting specific columns from the result set.\n\n3. **Selection**: The join"
        },
        {
          "id": 15,
          "text": "Se da tabelul \nSTUDENT(CNP, Nume, Grupa, Adresa) cu cheia primara CNP \nsi urmatoarele doua declansatoare: \n\nD1. CREATE OR REPLACE TRIGGER t1 \n BEFORE INSERT ON STUDENT \n REFERENCING OLD AS OLD NEW AS NEW \n FOR EACH ROW \n BEGIN \n  SELECT NVL(MAX(CNP),100)+1 INTO:NEW.CNP FROM STUDENT; \n END; \nD2. CREATE SEQUENCE secventa INCREMENT BY 1 \n INVALUE 101 MAXVALUE 500 NOCYCLE NOCACHE ORDER; \n\n CREATE OR REPLACE TRIGGER t2 \n BEFORE INSERT ON STUDENT \n REFERENCING OLD AS OLD NEW AS NEW \n FOR EACH ROW \n BEGIN \n  SELECT secventa.NEXTVAL INTO:NEW.CNP FROM STUDENT; \n END; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Declansatorul D1 atribuie o valoare maxima atributului CNP  inainte de o noua inserare",
            "B": "Cele doua declasatoare produc acelasi rezultat",
            "C": "Declansatorul D2 nu violeaza restrictia de cheie primara",
            "D": "Declansatorul D1 poate viola restrictia de cheie primara",
            "E": "Cele doua declasatoare nu produc acelasi rezultat"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "To understand the question, we need to analyze the behavior of the triggers and the sequence:\n\nA. **Declansatorul D1 atribuie o valoare maxima atributului CNP inainte de o noua inserare**  \n   This statement is true because Trigger D1 selects the maximum CNP value from the STUDENT table, adds 1 to it, and assigns this value to the new CNP before an insert.\n\nB. **Cele doua declasatoare produc acelasi rezultat**  \n   This statement is not true. Although both triggers aim to provide a new CNP value before inserting a record, the values they produce may differ. D1 uses the maximum existing CNP plus one, while D2 uses a sequence which may"
        },
        {
          "id": 16,
          "text": "Se dau tabelele \nANGAJATI(ID-Angajat, Nume, ID-Compart, Salariu) \nCOMPARTIMENT (ID-Compart, Nume-Compart) \nsi urmatorul declansator: \n\nCREATE OR REPLACE TRIGGER actual \nAFTER UPDATE OF ID_Compart ON COMPARTIMENT \nREFERENCING OLD AS OLD NEW AS NEW \nFOR EACH ROW \nBEGIN \n UPDATE ANGAJATI SET ID_Compart=:NEW.ID_Compart WHERE ID_Compart=:OLD.ID_Compart; \nEND; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Comanda UPDATE trebuie sa se limiteze numai la o linie a tabelei COM- PARTIMENT",
            "B": "Declansatorul implementeaza optiunea UPDATE CASCADE din Oracle",
            "C": "Declansatorul se va lansa numai la modificarea atributului ID-Compart din tabela COMPARTIMENT",
            "D": "Comanda UPDATE poate modifica mai multe linii din tabela ANGAJATI",
            "E": "Comanda UPDATE nu poate modifica mai multe linii din tabela ANGAJATI"
          },
          "correct_answer": [
            "A",
            "B",
            "C",
            "D"
          ],
          "explanation": "The given trigger is designed to handle updates on the `ID_Compart` column in the `COMPARTIMENT` table. Here's a breakdown of why each of the selected statements is true:\n\nA. Comanda UPDATE trebuie sa se limiteze numai la o linie a tabelei COMPARTIMENT  \n   - True: The trigger is defined to fire after an update on `ID_Compart` for each row in the `COMPARTIMENT` table. This implies that the update statement triggering this action should ideally affect only a single row at a time in `COMPARTIMENT` for this trigger to execute properly.\n\nB. Declansatorul implementeaza optiunea UPDATE CASCADE din Oracle  \n   - True: The trigger effectively mim"
        },
        {
          "id": 17,
          "text": "Se da tabelul \nPERSONAL(Marca, Numepren,Compart,Datasv,Salorar,Salorarco,Compart) \nsi urmatorul bloc PL/SQL: \n\nDECLARE \nani_etalon PLS_INTEGER := 15; \nnumar PLS_INTEGER; \n BEGIN \n UPDATE personal SET salorar = salorar + 10 \n WHERE MONTHS_BETWEEN (SYSDATE,datasv) / 12 >= ani_etalon; \n IF SQL%FOUND THEN \n  DBMS_OUTPUT.PUT_LINE(’Exista cel putin un angajat cu vechime de peste ’ || \n  ani_etalon ||’ ani’); \n  numar:= SQL%ROWCOUNT; \n  DBMS_OUTPUT.PUT_LINE(’Numarul lor este ’ || numar); \n ELSE \n  DBMS_OUTPUT.PUT_LINE(’Nici un angajat nu indeplineste conditia’); \n END IF; \n END; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Blocul mareste cu 10 lei salariul orar al tuturor angajatilor",
            "B": "Este un exemplu de cursor implicit",
            "C": "Blocul mareste cu 10 lei salariul orar al angajatilor cu o vechime de peste 15 ani",
            "D": "Pentru afisarea la ecran a mesajelor din bloc, trebuie lansata comanda SET SERVEROUTPUT",
            "E": "Blocul mareste cu 12 lei salariul orar al tuturor angajatilor"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "The PL/SQL block provided involves updating the salaries of employees in a database table named PERSONAL. Here's an explanation for each statement:\n\nA. **False** - The block does not increase the hourly salary of all employees, only those with more than 15 years of service.\n\nB. **True** - This is an example of using an implicit cursor. PL/SQL automatically creates an implicit cursor for SQL statements like UPDATE, and attributes like SQL%FOUND and SQL%ROWCOUNT are used to check the execution result.\n\nC. **True** - The block specifically updates the hourly salary (salorar) by 10 for employees who have more than 15 years of service, as calculated by the condition `MONTHS_BETWEEN(SYSD"
        },
        {
          "id": 18,
          "text": "Se dau tabelele \nPERSONAL(Marca, Numepren, Compart, Datasv, Salorar,Salorarco, Compart) \nPONTAJE(Marca, Data, Orelucrate, Oreco, Orenoapte, Oreabsnem) \nsi urmatoarea procedura: \n\nCREATE OR REPLACE PROCEDURE populare \n(an_ IN salarii.an%TYPE, luna_ IN salarii.luna%TYPE) \nIS \nprima_zi DATE ; \nzi DATE ; \nBEGIN \nprima_zi := TO_DATE(’01/’|| luna_ ||’/’||an_ , ’DD/MM/YYYY’) ; \nzi := prima_zi ; \n WHILE zi <= LAST_DAY(prima_zi) LOOP \n IF RTRIM(TO_CHAR(zi,’DAY’)) IN (’SATURDAY’, ’SUNDAY’) THEN \n  NULL; \n ELSE \n BEGIN \n  INSERT INTO pontaje (marca, data) \n  SELECT marca, zi FROM personal; \n  EXCEPTION \n  WHEN DUP_VAL_ON_INDEX THEN \n  DELETE FROM pontaje WHERE data = zi ; \n  INSERT INTO pontaje (marca, data) \n  SELECT marca, zi FROM personal ; \n END ; \nEND IF ; \nzi:= zi + 1; \n END LOOP; \n COMMIT; \nEND populare; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Procedura nu permite incalcarea restrictiei de cheie primara",
            "B": "Variabilele an si luna sunt parametrii formali",
            "C": "Procedura populeaza tabela PONTAJE pe o luna si un an cu date din tabela PERSONAL",
            "D": "Apelul se face astfel: populare(07,2008);",
            "E": "Apelul se face astfel: populare(2008,07);"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "Explanation:\n\nA. Procedura nu permite incalcarea restrictiei de cheie primara - This statement is true. The procedure handles potential primary key violations by using an exception handler. If an attempt to insert data violates the primary key constraint (DUP_VAL_ON_INDEX), it deletes the conflicting entries and then retries the insertion, ensuring that the primary key constraint is not violated.\n\nB. Variabilele an si luna sunt parametrii formali - This statement is true. In the procedure definition, `an_` and `luna_` are declared as input parameters (an_ IN, luna_ IN) and are used as formal parameters within the procedure.\n\nC. Procedura populeaza tabela PONTAJE pe o luna"
        },
        {
          "id": 19,
          "text": "Fie tabelul \nANGAJAT(Marca, Numepren, Compart, Datasv, Salorar,Salorarco, Compart)\n cu interogarea \nSELECT marca, Numepren, Datasv, vechime(datasv,2008,7) FROM ANGAJAT) \nsi functia \n\nCREATE OR REPLACE FUNCTION vechime \n(Datasv_ DATE, An_ Number(4), Luna_ Number(2)) \nRETURN Integer \nAS \nprima_zi DATE:=TO_DATE(’01/’||luna_||’/’||an_,’DD/MM/YYYY’); \nBEGIN \n RETURN TRUNC(MONTHS_BETWEEN(prima_zi,Datasv_)/12,0); \nEND; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Interogarea produce o singura valoare",
            "B": "Apelul functiei nu este plasat corectin interogare",
            "C": "Functia calculeaza numarul de ani dintre o datasi prima zi a lunii de referinta",
            "D": "Functia si interogarea sunt corecte",
            "E": "Interogarea produce mai multe valori"
          },
          "correct_answer": [
            "C",
            "D"
          ],
          "explanation": "The question involves analyzing a SQL query using a custom PL/SQL function. Let's break down the relevant components:\n\n1. **Function `vechime`:** This function calculates the number of full years between a given date (`Datasv_`) and the first day of a specified month and year (`prima_zi`). It uses `MONTHS_BETWEEN` to find the difference in months and then divides by 12 to convert it to years, truncating to get the full years.\n\n2. **Query:** The SQL query retrieves the `marca`, `Numepren`, and `Datasv` fields from the `ANGAJAT` table and calculates the seniority using the `vechime` function, with a reference date of"
        },
        {
          "id": 20,
          "text": "In definirea unui cursor explicit exista urmatoarele 5 operatiuni: \n1. Declararea variabileiin care va fi stocata o linie a cursorului \n2. Deschiderea cursorului (OPEN) \n3. Declararea cursorului printr-o fraza SELECT (CURSOR nume IS SELECT ...) \n4. Structura de ciclare ce include, obligatoriu, o comanda deincarcare a \nurmatoarelor linii din cursor altfel bucla se repeta la infinit \n5. Incarcarea urmatoarei linii din cursor (FETCH) Care este ordinea corecta a acestor operatii?",
          "options": {
            "A": "3,2,1,4,5",
            "B": "3,1,2,5,4",
            "C": "2,3,1,5,4",
            "D": "1,3,2,4,5",
            "E": "2,1,3,4,5"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In the process of defining and using an explicit cursor, the operations must be performed in a specific order to ensure the cursor functions correctly. Here's the correct order with an explanation:\n\n1. **Declararea cursorului printr-o fraza SELECT (CURSOR nume IS SELECT ...) (Step 3):** Before anything else, the cursor must be declared. This involves specifying the SQL query that the cursor will execute, establishing what data the cursor will manage.\n\n2. **Declararea variabilei in care va fi stocata o linie a cursorului (Step 1):** After declaring the cursor, a variable must be defined to hold the data from each row fetched by the cursor. This step is essential for processing the data retrieved"
        }
      ]
    },
    {
      "name": "Tehnologii Web",
      "questions": [
        {
          "id": 1,
          "text": "Care este rezultatul urmatoarei operatiiin JavaScript: “1” + 2 + 4 ?",
          "options": {
            "A": "124",
            "B": "\"124\"",
            "C": "eroare,asemenea operatii nu pot fi efectuate",
            "D": "“1” si 24",
            "E": "“1” si 6"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "In JavaScript, the `+` operator can be used for both addition and string concatenation. When using the `+` operator, if one of the operands is a string, JavaScript will convert the other operand to a string and perform concatenation. In the expression `\"1\" + 2 + 4`, `\"1\"` is a string, so `2` is converted to a string and concatenated, resulting in `\"12\"`. Then, `4` is also converted to a string and concatenated, resulting in the final string `\"124\"`. Therefore, the correct answer is B."
        },
        {
          "id": 2,
          "text": "Care este rezultatul urmatoarei operatiiin JavaScript: 2 + 5 + “8”?",
          "options": {
            "A": "\"78\"",
            "B": "eroare, asemenea operatii nu pot fi efectuate",
            "C": "78",
            "D": "“258”",
            "E": "258"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In JavaScript, the `+` operator is used for both addition and string concatenation. When an expression contains both numbers and strings, JavaScript performs type coercion, converting the numbers to strings if necessary to concatenate them. In the expression `2 + 5 + \"8\"`, the operations are evaluated from left to right. First, `2 + 5` is evaluated, resulting in the number `7`. Then, `7` is concatenated with the string `\"8\"`, resulting in the string `\"78\"`. Therefore, the correct answer is A: `\"78\"`."
        },
        {
          "id": 3,
          "text": "Ce face operatorul “= = =”in JavaScript?",
          "options": {
            "A": "nu exista acest operator",
            "B": "operatorul este adevarat doar daca operatorii sunt egali fara nicio conversie de tip",
            "C": "este operatorul egal strict",
            "D": "operatorul este adevarat daca operatorii sunt egali dupa o conversie de tip",
            "E": "operatorul se foloseste doarin cazul string-urilor"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "In JavaScript, the operator \"===\" is known as the strict equality operator. It checks for equality between two values without performing any type conversion, meaning the values must be of the same type and have the same value for the comparison to return true. This distinguishes it from the \"==\" operator, which does perform type conversion. Therefore, the correct explanations for the function of \"===\" are B, as it is true only if the operands are equal without type conversion, and C, since it is referred to as the strict equality operator."
        },
        {
          "id": 4,
          "text": "Ce face urmatoarea regula CSS? p {color: red}",
          "options": {
            "A": "scrie cu rosu toate textele din toate paragrafele",
            "B": "scrie cu rosu textul din paragraful urmator",
            "C": "atribuie variabilei p culoarea rosu",
            "D": "schimba culoarea fundaluluiin rosu",
            "E": "functia p are ca parametru culoarea rosu"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Explanation: The CSS rule `p {color: red}` targets all `<p>` elements (paragraphs) in an HTML document and sets their text color to red. In CSS, the `color` property affects the text color of the selected elements. Since `p` is a selector for paragraph elements, option A correctly describes the effect of the rule as changing the text color of all paragraphs to red. The other options incorrectly describe the effect of the rule, either by misinterpreting the CSS syntax or by assigning the property to the wrong aspect (such as the background or a variable)."
        },
        {
          "id": 5,
          "text": "Ce face urmatoarea regula CSS? p em {color:green}",
          "options": {
            "A": "textul scris in stil italic din paragrafe este verde",
            "B": "textele din paragrafe sunt scrise cu culoarea verde",
            "C": "textul scrisin stil italic din paragraful urmator este verde",
            "D": "cuvantul em din paragraful urmator este scris cu verde",
            "E": "regula este scrisa gresit"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The CSS rule `p em {color:green}` targets all `<em>` elements that are nested within `<p>` (paragraph) elements and sets their text color to green. The `<em>` tag is used to emphasize text, and it typically renders as italicized text in most browsers. Therefore, the rule specifically changes the color of the emphasized (italic) text within paragraphs to green, making option A the correct answer."
        },
        {
          "id": 6,
          "text": "Ce rezultat are urm˘atorul cod HTML?\n<TABLE BORDER=”2” CELLPADDING=”2” WIDTH=”100%”>\n    <TR onMouseover=”this.bgColor=’#EEEEEE’”onMouseout=”this.bgColor=’#FFFFFF’”>\n        <TD>Your Table Data</TD>\n        </TR><TR onMouseover=”this.bgColor=’#EEEEEE’”onMouseout=”this.bgColor=’#FFFFFF’”>\n    <TD>Your Table Data</TD></TR>\n        <TR onMouseover=”this.bgColor=’#EEEEEE’”onMouseout=”this.bgColor=’#FFFFFF’”>\n            <TD>Your Table Data</TD></TR></TABLE>",
          "options": {
            "A": "schimba culoare de background a tabelului cand se trece cu mouse-ul pe deasupra acestuia",
            "B": "creeaza un tabel cu 3 coloane",
            "C": "creeaza un tabel",
            "D": "schimba culoarea de background a paginii din #EEEEEE in #FFFFFF cand se trece cu mouse-ul peste tabel",
            "E": "schimba culoarea de background a paginii din #FFFFFF in #EEEEEE cand se trece cu mouse-ul peste tabel"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "The given HTML code creates an HTML table with a border and padding around its cells. The table consists of three rows (`<TR>` elements), each containing a single cell (`<TD>` element) with the text \"Your Table Data\". The `onMouseover` and `onMouseout` attributes in each `<TR>` element are JavaScript event handlers that change the background color of the row when the mouse hovers over it or moves away from it. Specifically, when the mouse is over a row, its background color changes to `#EEEEEE`, and when the mouse leaves the row, the color changes back to `#FFFFFF`. \n\nThus, the correct answers are:\nA. The background color of each table row changes when the"
        },
        {
          "id": 7,
          "text": "Ce rezultat are urmatorul cod?\n<form>\n    <inputtype=”button”value=”Clickme”onclick=”window.open(’http://www.domain.com’)”>\n    </form>",
          "options": {
            "A": "deschide o noua fereastra de browser cu ajutorul unui buton",
            "B": "nu face nimic, variabila onclick nu este declarata",
            "C": "creeaza un buton",
            "D": "creeaza un link catre o noua fereastra de browser",
            "E": "niciunul dintre raspunsurile de mai sus"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "The given HTML code creates a form that contains an input element of type \"button\". This button has a label \"Click me\" and an \"onclick\" event handler that triggers the opening of a new browser window or tab to the specified URL ('http://www.domain.com') when the button is clicked. Therefore, option A is correct because the code will indeed open a new browser window when the button is clicked. Option C is also correct because the code creates a button element in the form. The other options are incorrect: B is wrong because \"onclick\" is an event attribute, not a variable that needs declaration; D is incorrect because the code does not create a link but a button; E is incorrect because both A and C are valid answers"
        },
        {
          "id": 8,
          "text": "Ce rezultat are urmatorul cod JavaScript?\n<a href=”” onMouseOver=”alert(’Your Message’);return true;”>Linked Text</a>",
          "options": {
            "A": "in momentul in care se trece cu mouse-ul peste link sare o fereastra de alertare",
            "B": "in momentulin care se apasa link-ul sare o fereastra de alertare",
            "C": "in momentulin care se trece peste link cu mouse-ul browserul deschide o noua fereastra",
            "D": "nu are niciun efect",
            "E": "niciunul dintre raspunsurile de mai sus"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A. The `onMouseOver` event in JavaScript is triggered when the mouse pointer is moved over the specified element, in this case, the hyperlink (`<a>` tag). When the mouse is hovered over the link, the JavaScript function `alert('Your Message')` is executed, displaying an alert box with the text \"Your Message\". Therefore, as soon as the user moves the mouse over the link, an alert window pops up, corresponding to option A."
        },
        {
          "id": 9,
          "text": "Cum se defineste o constantain PHP?",
          "options": {
            "A": "prin directiva define()",
            "B": "cu ajutorul cuvantului cheie const",
            "C": "cu ajutorul cuvintelor cheie var const",
            "D": "cu ajutorul cuvantului static",
            "E": "cu un Macro"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In PHP, a constant is defined using the `define()` function, which allows you to set a name for the constant and assign it a value. Once defined, the value of a constant cannot be changed during the execution of the script. This is different from variables, which can be modified. The `define()` function is specifically designed for this purpose, making option A the correct choice. Option B, using the `const` keyword, is also a valid way to define constants starting from PHP 5.3, but since the question specifies the use of a directive, `define()` is the more appropriate answer. Options C, D, and E are incorrect as they do not relate to defining constants in PHP."
        },
        {
          "id": 10,
          "text": "Cum se poate trimite un formular fara ajutorul unui buton de “Submit”?",
          "options": {
            "A": "cu ajutorul unui hyperlink",
            "B": "cu ajutorul unui hyperlink, dar cu ajutorul JavaScript",
            "C": "<a href=\"javascript: document.myform.submit();\">Submit Me</a>",
            "D": "<a href=” myform.submit();”>Submit Me</a>",
            "E": "nu se poate trimite"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "To submit a form without using a traditional \"Submit\" button, one can utilize hyperlinks in conjunction with JavaScript. Option B is correct because it mentions using a hyperlink along with JavaScript, which can be used to trigger form submission. Option C specifically demonstrates this by using an anchor tag with an `href` attribute that calls a JavaScript function to submit the form (`document.myform.submit();`). This effectively submits the form when the hyperlink is clicked. Option D is incorrect due to syntax errors, and option E is incorrect because it is indeed possible to submit a form without a submit button by using JavaScript."
        },
        {
          "id": 11,
          "text": "De ce urmatorul cod nu afiseaza o noua linie corect?\n<?php $str = ‘Hello, there.\\nHow are you?\\nThanks for visiting fyicenter’; print $str; ?>\n",
          "options": {
            "A": "pentru ca \\nn\" nu este interpretat ca o linie noua",
            "B": "afiseaza corect linia noua",
            "C": "\\n\" si \\n\" sunt afisate ca o secventa de caractere",
            "D": "lipseste directiva newLine();",
            "E": "lipseste directiva println();"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "In PHP, single-quoted strings do not interpret escape sequences like `\\n` as special characters. Instead, they are treated as literal text. Therefore, in the given code, `\\n` is not interpreted as a newline character but is displayed as the two characters `\\` and `n`. This is why the correct answers are A and C: the newline escape sequence `\\n` is not interpreted as a new line, and it is displayed as a sequence of characters. To achieve the intended behavior, double quotes should be used around the string, or the newline should be explicitly added using concatenation or other methods."
        },
        {
          "id": 12,
          "text": "Care este lungimea maxima a unui nume de tabel, de baza de date sau campin MySQL?",
          "options": {
            "A": "tabel: 64 de caractere, baza de date: 64 de caractere, camp: 64 de caractere",
            "B": "48 de caractere, baza de date: 64 de caractere, camp: 48 de caractere",
            "C": "8 de caractere, baza de date: 8 de caractere, camp: 8 de caractere",
            "D": "64 de caractere, baza de date: 64 de caractere, camp: 63 de caractere",
            "E": "nu exista limita de lungime"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In MySQL, the maximum length for the names of tables, databases, and columns (fields) is defined by the system. The correct values are as follows:\n\n- **Table Name**: The maximum length for a table name is 64 characters.\n- **Database Name**: Similarly, the maximum length for a database name is 64 characters.\n- **Column Name**: The maximum length for a column (field) name is also 64 characters.\n\nThese limits are set to ensure that the names are manageable and do not cause issues within the database system. The correct answer is option A, which states that the maximum length for all three—table, database, and field names—is 64 characters. Options B, C, D,"
        },
        {
          "id": 13,
          "text": "Care din urmatoarele functii sunt functii de criptarein PHP?",
          "options": {
            "A": "CRYPT()",
            "B": "MD5()",
            "C": "CRYPTED()",
            "D": "MD6()",
            "E": "ENCRYPT()"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "In PHP, functions related to encryption and hashing are used to secure data. \n\n- **A. CRYPT()**: This function is a built-in PHP function used for hashing strings using one-way hashing algorithms. It is commonly used for password hashing.\n\n- **B. MD5()**: This function generates a 32-character hexadecimal number, which is a hash value, from a given input string. While it is not recommended for secure encryption due to vulnerabilities, it is still considered a hashing function.\n\n- **C. CRYPTED()**: There is no such function in PHP by this name. It might seem like a variation of CRYPT(), but it is not a valid PHP function.\n\n- **D. MD6()**"
        },
        {
          "id": 14,
          "text": "Ce efect are urmatoarea linie de cod:\n<marquee>THIS WILL DISAPPEAR</marquee>?",
          "options": {
            "A": "textul disparein fundal",
            "B": "textul se plimba pe ecran de la stanga la dreapta",
            "C": "textul se plimba pe ecran de la dreapta la stanga",
            "D": "afiseaza un dreptunghi cu textul THIS WILL DISAPPER",
            "E": "marcheaza textul THIS WILL DISAPPEAR"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The `<marquee>` HTML tag is used to create scrolling text effects on a webpage. By default, the text within the `<marquee>` tag moves from right to left across the screen. Therefore, the correct answer is C: \"textul se plimba pe ecran de la dreapta la stanga,\" which means \"the text moves across the screen from right to left.\" This behavior is a visual effect that draws attention to the text by making it appear to move continuously in the specified direction. Note that the `<marquee>` tag is deprecated in HTML5, and its use is generally discouraged in favor of CSS animations."
        },
        {
          "id": 15,
          "text": "Care dintre sintaxele urmatoare este corecta?",
          "options": {
            "A": "body {color: black}",
            "B": "{body;color:black}",
            "C": "body:color=black",
            "D": "{body:color=black(body}",
            "E": "{body=color:black(body)}"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In CSS, the correct syntax for styling elements involves using a selector followed by curly braces enclosing property-value pairs. Option A, `body {color: black}`, is correct because it follows this structure: the selector `body` is followed by curly braces, which contain the property `color` and its value `black`, separated by a colon. The other options contain syntax errors, such as misplaced characters or incorrect use of symbols, which do not conform to the standard CSS syntax rules."
        },
        {
          "id": 16,
          "text": "Cum se adauga aceeasi culoare de background pentru toate elementele <h1>?",
          "options": {
            "A": "h1 {background-color:#FFFFFF}",
            "B": "h1.all {background-color:#FFFFFF}",
            "C": "all.h1 {background-color:#FFFFFF}",
            "D": "h1 ={background-color:#FFFFFF}",
            "E": "h1 :{background-color:#FFFFFF"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "To apply the same background color to all `<h1>` elements, you need to use a CSS selector that targets all `<h1>` elements. The correct syntax for this is `h1 {background-color:#FFFFFF;}`. This rule applies the specified background color to every `<h1>` element in the document. Option A is correct because it uses the correct syntax for a CSS rule: the selector `h1` targets all `<h1>` elements, and `{background-color:#FFFFFF;}` applies the white background color to them. Other options either use incorrect selectors, do not use the correct CSS syntax, or misuse colons and brackets."
        },
        {
          "id": 17,
          "text": "Care este eticheta corecta HTML pentru a scrie un text cu bold?",
          "options": {
            "A": "<b>",
            "B": "<bold>",
            "C": "<bld>",
            "D": "<bb>",
            "E": "B"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Explanation: In HTML, the `<b>` tag is used to create bold text. It is the correct tag for making text appear in bold typeface, without implying any extra importance or emphasis. The other options, `<bold>`, `<bld>`, `<bb>`, and `B`, are not valid HTML tags for bold text."
        },
        {
          "id": 18,
          "text": "Care este eticheta corecta HTML pentru a scrie un hyperlink?",
          "options": {
            "A": "<a>http://www.w3schools.com</a>",
            "B": "<a url=”http://www.w3schools.com”>W3Schools.com</a>",
            "C": "<a href=\"http://www.w3schools.com\">W3Schools</a>",
            "D": "<a name=”http://www.w3schools.com”>W3Schools.com</a>",
            "E": "<a href=”http://www.w3schools.com”>W3Schools<a>"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In HTML, a hyperlink is created using the `<a>` (anchor) tag, which requires the `href` attribute to specify the URL of the page the link goes to. The link text, which is the clickable part, is placed between the opening `<a>` tag and the closing `</a>` tag. Option C correctly uses the `href` attribute to define the URL and provides link text between the tags. Therefore, `<a href=\"http://www.w3schools.com\">W3Schools</a>` is the correct format for writing a hyperlink in HTML. Other options either use incorrect attributes or have syntax errors, such as missing the closing tag or using incorrect attribute names."
        },
        {
          "id": 19,
          "text": "Care este eticheta corecta HTML pentru un link e-mail?",
          "options": {
            "A": "<mail>aaa@yyy</mail>",
            "B": "<a href=”aaa@yyy”>",
            "C": "<mail href=”aaa@yyy”>",
            "D": "<a href=\"mailto:aaa@yyy\">",
            "E": "<a href=”mailto:aaa@yyy”></a>"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The correct label for creating an email link in HTML is D: `<a href=\"mailto:aaa@yyy\">`. This option correctly uses the `<a>` tag, which is designed for hyperlinks, and the `href` attribute with the `mailto:` protocol, indicating that the link should open the user's default email client to send an email to the specified address. Option E is also technically correct in terms of syntax, as it includes closing tags, but D is the most concise correct answer without additional elements."
        },
        {
          "id": 20,
          "text": "Care este eticheta corecta HTML pentru liste numerotate?",
          "options": {
            "A": "<ul>",
            "B": "<dl>",
            "C": "<ol>",
            "D": "<list>",
            "E": "<numl>"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In HTML, different tags are used to create different types of lists. The tag `<ol>` stands for \"ordered list\" and is used to create lists where each item is numbered. This is why the correct answer is C. The `<ul>` tag is used for unordered lists (bulleted), `<dl>` is used for definition lists, and `<list>` and `<numl>` are not standard HTML tags."
        },
        {
          "id": 21,
          "text": "Care este eticheta corecta HTML pentru inserarea unei imagini?",
          "options": {
            "A": "<img href=”image.gif>",
            "B": "<img>image.gif</img>",
            "C": "<image src=”image.gif”>",
            "D": "<img src=\"image.gif\">",
            "E": "<image src=”image.gif”></image>"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The correct answer is D. In HTML, to insert an image, the `<img>` tag is used, and the `src` attribute specifies the path to the image file. The correct syntax is `<img src=\"image.gif\">`. Unlike some other HTML tags, `<img>` is self-closing and does not require a closing tag. Option A is incorrect because it uses `href` instead of `src`. Option B incorrectly uses `<img>` as a container tag with closing tags. Option C incorrectly uses the `<image>` tag, which is not valid in HTML. Option E also incorrectly uses the `<image>` tag and includes unnecessary closing tags."
        },
        {
          "id": 22,
          "text": "Ce face urmatorul script JavaScript?\n<body>\n    <script language=”JavaScript”>\n        <!–\n        var myVariable = “Hello there”;\n        var therePlace = myVariable.search(“there”);\n        document.write(therePlace);\n        –>\n    </script>\n</body>",
          "options": {
            "A": "cauta un anumit cuvant intr-un text",
            "B": "cauta cuvantul \\there\" in \\Hello there\"",
            "C": "cauta cuvantul \\there\"",
            "D": "scrie variabila \\therePlace\"",
            "E": "cauta un anumit cuvant in string-ul \\Hello there\""
          },
          "correct_answer": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "explanation": "The script in question performs multiple actions related to searching for a specific word within a string and displaying the result. Here's a breakdown of what it does:\n\n1. **Initialization**: The script initializes a variable `myVariable` with the string \"Hello there\".\n\n2. **Searching for a Word**: It uses the `search()` method to find the position of the substring \"there\" within `myVariable`. The method returns the index of the first occurrence of the specified substring, which is 6 in this case.\n\n3. **Storing the Result**: The result of the search, which is a number indicating the position of \"there\" in the string \"Hello there\", is stored in the variable `therePlace`.\n\n4. **"
        },
        {
          "id": 23,
          "text": "Inauntrul carui element HTML putem scrie un script JavaScript?",
          "options": {
            "A": "<script>",
            "B": "<js>",
            "C": "<javascript>",
            "D": "<scripting>",
            "E": "<jscript>"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct element to use for including JavaScript code in an HTML document is the `<script>` element. This is the standard and universally recognized HTML tag for embedding or referencing JavaScript code. Options B (`<js>`), C (`<javascript>`), D (`<scripting>`), and E (`<jscript>`) are not valid HTML tags for including JavaScript."
        },
        {
          "id": 24,
          "text": "Care este sintaxa corecta Javascript pentru a scrie “Hello World”?",
          "options": {
            "A": "document.write(\"Hello World\")",
            "B": "”Hello World”",
            "C": "”Hello World”",
            "D": "response.write(”Hello World”)",
            "E": "document.write(Hello World”)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In JavaScript, the `document.write()` method is used to output text directly to the HTML document. The correct syntax for writing \"Hello World\" using this method is `document.write(\"Hello World\")`, which is option A. Options B and C are incorrect because they do not use any JavaScript method or function to output the text. Option D uses `response.write`, which is not a standard JavaScript method for writing to an HTML document. Option E is incorrect due to a missing opening quote for the string \"Hello World\"."
        },
        {
          "id": 25,
          "text": "Cum se scrie “Hello World” intr-o fereastra alert?",
          "options": {
            "A": "alertBox=”Hello World”",
            "B": "alertBox(”Hello World”)",
            "C": "msgBox(”Hello World”)",
            "D": "alert(\"Hello World\")",
            "E": "winalert(“Hello World”)"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The question asks how to display \"Hello World\" in an alert window using JavaScript. \n\nExplanation: \n- Option D, `alert(\"Hello World\")`, is the correct syntax for creating a pop-up alert dialog in JavaScript that displays the message \"Hello World\". \n- Option A, `alertBox=”Hello World”`, is incorrect because `alertBox` is not a function or method used for alerts in JavaScript; it looks like an assignment operation.\n- Option B, `alertBox(”Hello World”)`, is incorrect as `alertBox` is not a recognized JavaScript function for alerts.\n- Option C, `msgBox(”Hello World”)`, is incorrect because `msgBox` is not a JavaScript"
        },
        {
          "id": 26,
          "text": "Care sunt delimitatorii pentru script-urile PHP?",
          "options": {
            "A": "<script language=\"php\">...</script>",
            "B": "<?php...?>",
            "C": "<&>...</&>",
            "D": "¡<?php>...</?>",
            "E": "<php>...</php>"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "In PHP, scripts are typically embedded within HTML, and specific delimiters are used to indicate the start and end of PHP code. The correct delimiters are:\n\nA. `<script language=\"php\">...</script>`: Although not commonly used, this syntax can be valid in certain configurations where PHP is parsed within script tags, but it's unconventional.\n\nB. `<?php...?>`: This is the standard and most widely used tag for embedding PHP code within a document. It tells the PHP parser to start interpreting the code following the `<?php` and to stop at the `?>`.\n\nThe other options are incorrect:\n\nC. `<&>...</&>`: This is not a valid PHP syntax.\n\nD. `¡<?php>...</?>"
        },
        {
          "id": 27,
          "text": "Cum se scrie “Hello World” in PHP?",
          "options": {
            "A": "Document.Write(”Hello World”);",
            "B": "document.write(”Hello World”);",
            "C": "echo \"Hello World\";",
            "D": "”Hello World”;",
            "E": "System.out.println(“Hello World”);"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In PHP, the `echo` statement is used to output text to the screen. Among the options provided, option C, `echo \"Hello World\";`, correctly uses the `echo` command to display the string \"Hello World\". The other options pertain to different programming languages: A and B are JavaScript, D is an incomplete or incorrect expression, and E is Java, making C the correct choice for PHP."
        },
        {
          "id": 28,
          "text": "Variabilele in PHP incep cu:",
          "options": {
            "A": "$",
            "B": "&",
            "C": "!",
            "D": "Nimic",
            "E": "%"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In PHP, all variable names must begin with a dollar sign (`$`). This is a syntax requirement of the language, indicating that the following sequence of characters is a variable. The use of the dollar sign helps PHP distinguish variables from other types of identifiers within the code. Therefore, the correct answer is A."
        },
        {
          "id": 29,
          "text": "Ce inseamna CSS?",
          "options": {
            "A": "Cascading Style Sheets",
            "B": "Colorful Style Sheets",
            "C": "Creative Style Sheets",
            "D": "Computer Style Sheets",
            "E": "Cascade Style Sheets"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "CSS stands for \"Cascading Style Sheets,\" which is a style sheet language used to describe the presentation of a document written in HTML or XML. It allows web developers to separate the content of a webpage from its design, making it easier to manage the layout, colors, fonts, and overall appearance of the site. The term \"cascading\" refers to the way styles are applied and prioritized, allowing for multiple style rules to be combined and applied consistently across web pages."
        },
        {
          "id": 30,
          "text": "Care este sintaxa unei reguli CSS?",
          "options": {
            "A": "selector {proprietate : valoare}",
            "B": "selector(proprietate, valoare)",
            "C": "selector.proprietate = valoare",
            "D": "selector(proprietate) = valoare",
            "E": "{selector.proprietate = valoare}"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The correct answer is A: \"selector {proprietate : valoare}\". This syntax is used in CSS to define the style for a specific HTML element or group of elements, where \"selector\" targets the HTML element(s), \"proprietate\" specifies the CSS property to be styled, and \"valoare\" defines the value for that property. The properties and values are enclosed within curly braces and separated by a colon, with each property-value pair terminated by a semicolon if there are multiple pairs. This format allows you to apply consistent styling across web pages."
        },
        {
          "id": 31,
          "text": "CSS-ul se foloseste pentru:",
          "options": {
            "A": "poate fi folosit de mai multi agenti (browser, telefon mobil PDA)",
            "B": "separa continutul de prezentare",
            "C": "iti confirma faptul ca ai scris codul corect",
            "D": "a crea programe stand-alone",
            "E": "a face legatura cu o baza de date"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "CSS (Cascading Style Sheets) is primarily used for styling and formatting web pages. Here's a brief explanation for each correct option:\n\nA. **Poate fi folosit de mai multi agenti (browser, telefon mobil PDA):** CSS is designed to ensure that web content is accessible and presentable across various devices and platforms, including different web browsers and mobile devices like phones and PDAs. This adaptability is one of the strengths of CSS, allowing for a consistent user experience across different environments.\n\nB. **Separa continutul de prezentare:** One of the core purposes of CSS is to separate the content (HTML) from its presentation (styling). This separation allows for more flexible design and easier maintenance, as changes to the presentation"
        },
        {
          "id": 32,
          "text": "Ce efect are urmatoarea regula CSS? fcolor:green;g",
          "options": {
            "A": "totul o sa fie transformat in verde",
            "B": "* din text sunt transformatein verde",
            "C": "regula este un comentariu",
            "D": "regula este scrisa gresit",
            "E": "nu are niciun efect"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The given CSS rule `fcolor:green;g` appears to be a typo or incorrect syntax. In standard CSS, the correct property to change text color is `color`, not `fcolor`. Due to this incorrect syntax, the rule will not be interpreted correctly by browsers and will have no effect on the styling of the elements. Therefore, the correct answer should actually be D: the rule is written incorrectly, which means the rule will not function as intended. However, given that the correct answer is marked as A, it seems there might be an error in the question or answer key."
        },
        {
          "id": 33,
          "text": "Ce efect are urmatoarea regula CSS? \nimg [title] fborder: 2px solid blue;g <img src=”images/sunset.jpg” alt=”Lahina Sunset” title=”Lahina Sunset”>",
          "options": {
            "A": "imaginea o sa aiba o margine de 2px",
            "B": "imaginea o sa aiba marimea de 2px",
            "C": "nu are niciun efect deoarece imaginea nu este inserata corect",
            "D": "scrie titlul imaginii cu albastru inchis",
            "E": "titlul imaginii esteincadrat de o margine de 2px"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "The CSS rule `img[title] { border: 2px solid blue; }` targets any `<img>` element that has a `title` attribute and applies a border to it. In this case, the image `<img src=\"images/sunset.jpg\" alt=\"Lahina Sunset\" title=\"Lahina Sunset\">` includes a `title` attribute, meaning the CSS rule will apply a 2px solid blue border around the image. Therefore, the correct answer is A, as the effect of the CSS rule is to add a border to the image, not to change its size, display the title in a different color, or any of the other options."
        },
        {
          "id": 34,
          "text": "Cum se trimite in PHP un query MySQL?",
          "options": {
            "A": "mysql_query",
            "B": "mysql.query",
            "C": "query.mysql",
            "D": "query_mysql",
            "E": "mysql_q"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "In PHP, the function used to send a query to a MySQL database is `mysql_query()`. This function is specifically designed to execute queries such as SELECT, INSERT, UPDATE, or DELETE on a MySQL database. The syntax matches option A, `mysql_query`, which is the correct answer. The other options do not represent valid PHP functions for executing MySQL queries. However, it's important to note that the `mysql_query()` function is deprecated as of PHP 5.5.0 and removed in PHP 7.0.0, and it is recommended to use MySQLi or PDO_MySQL for database interactions in newer PHP versions."
        },
        {
          "id": 35,
          "text": "Ce inseamna PHP?",
          "options": {
            "A": "Personal Hypertext Processor",
            "B": "PHP: Hypertext Preprocessor",
            "C": "Private Home Page",
            "D": "Personal Home Page",
            "E": "PHP: Private Hypertext Processor"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "PHP originally stood for \"Personal Home Page\" when it was first created by Rasmus Lerdorf in 1994. However, as the language evolved and became more sophisticated, the meaning was changed to \"PHP: Hypertext Preprocessor.\" This is an example of a recursive acronym, where \"PHP\" is included in its own definition. The term reflects the language's primary use for server-side scripting to generate dynamic web pages and manage web content."
        },
        {
          "id": 36,
          "text": "Care este modul corect de a se conecta la o baza de date MySQL?",
          "options": {
            "A": "mysql open(”localhost”);",
            "B": "connect mysql(”localhost”);",
            "C": "mysql connect(\"localhost\");",
            "D": "dbopen(”localhost”);",
            "E": "dbconnetc(“localhost”);"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Explanation: The correct way to connect to a MySQL database typically involves using a function that establishes a connection to the server. In many programming languages and libraries, this is done using a function similar to `mysql_connect(\"localhost\")`. Option C represents a common syntax used in older versions of PHP before the introduction of MySQLi and PDO, where `mysql_connect` is the function used to initiate a connection to a MySQL database server at the specified host, which in this case is \"localhost\". The other options either use incorrect function names or syntax."
        },
        {
          "id": 37,
          "text": "Care este modul corect de a adauga 1 la varibila $count?",
          "options": {
            "A": "$count =+1",
            "B": "++count",
            "C": "$count++;",
            "D": "count++;",
            "E": "$count==1"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In the given multiple choice question, the goal is to find the correct way to increment the variable `$count` by 1 in many programming languages such as PHP, Java, and C++. \n\nOption C, `$count++;`, is the correct answer. This is because the `++` operator is used for incrementing the value of a variable by 1. The post-increment operator `++` placed after the variable name means the current value of `$count` is used in expressions, if any, and then it is incremented by 1.\n\nLet's briefly look at why the other options are incorrect:\n\n- A. `$count =+1`: This is incorrect because it assigns the value `+1` to `$count`, effectively setting"
        },
        {
          "id": 38,
          "text": "Unde este corect sa asezam script-uri Javascript?",
          "options": {
            "A": "sectiunea body",
            "B": "sectiunea head",
            "C": "sectiunea body si sectiunea head",
            "D": "sectiunea title",
            "E": "sectiunea title si head"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "The correct answer is C, which means that JavaScript scripts can be placed in both the body and the head sections of an HTML document. Placing scripts in the head section is common for loading libraries or scripts that need to be available before the content is rendered, while placing them at the end of the body is often used to ensure that the HTML content is fully loaded before the script runs, improving page load performance and user experience. Scripts should not be placed in the title section, so options D and E are incorrect."
        },
        {
          "id": 39,
          "text": "Cum se poate introduce un script extern in Javascript?",
          "options": {
            "A": "<script href=”aaa.js”>",
            "B": "<script name=”aaa.js”>",
            "C": "<script src=\"aaa.js\">",
            "D": "<script src = “aaa.java”",
            "E": "<script src = “aaa.javascript>"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "To include an external JavaScript file in an HTML document, the `<script>` tag is used with the `src` attribute specifying the path to the JavaScript file. Option C, `<script src=\"aaa.js\">`, correctly uses the `src` attribute to reference the external file \"aaa.js\". Options A and B use incorrect attributes (`href` and `name`), while D and E reference files with incorrect extensions (\".java\" and \".javascript\"). The correct extension for a JavaScript file is \".js\"."
        },
        {
          "id": 40,
          "text": "Cum se scriu comentariile in JavaScript?",
          "options": {
            "A": "’Acesta este un comentariu",
            "B": "<!–Acesta este un comentariu –>",
            "C": "//Acesta este un comentariu",
            "D": "Acesta este un comentariu",
            "E": "nu se pot scrie comentariiin JavaScript"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "In JavaScript, comments are used to include explanations or annotations in the code, which are ignored during execution. The correct syntax for writing a single-line comment in JavaScript is by using two forward slashes `//` at the beginning of the comment line. Therefore, option C, `//Acesta este un comentariu`, correctly demonstrates how to write a comment in JavaScript. Other options either represent comment syntax from different languages (like HTML's `<!-- -->`) or do not use any comment syntax at all."
        }
      ]
    }
  ]
}